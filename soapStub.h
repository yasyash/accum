/* soapStub.h
   Generated by gSOAP 2.8.75 for liga.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://liga.AutoChrom.WCFHost/Imports"
#define SOAP_NAMESPACE_OF_ns2	"http://liga.AutoChrom.WCFHost"
#define SOAP_NAMESPACE_OF_ns3	"http://schemas.datacontract.org/2004/07/liga.AutoChrom.Main.Service.Processing"
#define SOAP_NAMESPACE_OF_ns4	"http://schemas.datacontract.org/2004/07/liga.AutoChrom.Main.WorkPlan"
#define SOAP_NAMESPACE_OF_arr	"http://schemas.microsoft.com/2003/10/Serialization/Arrays"
#define SOAP_NAMESPACE_OF_ns5	"http://schemas.datacontract.org/2004/07/liga.AutoChrom.Main.Configurations"
#define SOAP_NAMESPACE_OF_ns6	"http://schemas.datacontract.org/2004/07/liga.AutoChrom.Main.Service.AuxiliaryDevices2"
#define SOAP_NAMESPACE_OF_ns7	"http://schemas.datacontract.org/2004/07/liga.AutoChrom.Main.Service.AuxiliaryDevices"
#define SOAP_NAMESPACE_OF_ns8	"http://schemas.datacontract.org/2004/07/liga.AutoChrom.Main.Library"
#define SOAP_NAMESPACE_OF_ns9	"http://schemas.datacontract.org/2004/07/liga.AutoChrom.Main.Service.Chromatographs"
#define SOAP_NAMESPACE_OF_ns10	"http://schemas.datacontract.org/2004/07/liga.AutoChrom.Main.Entities"
#define SOAP_WSA_2005
#define SOAP_NAMESPACE_OF_wsa5	"http://www.w3.org/2005/08/addressing"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20875
# error "GSOAP VERSION 20875 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* liga.h:443 */
#ifndef SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfoStates
#define SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfoStates (82)
/* ns3:OperationProcInfo.OperationStepInfoStates */
enum ns3__OperationProcInfo_x002eOperationStepInfoStates {
	ns3__OperationProcInfo_x002eOperationStepInfoStates__None = 0,
	ns3__OperationProcInfo_x002eOperationStepInfoStates__NotStarted = 1,
	ns3__OperationProcInfo_x002eOperationStepInfoStates__Running = 2,
	ns3__OperationProcInfo_x002eOperationStepInfoStates__Finished = 3,
	ns3__OperationProcInfo_x002eOperationStepInfoStates__Error = 4
};
#endif

/* liga.h:455 */
#ifndef SOAP_TYPE_ns3__ProcessingModes
#define SOAP_TYPE_ns3__ProcessingModes (83)
/* ns3:ProcessingModes */
enum ns3__ProcessingModes {
	ns3__ProcessingModes__None = 0,
	ns3__ProcessingModes__OperationRunning = 1,
	ns3__ProcessingModes__AutoPlanRunning = 2,
	ns3__ProcessingModes__Stopping = 3,
	ns3__ProcessingModes__Aborting = 4
};
#endif

/* liga.h:475 */
#ifndef SOAP_TYPE_ns4__OperationStepTypes
#define SOAP_TYPE_ns4__OperationStepTypes (84)
/* ns4:OperationStepTypes */
enum ns4__OperationStepTypes {
	ns4__OperationStepTypes__None = 0,
	ns4__OperationStepTypes__WaitTime = 1,
	ns4__OperationStepTypes__WaitMode = 2,
	ns4__OperationStepTypes__WaitWhileMode = 3,
	ns4__OperationStepTypes__WaitConditions = 4,
	ns4__OperationStepTypes__ProgStart = 5,
	ns4__OperationStepTypes__ProgStop = 6,
	ns4__OperationStepTypes__ProgLoadMode = 7,
	ns4__OperationStepTypes__ProgLoadModeConf = 8,
	ns4__OperationStepTypes__ProgButtonStart = 9,
	ns4__OperationStepTypes__ProgButtonStop = 10,
	ns4__OperationStepTypes__ProgButtonCooling = 11,
	ns4__OperationStepTypes__SamplingStart = 12,
	ns4__OperationStepTypes__SamplingStop = 13,
	ns4__OperationStepTypes__CriticalStart = 14,
	ns4__OperationStepTypes__CriticalStop = 15,
	ns4__OperationStepTypes__Calc_USCOREReceiveResult = 16,
	ns4__OperationStepTypes__Calc_USCORERememberLastResult = 17,
	ns4__OperationStepTypes__Device_USCORESendCommand = 18,
	ns4__OperationStepTypes__Device_USCORESendCommand2 = 19
};
#endif

/* liga.h:502 */
#ifndef SOAP_TYPE_ns4__ControlledParametr_x002eControlActionType
#define SOAP_TYPE_ns4__ControlledParametr_x002eControlActionType (85)
/* ns4:ControlledParametr.ControlActionType */
enum ns4__ControlledParametr_x002eControlActionType {
	ns4__ControlledParametr_x002eControlActionType__None = 0,
	ns4__ControlledParametr_x002eControlActionType__Warning = 1,
	ns4__ControlledParametr_x002eControlActionType__Error = 2
};
#endif

/* liga.h:512 */
#ifndef SOAP_TYPE_ns4__OperationTypes
#define SOAP_TYPE_ns4__OperationTypes (86)
/* ns4:OperationTypes */
enum ns4__OperationTypes {
	ns4__OperationTypes__None = 0,
	ns4__OperationTypes__RegularSampling = 1,
	ns4__OperationTypes__ControlSampling = 2,
	ns4__OperationTypes__Clearing = 3,
	ns4__OperationTypes__Cooling = 4,
	ns4__OperationTypes__PreparingAtStart = 5
};
#endif

/* liga.h:565 */
#ifndef SOAP_TYPE_ns8__Logger_x002eLogLevel
#define SOAP_TYPE_ns8__Logger_x002eLogLevel (87)
/* ns8:Logger.LogLevel */
enum ns8__Logger_x002eLogLevel {
	ns8__Logger_x002eLogLevel__Debug = 0,
	ns8__Logger_x002eLogLevel__Info = 1,
	ns8__Logger_x002eLogLevel__Warning = 2,
	ns8__Logger_x002eLogLevel__Error = 3,
	ns8__Logger_x002eLogLevel__Fatal = 4
};
#endif

/* liga.h:585 */
#ifndef SOAP_TYPE_ns9__ChromatographMode
#define SOAP_TYPE_ns9__ChromatographMode (88)
/* ns9:ChromatographMode */
enum ns9__ChromatographMode {
	ns9__ChromatographMode__Null = 0,
	ns9__ChromatographMode__Preparation = 1,
	ns9__ChromatographMode__Awaiting = 2,
	ns9__ChromatographMode__Firing = 3,
	ns9__ChromatographMode__Readiness = 4,
	ns9__ChromatographMode__BlowingPreparation = 5,
	ns9__ChromatographMode__Blowing = 6,
	ns9__ChromatographMode__Economy = 7,
	ns9__ChromatographMode__Cooling = 8,
	ns9__ChromatographMode__Analysis = 9,
	ns9__ChromatographMode__FatalError = 10,
	ns9__ChromatographMode__MethodStaring = 11,
	ns9__ChromatographMode__StartAnalysis = 12,
	ns9__ChromatographMode__Unknown = 13
};
#endif

/* liga.h:614 */
#ifndef SOAP_TYPE_ns10__ESampleTypes
#define SOAP_TYPE_ns10__ESampleTypes (89)
/* ns10:ESampleTypes */
enum ns10__ESampleTypes {
	ns10__ESampleTypes__None = 0,
	ns10__ESampleTypes__Regular = 1,
	ns10__ESampleTypes__Control = 2
};
#endif

/* liga.h:624 */
#ifndef SOAP_TYPE_ns10__EResultStatus
#define SOAP_TYPE_ns10__EResultStatus (90)
/* ns10:EResultStatus */
enum ns10__EResultStatus {
	ns10__EResultStatus__None = 0,
	ns10__EResultStatus__OK = 1,
	ns10__EResultStatus__Error = 2
};
#endif

/* liga.h:634 */
#ifndef SOAP_TYPE_ns10__EResultValueStatus
#define SOAP_TYPE_ns10__EResultValueStatus (91)
/* ns10:EResultValueStatus */
enum ns10__EResultValueStatus {
	ns10__EResultValueStatus__InInterval = 0,
	ns10__EResultValueStatus__LowerInterval = 1,
	ns10__EResultValueStatus__UpperInterval = 2,
	ns10__EResultValueStatus__LowerOrEqualsInterval = 3,
	ns10__EResultValueStatus__UpperOrEqualsInterval = 4
};
#endif

/* liga.h:646 */
#ifndef SOAP_TYPE_ns10__EEventTypes
#define SOAP_TYPE_ns10__EEventTypes (92)
/* ns10:EEventTypes */
enum ns10__EEventTypes {
	ns10__EEventTypes__None = 0
};
#endif

/* wsa5.h:95 */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (236)
/* wsa5:RelationshipType */
enum wsa5__RelationshipType {
	http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0
};
#endif

/* wsa5.h:103 */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (237)
/* wsa5:FaultCodesType */
enum wsa5__FaultCodesType {
	wsa5__InvalidAddressingHeader = 0,
	wsa5__InvalidAddress = 1,
	wsa5__InvalidEPR = 2,
	wsa5__InvalidCardinality = 3,
	wsa5__MissingAddressInEPR = 4,
	wsa5__DuplicateMessageID = 5,
	wsa5__ActionMismatch = 6,
	wsa5__MessageAddressingHeaderRequired = 7,
	wsa5__DestinationUnreachable = 8,
	wsa5__ActionNotSupported = 9,
	wsa5__EndpointUnavailable = 10
};
#endif

/* wsa5.h:253 */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (256)
/* wsa5:IsReferenceParameter */
enum _wsa5__IsReferenceParameter {
	_wsa5__IsReferenceParameter__false = 0,
	_wsa5__IsReferenceParameter__true = 1
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

struct __ser__anyType;	/* ser.h:14 */
class _ns2__StartAutoPlan;	/* liga.h:219 */
class _ns2__StartAutoPlanResponse;	/* liga.h:221 */
class _ns2__StartOperation;	/* liga.h:223 */
class _ns2__StartOperationResponse;	/* liga.h:225 */
class _ns2__StopAnalyzing;	/* liga.h:227 */
class _ns2__StopAnalyzingResponse;	/* liga.h:229 */
class _ns2__AbortAnalyzing;	/* liga.h:231 */
class _ns2__AbortAnalyzingResponse;	/* liga.h:233 */
class _ns2__GetProcessingInfo;	/* liga.h:235 */
class _ns2__GetProcessingInfoResponse;	/* liga.h:237 */
class _ns2__SetIgnoreClearing;	/* liga.h:239 */
class _ns2__SetIgnoreClearingResponse;	/* liga.h:241 */
class _ns2__GetSystemConfigurations;	/* liga.h:243 */
class _ns2__GetSystemConfigurationsResponse;	/* liga.h:245 */
class _ns2__SetSystemConfigurations;	/* liga.h:247 */
class _ns2__SetSystemConfigurationsResponse;	/* liga.h:249 */
class _ns2__GetResults;	/* liga.h:251 */
class _ns2__GetResultsResponse;	/* liga.h:253 */
class _ns2__GetLastResult;	/* liga.h:255 */
class _ns2__GetLastResultResponse;	/* liga.h:257 */
class _ns2__GetLastResultId;	/* liga.h:259 */
class _ns2__GetLastResultIdResponse;	/* liga.h:261 */
class _ns2__GetResultsSinceId;	/* liga.h:263 */
class _ns2__GetResultsSinceIdResponse;	/* liga.h:265 */
class _ns2__GetEvents;	/* liga.h:267 */
class _ns2__GetEventsResponse;	/* liga.h:269 */
class _ns2__GetLastEventId;	/* liga.h:271 */
class _ns2__GetLastEventIdResponse;	/* liga.h:273 */
class _ns2__GetEventsSinceId;	/* liga.h:275 */
class _ns2__GetEventsSinceIdResponse;	/* liga.h:277 */
class ns3__ProcessingInfo;	/* liga.h:279 */
class ns3__OperationProcInfo;	/* liga.h:281 */
class ns3__ArrayOfOperationProcInfo_x002eControlParamInfo;	/* liga.h:283 */
class ns3__OperationProcInfo_x002eControlParamInfo;	/* liga.h:285 */
class ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo;	/* liga.h:287 */
class ns3__OperationProcInfo_x002eOperationStepInfo;	/* liga.h:289 */
class ns4__ArrayOfAutoPlanItem;	/* liga.h:291 */
class ns4__AutoPlanItem;	/* liga.h:293 */
class ns4__Periodicity;	/* liga.h:295 */
class ns4__ArrayOfPeriodicity_x002eTime;	/* liga.h:297 */
class ns4__Periodicity_x002eTime;	/* liga.h:299 */
class ns4__ArrayOfControlledParametr;	/* liga.h:301 */
class ns4__ControlledParametr;	/* liga.h:303 */
class ns4__ArrayOfMeasuringComponent;	/* liga.h:305 */
class ns4__MeasuringComponent;	/* liga.h:307 */
class ns4__ArrayOfOperation;	/* liga.h:309 */
class ns4__Operation;	/* liga.h:311 */
class ns4__ArrayOfOperationStep;	/* liga.h:313 */
class ns4__OperationStep;	/* liga.h:315 */
class ns4__ArrayOfOperationStep_x002eUsingControlledParametr;	/* liga.h:317 */
class ns4__OperationStep_x002eUsingControlledParametr;	/* liga.h:319 */
class arr__ArrayOfstring;	/* liga.h:321 */
class arr__ArrayOfboolean;	/* liga.h:323 */
class ns5__SystemConfigurations;	/* liga.h:325 */
class ns6__Aux2Config;	/* liga.h:327 */
class ns7__AuxControllerConfiguration;	/* liga.h:329 */
class ns7__ArrayOfAuxDevice;	/* liga.h:331 */
class ns7__AuxDevice;	/* liga.h:333 */
class ns7__ArrayOfAuxDeviceState;	/* liga.h:335 */
class ns7__AuxDeviceState;	/* liga.h:337 */
class ns10__ArrayOfESample;	/* liga.h:339 */
class ns10__ESample;	/* liga.h:341 */
class ns10__ArrayOfEResult;	/* liga.h:343 */
class ns10__EResult;	/* liga.h:345 */
class ns10__ArrayOfEEvent;	/* liga.h:347 */
class ns10__EEvent;	/* liga.h:349 */
struct __tempuri__StartAutoPlan;	/* liga.h:2847 */
struct __tempuri__StartOperation;	/* liga.h:2917 */
struct __tempuri__StopAnalyzing;	/* liga.h:2987 */
struct __tempuri__AbortAnalyzing;	/* liga.h:3057 */
struct __tempuri__GetProcessingInfo;	/* liga.h:3127 */
struct __tempuri__SetIgnoreClearing;	/* liga.h:3197 */
struct __tempuri__GetSystemConfigurations;	/* liga.h:3267 */
struct __tempuri__SetSystemConfigurations;	/* liga.h:3337 */
struct __tempuri__GetResults;	/* liga.h:3407 */
struct __tempuri__GetLastResult;	/* liga.h:3477 */
struct __tempuri__GetLastResultId;	/* liga.h:3547 */
struct __tempuri__GetResultsSinceId;	/* liga.h:3617 */
struct __tempuri__GetEvents;	/* liga.h:3687 */
struct __tempuri__GetLastEventId;	/* liga.h:3757 */
struct __tempuri__GetEventsSinceId;	/* liga.h:3827 */
struct wsa5__EndpointReferenceType;	/* wsa5.h:64 */
struct wsa5__ReferenceParametersType;	/* wsa5.h:67 */
struct wsa5__MetadataType;	/* wsa5.h:70 */
struct wsa5__ProblemActionType;	/* wsa5.h:85 */
struct wsa5__RelatesToType;	/* wsa5.h:73 */
struct chan__ChannelInstanceType;	/* wsa5.h:259 */

/* ser.h:14 */
#ifndef SOAP_TYPE___ser__anyType
#define SOAP_TYPE___ser__anyType (8)
/* Wrapper: */
struct SOAP_CMAC __ser__anyType {
      public:
        /** Any type of element 'ser:anyType' assigned to ser__anyType with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *ser__anyType;
      public:
        /** Return unique type id SOAP_TYPE___ser__anyType */
        long soap_type() const { return SOAP_TYPE___ser__anyType; }
        /** Constructor with member initializations */
        __ser__anyType() : __type(), ser__anyType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ser__anyType * SOAP_FMAC2 soap_instantiate___ser__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:219 */
#ifndef SOAP_TYPE__ns2__StartAutoPlan
#define SOAP_TYPE__ns2__StartAutoPlan (16)
/* complex XML schema type 'ns2:StartAutoPlan': */
class SOAP_CMAC _ns2__StartAutoPlan {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__StartAutoPlan
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__StartAutoPlan; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__StartAutoPlan, default initialized and not managed by a soap context
        virtual _ns2__StartAutoPlan *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__StartAutoPlan); }
      public:
        /// Constructor with default initializations
        _ns2__StartAutoPlan() : soap() { }
        virtual ~_ns2__StartAutoPlan() { }
        /// Friend allocator used by soap_new__ns2__StartAutoPlan(struct soap*, int)
        friend SOAP_FMAC1 _ns2__StartAutoPlan * SOAP_FMAC2 soap_instantiate__ns2__StartAutoPlan(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:221 */
#ifndef SOAP_TYPE__ns2__StartAutoPlanResponse
#define SOAP_TYPE__ns2__StartAutoPlanResponse (17)
/* complex XML schema type 'ns2:StartAutoPlanResponse': */
class SOAP_CMAC _ns2__StartAutoPlanResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__StartAutoPlanResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__StartAutoPlanResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__StartAutoPlanResponse, default initialized and not managed by a soap context
        virtual _ns2__StartAutoPlanResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__StartAutoPlanResponse); }
      public:
        /// Constructor with default initializations
        _ns2__StartAutoPlanResponse() : soap() { }
        virtual ~_ns2__StartAutoPlanResponse() { }
        /// Friend allocator used by soap_new__ns2__StartAutoPlanResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__StartAutoPlanResponse * SOAP_FMAC2 soap_instantiate__ns2__StartAutoPlanResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:223 */
#ifndef SOAP_TYPE__ns2__StartOperation
#define SOAP_TYPE__ns2__StartOperation (18)
/* complex XML schema type 'ns2:StartOperation': */
class SOAP_CMAC _ns2__StartOperation {
      public:
        /// Optional element 'ns2:operationName' of XML schema type 'xsd:string'
        std::string *operationName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__StartOperation
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__StartOperation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__StartOperation, default initialized and not managed by a soap context
        virtual _ns2__StartOperation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__StartOperation); }
      public:
        /// Constructor with default initializations
        _ns2__StartOperation() : operationName(), soap() { }
        virtual ~_ns2__StartOperation() { }
        /// Friend allocator used by soap_new__ns2__StartOperation(struct soap*, int)
        friend SOAP_FMAC1 _ns2__StartOperation * SOAP_FMAC2 soap_instantiate__ns2__StartOperation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:225 */
#ifndef SOAP_TYPE__ns2__StartOperationResponse
#define SOAP_TYPE__ns2__StartOperationResponse (19)
/* complex XML schema type 'ns2:StartOperationResponse': */
class SOAP_CMAC _ns2__StartOperationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__StartOperationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__StartOperationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__StartOperationResponse, default initialized and not managed by a soap context
        virtual _ns2__StartOperationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__StartOperationResponse); }
      public:
        /// Constructor with default initializations
        _ns2__StartOperationResponse() : soap() { }
        virtual ~_ns2__StartOperationResponse() { }
        /// Friend allocator used by soap_new__ns2__StartOperationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__StartOperationResponse * SOAP_FMAC2 soap_instantiate__ns2__StartOperationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:227 */
#ifndef SOAP_TYPE__ns2__StopAnalyzing
#define SOAP_TYPE__ns2__StopAnalyzing (20)
/* complex XML schema type 'ns2:StopAnalyzing': */
class SOAP_CMAC _ns2__StopAnalyzing {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__StopAnalyzing
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__StopAnalyzing; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__StopAnalyzing, default initialized and not managed by a soap context
        virtual _ns2__StopAnalyzing *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__StopAnalyzing); }
      public:
        /// Constructor with default initializations
        _ns2__StopAnalyzing() : soap() { }
        virtual ~_ns2__StopAnalyzing() { }
        /// Friend allocator used by soap_new__ns2__StopAnalyzing(struct soap*, int)
        friend SOAP_FMAC1 _ns2__StopAnalyzing * SOAP_FMAC2 soap_instantiate__ns2__StopAnalyzing(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:229 */
#ifndef SOAP_TYPE__ns2__StopAnalyzingResponse
#define SOAP_TYPE__ns2__StopAnalyzingResponse (21)
/* complex XML schema type 'ns2:StopAnalyzingResponse': */
class SOAP_CMAC _ns2__StopAnalyzingResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__StopAnalyzingResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__StopAnalyzingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__StopAnalyzingResponse, default initialized and not managed by a soap context
        virtual _ns2__StopAnalyzingResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__StopAnalyzingResponse); }
      public:
        /// Constructor with default initializations
        _ns2__StopAnalyzingResponse() : soap() { }
        virtual ~_ns2__StopAnalyzingResponse() { }
        /// Friend allocator used by soap_new__ns2__StopAnalyzingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__StopAnalyzingResponse * SOAP_FMAC2 soap_instantiate__ns2__StopAnalyzingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:231 */
#ifndef SOAP_TYPE__ns2__AbortAnalyzing
#define SOAP_TYPE__ns2__AbortAnalyzing (22)
/* complex XML schema type 'ns2:AbortAnalyzing': */
class SOAP_CMAC _ns2__AbortAnalyzing {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__AbortAnalyzing
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__AbortAnalyzing; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__AbortAnalyzing, default initialized and not managed by a soap context
        virtual _ns2__AbortAnalyzing *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__AbortAnalyzing); }
      public:
        /// Constructor with default initializations
        _ns2__AbortAnalyzing() : soap() { }
        virtual ~_ns2__AbortAnalyzing() { }
        /// Friend allocator used by soap_new__ns2__AbortAnalyzing(struct soap*, int)
        friend SOAP_FMAC1 _ns2__AbortAnalyzing * SOAP_FMAC2 soap_instantiate__ns2__AbortAnalyzing(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:233 */
#ifndef SOAP_TYPE__ns2__AbortAnalyzingResponse
#define SOAP_TYPE__ns2__AbortAnalyzingResponse (23)
/* complex XML schema type 'ns2:AbortAnalyzingResponse': */
class SOAP_CMAC _ns2__AbortAnalyzingResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__AbortAnalyzingResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__AbortAnalyzingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__AbortAnalyzingResponse, default initialized and not managed by a soap context
        virtual _ns2__AbortAnalyzingResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__AbortAnalyzingResponse); }
      public:
        /// Constructor with default initializations
        _ns2__AbortAnalyzingResponse() : soap() { }
        virtual ~_ns2__AbortAnalyzingResponse() { }
        /// Friend allocator used by soap_new__ns2__AbortAnalyzingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__AbortAnalyzingResponse * SOAP_FMAC2 soap_instantiate__ns2__AbortAnalyzingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:235 */
#ifndef SOAP_TYPE__ns2__GetProcessingInfo
#define SOAP_TYPE__ns2__GetProcessingInfo (24)
/* complex XML schema type 'ns2:GetProcessingInfo': */
class SOAP_CMAC _ns2__GetProcessingInfo {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetProcessingInfo
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetProcessingInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetProcessingInfo, default initialized and not managed by a soap context
        virtual _ns2__GetProcessingInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetProcessingInfo); }
      public:
        /// Constructor with default initializations
        _ns2__GetProcessingInfo() : soap() { }
        virtual ~_ns2__GetProcessingInfo() { }
        /// Friend allocator used by soap_new__ns2__GetProcessingInfo(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetProcessingInfo * SOAP_FMAC2 soap_instantiate__ns2__GetProcessingInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:237 */
#ifndef SOAP_TYPE__ns2__GetProcessingInfoResponse
#define SOAP_TYPE__ns2__GetProcessingInfoResponse (25)
/* complex XML schema type 'ns2:GetProcessingInfoResponse': */
class SOAP_CMAC _ns2__GetProcessingInfoResponse {
      public:
        /// Optional element 'ns2:GetProcessingInfoResult' of XML schema type 'ns3:ProcessingInfo'
        ns3__ProcessingInfo *GetProcessingInfoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetProcessingInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetProcessingInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetProcessingInfoResponse, default initialized and not managed by a soap context
        virtual _ns2__GetProcessingInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetProcessingInfoResponse); }
      public:
        /// Constructor with default initializations
        _ns2__GetProcessingInfoResponse() : GetProcessingInfoResult(), soap() { }
        virtual ~_ns2__GetProcessingInfoResponse() { }
        /// Friend allocator used by soap_new__ns2__GetProcessingInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetProcessingInfoResponse * SOAP_FMAC2 soap_instantiate__ns2__GetProcessingInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:239 */
#ifndef SOAP_TYPE__ns2__SetIgnoreClearing
#define SOAP_TYPE__ns2__SetIgnoreClearing (26)
/* complex XML schema type 'ns2:SetIgnoreClearing': */
class SOAP_CMAC _ns2__SetIgnoreClearing {
      public:
        /// Optional element 'ns2:ignoreClearing' of XML schema type 'xsd:boolean'
        bool *ignoreClearing;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__SetIgnoreClearing
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__SetIgnoreClearing; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__SetIgnoreClearing, default initialized and not managed by a soap context
        virtual _ns2__SetIgnoreClearing *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__SetIgnoreClearing); }
      public:
        /// Constructor with default initializations
        _ns2__SetIgnoreClearing() : ignoreClearing(), soap() { }
        virtual ~_ns2__SetIgnoreClearing() { }
        /// Friend allocator used by soap_new__ns2__SetIgnoreClearing(struct soap*, int)
        friend SOAP_FMAC1 _ns2__SetIgnoreClearing * SOAP_FMAC2 soap_instantiate__ns2__SetIgnoreClearing(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:241 */
#ifndef SOAP_TYPE__ns2__SetIgnoreClearingResponse
#define SOAP_TYPE__ns2__SetIgnoreClearingResponse (27)
/* complex XML schema type 'ns2:SetIgnoreClearingResponse': */
class SOAP_CMAC _ns2__SetIgnoreClearingResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__SetIgnoreClearingResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__SetIgnoreClearingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__SetIgnoreClearingResponse, default initialized and not managed by a soap context
        virtual _ns2__SetIgnoreClearingResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__SetIgnoreClearingResponse); }
      public:
        /// Constructor with default initializations
        _ns2__SetIgnoreClearingResponse() : soap() { }
        virtual ~_ns2__SetIgnoreClearingResponse() { }
        /// Friend allocator used by soap_new__ns2__SetIgnoreClearingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__SetIgnoreClearingResponse * SOAP_FMAC2 soap_instantiate__ns2__SetIgnoreClearingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:243 */
#ifndef SOAP_TYPE__ns2__GetSystemConfigurations
#define SOAP_TYPE__ns2__GetSystemConfigurations (28)
/* complex XML schema type 'ns2:GetSystemConfigurations': */
class SOAP_CMAC _ns2__GetSystemConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetSystemConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetSystemConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetSystemConfigurations, default initialized and not managed by a soap context
        virtual _ns2__GetSystemConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetSystemConfigurations); }
      public:
        /// Constructor with default initializations
        _ns2__GetSystemConfigurations() : soap() { }
        virtual ~_ns2__GetSystemConfigurations() { }
        /// Friend allocator used by soap_new__ns2__GetSystemConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetSystemConfigurations * SOAP_FMAC2 soap_instantiate__ns2__GetSystemConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:245 */
#ifndef SOAP_TYPE__ns2__GetSystemConfigurationsResponse
#define SOAP_TYPE__ns2__GetSystemConfigurationsResponse (29)
/* complex XML schema type 'ns2:GetSystemConfigurationsResponse': */
class SOAP_CMAC _ns2__GetSystemConfigurationsResponse {
      public:
        /// Optional element 'ns2:GetSystemConfigurationsResult' of XML schema type 'ns5:SystemConfigurations'
        ns5__SystemConfigurations *GetSystemConfigurationsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetSystemConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetSystemConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetSystemConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns2__GetSystemConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetSystemConfigurationsResponse); }
      public:
        /// Constructor with default initializations
        _ns2__GetSystemConfigurationsResponse() : GetSystemConfigurationsResult(), soap() { }
        virtual ~_ns2__GetSystemConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns2__GetSystemConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetSystemConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns2__GetSystemConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:247 */
#ifndef SOAP_TYPE__ns2__SetSystemConfigurations
#define SOAP_TYPE__ns2__SetSystemConfigurations (30)
/* complex XML schema type 'ns2:SetSystemConfigurations': */
class SOAP_CMAC _ns2__SetSystemConfigurations {
      public:
        /// Optional element 'ns2:systemConfigurations' of XML schema type 'ns5:SystemConfigurations'
        ns5__SystemConfigurations *systemConfigurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__SetSystemConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__SetSystemConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__SetSystemConfigurations, default initialized and not managed by a soap context
        virtual _ns2__SetSystemConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__SetSystemConfigurations); }
      public:
        /// Constructor with default initializations
        _ns2__SetSystemConfigurations() : systemConfigurations(), soap() { }
        virtual ~_ns2__SetSystemConfigurations() { }
        /// Friend allocator used by soap_new__ns2__SetSystemConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns2__SetSystemConfigurations * SOAP_FMAC2 soap_instantiate__ns2__SetSystemConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:249 */
#ifndef SOAP_TYPE__ns2__SetSystemConfigurationsResponse
#define SOAP_TYPE__ns2__SetSystemConfigurationsResponse (31)
/* complex XML schema type 'ns2:SetSystemConfigurationsResponse': */
class SOAP_CMAC _ns2__SetSystemConfigurationsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__SetSystemConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__SetSystemConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__SetSystemConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns2__SetSystemConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__SetSystemConfigurationsResponse); }
      public:
        /// Constructor with default initializations
        _ns2__SetSystemConfigurationsResponse() : soap() { }
        virtual ~_ns2__SetSystemConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns2__SetSystemConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__SetSystemConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns2__SetSystemConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:251 */
#ifndef SOAP_TYPE__ns2__GetResults
#define SOAP_TYPE__ns2__GetResults (32)
/* complex XML schema type 'ns2:GetResults': */
class SOAP_CMAC _ns2__GetResults {
      public:
        /// Optional element 'ns2:beginDateTime' of XML schema type 'xsd:dateTime'
        time_t *beginDateTime;
        /// Optional element 'ns2:endDateTime' of XML schema type 'xsd:dateTime'
        time_t *endDateTime;
        /// Optional element 'ns2:sampleType' of XML schema type 'ns10:ESampleTypes'
        enum ns10__ESampleTypes *sampleType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetResults
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetResults; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetResults, default initialized and not managed by a soap context
        virtual _ns2__GetResults *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetResults); }
      public:
        /// Constructor with default initializations
        _ns2__GetResults() : beginDateTime(), endDateTime(), sampleType(), soap() { }
        virtual ~_ns2__GetResults() { }
        /// Friend allocator used by soap_new__ns2__GetResults(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetResults * SOAP_FMAC2 soap_instantiate__ns2__GetResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:253 */
#ifndef SOAP_TYPE__ns2__GetResultsResponse
#define SOAP_TYPE__ns2__GetResultsResponse (33)
/* complex XML schema type 'ns2:GetResultsResponse': */
class SOAP_CMAC _ns2__GetResultsResponse {
      public:
        /// Optional element 'ns2:GetResultsResult' of XML schema type 'ns10:ArrayOfESample'
        ns10__ArrayOfESample *GetResultsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetResultsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetResultsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetResultsResponse, default initialized and not managed by a soap context
        virtual _ns2__GetResultsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetResultsResponse); }
      public:
        /// Constructor with default initializations
        _ns2__GetResultsResponse() : GetResultsResult(), soap() { }
        virtual ~_ns2__GetResultsResponse() { }
        /// Friend allocator used by soap_new__ns2__GetResultsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetResultsResponse * SOAP_FMAC2 soap_instantiate__ns2__GetResultsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:255 */
#ifndef SOAP_TYPE__ns2__GetLastResult
#define SOAP_TYPE__ns2__GetLastResult (34)
/* complex XML schema type 'ns2:GetLastResult': */
class SOAP_CMAC _ns2__GetLastResult {
      public:
        /// Optional element 'ns2:sampleType' of XML schema type 'ns10:ESampleTypes'
        enum ns10__ESampleTypes *sampleType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetLastResult
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetLastResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetLastResult, default initialized and not managed by a soap context
        virtual _ns2__GetLastResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetLastResult); }
      public:
        /// Constructor with default initializations
        _ns2__GetLastResult() : sampleType(), soap() { }
        virtual ~_ns2__GetLastResult() { }
        /// Friend allocator used by soap_new__ns2__GetLastResult(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetLastResult * SOAP_FMAC2 soap_instantiate__ns2__GetLastResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:257 */
#ifndef SOAP_TYPE__ns2__GetLastResultResponse
#define SOAP_TYPE__ns2__GetLastResultResponse (35)
/* complex XML schema type 'ns2:GetLastResultResponse': */
class SOAP_CMAC _ns2__GetLastResultResponse {
      public:
        /// Optional element 'ns2:GetLastResultResult' of XML schema type 'ns10:ESample'
        ns10__ESample *GetLastResultResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetLastResultResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetLastResultResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetLastResultResponse, default initialized and not managed by a soap context
        virtual _ns2__GetLastResultResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetLastResultResponse); }
      public:
        /// Constructor with default initializations
        _ns2__GetLastResultResponse() : GetLastResultResult(), soap() { }
        virtual ~_ns2__GetLastResultResponse() { }
        /// Friend allocator used by soap_new__ns2__GetLastResultResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetLastResultResponse * SOAP_FMAC2 soap_instantiate__ns2__GetLastResultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:259 */
#ifndef SOAP_TYPE__ns2__GetLastResultId
#define SOAP_TYPE__ns2__GetLastResultId (36)
/* complex XML schema type 'ns2:GetLastResultId': */
class SOAP_CMAC _ns2__GetLastResultId {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetLastResultId
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetLastResultId; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetLastResultId, default initialized and not managed by a soap context
        virtual _ns2__GetLastResultId *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetLastResultId); }
      public:
        /// Constructor with default initializations
        _ns2__GetLastResultId() : soap() { }
        virtual ~_ns2__GetLastResultId() { }
        /// Friend allocator used by soap_new__ns2__GetLastResultId(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetLastResultId * SOAP_FMAC2 soap_instantiate__ns2__GetLastResultId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:261 */
#ifndef SOAP_TYPE__ns2__GetLastResultIdResponse
#define SOAP_TYPE__ns2__GetLastResultIdResponse (37)
/* complex XML schema type 'ns2:GetLastResultIdResponse': */
class SOAP_CMAC _ns2__GetLastResultIdResponse {
      public:
        /// Optional element 'ns2:GetLastResultIdResult' of XML schema type 'xsd:int'
        int *GetLastResultIdResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetLastResultIdResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetLastResultIdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetLastResultIdResponse, default initialized and not managed by a soap context
        virtual _ns2__GetLastResultIdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetLastResultIdResponse); }
      public:
        /// Constructor with default initializations
        _ns2__GetLastResultIdResponse() : GetLastResultIdResult(), soap() { }
        virtual ~_ns2__GetLastResultIdResponse() { }
        /// Friend allocator used by soap_new__ns2__GetLastResultIdResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetLastResultIdResponse * SOAP_FMAC2 soap_instantiate__ns2__GetLastResultIdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:263 */
#ifndef SOAP_TYPE__ns2__GetResultsSinceId
#define SOAP_TYPE__ns2__GetResultsSinceId (38)
/* complex XML schema type 'ns2:GetResultsSinceId': */
class SOAP_CMAC _ns2__GetResultsSinceId {
      public:
        /// Optional element 'ns2:lastId' of XML schema type 'xsd:int'
        int *lastId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetResultsSinceId
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetResultsSinceId; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetResultsSinceId, default initialized and not managed by a soap context
        virtual _ns2__GetResultsSinceId *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetResultsSinceId); }
      public:
        /// Constructor with default initializations
        _ns2__GetResultsSinceId() : lastId(), soap() { }
        virtual ~_ns2__GetResultsSinceId() { }
        /// Friend allocator used by soap_new__ns2__GetResultsSinceId(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetResultsSinceId * SOAP_FMAC2 soap_instantiate__ns2__GetResultsSinceId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:265 */
#ifndef SOAP_TYPE__ns2__GetResultsSinceIdResponse
#define SOAP_TYPE__ns2__GetResultsSinceIdResponse (39)
/* complex XML schema type 'ns2:GetResultsSinceIdResponse': */
class SOAP_CMAC _ns2__GetResultsSinceIdResponse {
      public:
        /// Optional element 'ns2:GetResultsSinceIdResult' of XML schema type 'ns10:ArrayOfESample'
        ns10__ArrayOfESample *GetResultsSinceIdResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetResultsSinceIdResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetResultsSinceIdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetResultsSinceIdResponse, default initialized and not managed by a soap context
        virtual _ns2__GetResultsSinceIdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetResultsSinceIdResponse); }
      public:
        /// Constructor with default initializations
        _ns2__GetResultsSinceIdResponse() : GetResultsSinceIdResult(), soap() { }
        virtual ~_ns2__GetResultsSinceIdResponse() { }
        /// Friend allocator used by soap_new__ns2__GetResultsSinceIdResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetResultsSinceIdResponse * SOAP_FMAC2 soap_instantiate__ns2__GetResultsSinceIdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:267 */
#ifndef SOAP_TYPE__ns2__GetEvents
#define SOAP_TYPE__ns2__GetEvents (40)
/* complex XML schema type 'ns2:GetEvents': */
class SOAP_CMAC _ns2__GetEvents {
      public:
        /// Optional element 'ns2:beginDateTime' of XML schema type 'xsd:dateTime'
        time_t *beginDateTime;
        /// Optional element 'ns2:endDateTime' of XML schema type 'xsd:dateTime'
        time_t *endDateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetEvents
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetEvents; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetEvents, default initialized and not managed by a soap context
        virtual _ns2__GetEvents *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetEvents); }
      public:
        /// Constructor with default initializations
        _ns2__GetEvents() : beginDateTime(), endDateTime(), soap() { }
        virtual ~_ns2__GetEvents() { }
        /// Friend allocator used by soap_new__ns2__GetEvents(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetEvents * SOAP_FMAC2 soap_instantiate__ns2__GetEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:269 */
#ifndef SOAP_TYPE__ns2__GetEventsResponse
#define SOAP_TYPE__ns2__GetEventsResponse (41)
/* complex XML schema type 'ns2:GetEventsResponse': */
class SOAP_CMAC _ns2__GetEventsResponse {
      public:
        /// Optional element 'ns2:GetEventsResult' of XML schema type 'ns10:ArrayOfEEvent'
        ns10__ArrayOfEEvent *GetEventsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetEventsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetEventsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetEventsResponse, default initialized and not managed by a soap context
        virtual _ns2__GetEventsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetEventsResponse); }
      public:
        /// Constructor with default initializations
        _ns2__GetEventsResponse() : GetEventsResult(), soap() { }
        virtual ~_ns2__GetEventsResponse() { }
        /// Friend allocator used by soap_new__ns2__GetEventsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetEventsResponse * SOAP_FMAC2 soap_instantiate__ns2__GetEventsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:271 */
#ifndef SOAP_TYPE__ns2__GetLastEventId
#define SOAP_TYPE__ns2__GetLastEventId (42)
/* complex XML schema type 'ns2:GetLastEventId': */
class SOAP_CMAC _ns2__GetLastEventId {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetLastEventId
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetLastEventId; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetLastEventId, default initialized and not managed by a soap context
        virtual _ns2__GetLastEventId *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetLastEventId); }
      public:
        /// Constructor with default initializations
        _ns2__GetLastEventId() : soap() { }
        virtual ~_ns2__GetLastEventId() { }
        /// Friend allocator used by soap_new__ns2__GetLastEventId(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetLastEventId * SOAP_FMAC2 soap_instantiate__ns2__GetLastEventId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:273 */
#ifndef SOAP_TYPE__ns2__GetLastEventIdResponse
#define SOAP_TYPE__ns2__GetLastEventIdResponse (43)
/* complex XML schema type 'ns2:GetLastEventIdResponse': */
class SOAP_CMAC _ns2__GetLastEventIdResponse {
      public:
        /// Optional element 'ns2:GetLastEventIdResult' of XML schema type 'xsd:int'
        int *GetLastEventIdResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetLastEventIdResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetLastEventIdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetLastEventIdResponse, default initialized and not managed by a soap context
        virtual _ns2__GetLastEventIdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetLastEventIdResponse); }
      public:
        /// Constructor with default initializations
        _ns2__GetLastEventIdResponse() : GetLastEventIdResult(), soap() { }
        virtual ~_ns2__GetLastEventIdResponse() { }
        /// Friend allocator used by soap_new__ns2__GetLastEventIdResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetLastEventIdResponse * SOAP_FMAC2 soap_instantiate__ns2__GetLastEventIdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:275 */
#ifndef SOAP_TYPE__ns2__GetEventsSinceId
#define SOAP_TYPE__ns2__GetEventsSinceId (44)
/* complex XML schema type 'ns2:GetEventsSinceId': */
class SOAP_CMAC _ns2__GetEventsSinceId {
      public:
        /// Optional element 'ns2:lastId' of XML schema type 'xsd:int'
        int *lastId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetEventsSinceId
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetEventsSinceId; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetEventsSinceId, default initialized and not managed by a soap context
        virtual _ns2__GetEventsSinceId *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetEventsSinceId); }
      public:
        /// Constructor with default initializations
        _ns2__GetEventsSinceId() : lastId(), soap() { }
        virtual ~_ns2__GetEventsSinceId() { }
        /// Friend allocator used by soap_new__ns2__GetEventsSinceId(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetEventsSinceId * SOAP_FMAC2 soap_instantiate__ns2__GetEventsSinceId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:277 */
#ifndef SOAP_TYPE__ns2__GetEventsSinceIdResponse
#define SOAP_TYPE__ns2__GetEventsSinceIdResponse (45)
/* complex XML schema type 'ns2:GetEventsSinceIdResponse': */
class SOAP_CMAC _ns2__GetEventsSinceIdResponse {
      public:
        /// Optional element 'ns2:GetEventsSinceIdResult' of XML schema type 'ns10:ArrayOfEEvent'
        ns10__ArrayOfEEvent *GetEventsSinceIdResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__GetEventsSinceIdResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__GetEventsSinceIdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__GetEventsSinceIdResponse, default initialized and not managed by a soap context
        virtual _ns2__GetEventsSinceIdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__GetEventsSinceIdResponse); }
      public:
        /// Constructor with default initializations
        _ns2__GetEventsSinceIdResponse() : GetEventsSinceIdResult(), soap() { }
        virtual ~_ns2__GetEventsSinceIdResponse() { }
        /// Friend allocator used by soap_new__ns2__GetEventsSinceIdResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__GetEventsSinceIdResponse * SOAP_FMAC2 soap_instantiate__ns2__GetEventsSinceIdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:279 */
#ifndef SOAP_TYPE_ns3__ProcessingInfo
#define SOAP_TYPE_ns3__ProcessingInfo (46)
/* complex XML schema type 'ns3:ProcessingInfo': */
class SOAP_CMAC ns3__ProcessingInfo {
      public:
        /// Optional element 'ns3:CurrentDateTime' of XML schema type 'xsd:dateTime'
        time_t *CurrentDateTime;
        /// Optional element 'ns3:IgnoreClearing' of XML schema type 'xsd:boolean'
        bool *IgnoreClearing;
        /// Optional element 'ns3:OperationInfo' of XML schema type 'ns3:OperationProcInfo'
        ns3__OperationProcInfo *OperationInfo;
        /// Optional element 'ns3:ProcessingMode' of XML schema type 'ns3:ProcessingModes'
        enum ns3__ProcessingModes *ProcessingMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ProcessingInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__ProcessingInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ProcessingInfo, default initialized and not managed by a soap context
        virtual ns3__ProcessingInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__ProcessingInfo); }
      public:
        /// Constructor with default initializations
        ns3__ProcessingInfo() : CurrentDateTime(), IgnoreClearing(), OperationInfo(), ProcessingMode(), soap() { }
        virtual ~ns3__ProcessingInfo() { }
        /// Friend allocator used by soap_new_ns3__ProcessingInfo(struct soap*, int)
        friend SOAP_FMAC1 ns3__ProcessingInfo * SOAP_FMAC2 soap_instantiate_ns3__ProcessingInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:281 */
#ifndef SOAP_TYPE_ns3__OperationProcInfo
#define SOAP_TYPE_ns3__OperationProcInfo (47)
/* complex XML schema type 'ns3:OperationProcInfo': */
class SOAP_CMAC ns3__OperationProcInfo {
      public:
        /// Optional element 'ns3:AuxDevicesStatus' of XML schema type 'xsd:string'
        std::string *AuxDevicesStatus;
        /// Optional element 'ns3:BeginDateTime' of XML schema type 'xsd:dateTime'
        time_t *BeginDateTime;
        /// Optional element 'ns3:ControlParams' of XML schema type 'ns3:ArrayOfOperationProcInfo.ControlParamInfo'
        ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *ControlParams;
        /// Optional element 'ns3:EndDateTime' of XML schema type 'xsd:dateTime'
        time_t *EndDateTime;
        /// Optional element 'ns3:OperationStepsInfo' of XML schema type 'ns3:ArrayOfOperationProcInfo.OperationStepInfo'
        ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *OperationStepsInfo;
        /// Optional element 'ns3:OperationTitle' of XML schema type 'xsd:string'
        std::string *OperationTitle;
        /// Optional element 'ns3:PanelErrors' of XML schema type 'arr:ArrayOfstring'
        arr__ArrayOfstring *PanelErrors;
        /// Optional element 'ns3:PanelMode' of XML schema type 'xsd:string'
        std::string *PanelMode;
        /// Optional element 'ns3:PanelStatus' of XML schema type 'xsd:string'
        std::string *PanelStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__OperationProcInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__OperationProcInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__OperationProcInfo, default initialized and not managed by a soap context
        virtual ns3__OperationProcInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__OperationProcInfo); }
      public:
        /// Constructor with default initializations
        ns3__OperationProcInfo() : AuxDevicesStatus(), BeginDateTime(), ControlParams(), EndDateTime(), OperationStepsInfo(), OperationTitle(), PanelErrors(), PanelMode(), PanelStatus(), soap() { }
        virtual ~ns3__OperationProcInfo() { }
        /// Friend allocator used by soap_new_ns3__OperationProcInfo(struct soap*, int)
        friend SOAP_FMAC1 ns3__OperationProcInfo * SOAP_FMAC2 soap_instantiate_ns3__OperationProcInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:283 */
#ifndef SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo
#define SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo (48)
/* complex XML schema type 'ns3:ArrayOfOperationProcInfo.ControlParamInfo': */
class SOAP_CMAC ns3__ArrayOfOperationProcInfo_x002eControlParamInfo {
      public:
        /// Optional element 'ns3:OperationProcInfo.ControlParamInfo' of XML schema type 'ns3:OperationProcInfo.ControlParamInfo'
        std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> OperationProcInfo_x002eControlParamInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ArrayOfOperationProcInfo_x002eControlParamInfo, default initialized and not managed by a soap context
        virtual ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__ArrayOfOperationProcInfo_x002eControlParamInfo); }
      public:
        /// Constructor with default initializations
        ns3__ArrayOfOperationProcInfo_x002eControlParamInfo() : OperationProcInfo_x002eControlParamInfo(), soap() { }
        virtual ~ns3__ArrayOfOperationProcInfo_x002eControlParamInfo() { }
        /// Friend allocator used by soap_new_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(struct soap*, int)
        friend SOAP_FMAC1 ns3__ArrayOfOperationProcInfo_x002eControlParamInfo * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:285 */
#ifndef SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo
#define SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo (49)
/* complex XML schema type 'ns3:OperationProcInfo.ControlParamInfo': */
class SOAP_CMAC ns3__OperationProcInfo_x002eControlParamInfo {
      public:
        /// Optional element 'ns3:Condition' of XML schema type 'xsd:string'
        std::string *Condition;
        /// Optional element 'ns3:Ok' of XML schema type 'xsd:boolean'
        bool *Ok;
        /// Optional element 'ns3:Title' of XML schema type 'xsd:string'
        std::string *Title;
        /// Optional element 'ns3:Value' of XML schema type 'xsd:string'
        std::string *Value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__OperationProcInfo_x002eControlParamInfo, default initialized and not managed by a soap context
        virtual ns3__OperationProcInfo_x002eControlParamInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__OperationProcInfo_x002eControlParamInfo); }
      public:
        /// Constructor with default initializations
        ns3__OperationProcInfo_x002eControlParamInfo() : Condition(), Ok(), Title(), Value(), soap() { }
        virtual ~ns3__OperationProcInfo_x002eControlParamInfo() { }
        /// Friend allocator used by soap_new_ns3__OperationProcInfo_x002eControlParamInfo(struct soap*, int)
        friend SOAP_FMAC1 ns3__OperationProcInfo_x002eControlParamInfo * SOAP_FMAC2 soap_instantiate_ns3__OperationProcInfo_x002eControlParamInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:287 */
#ifndef SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo
#define SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo (50)
/* complex XML schema type 'ns3:ArrayOfOperationProcInfo.OperationStepInfo': */
class SOAP_CMAC ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo {
      public:
        /// Optional element 'ns3:OperationProcInfo.OperationStepInfo' of XML schema type 'ns3:OperationProcInfo.OperationStepInfo'
        std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> OperationProcInfo_x002eOperationStepInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo, default initialized and not managed by a soap context
        virtual ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo); }
      public:
        /// Constructor with default initializations
        ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo() : OperationProcInfo_x002eOperationStepInfo(), soap() { }
        virtual ~ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo() { }
        /// Friend allocator used by soap_new_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(struct soap*, int)
        friend SOAP_FMAC1 ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:289 */
#ifndef SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo
#define SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo (51)
/* complex XML schema type 'ns3:OperationProcInfo.OperationStepInfo': */
class SOAP_CMAC ns3__OperationProcInfo_x002eOperationStepInfo {
      public:
        /// Optional element 'ns3:BeginDateTime' of XML schema type 'xsd:dateTime'
        time_t *BeginDateTime;
        /// Optional element 'ns3:Description' of XML schema type 'xsd:string'
        std::string *Description;
        /// Optional element 'ns3:ElapsedMilliseconds' of XML schema type 'xsd:double'
        double *ElapsedMilliseconds;
        /// Optional element 'ns3:EndDateTime' of XML schema type 'xsd:dateTime'
        time_t *EndDateTime;
        /// Optional element 'ns3:State' of XML schema type 'ns3:OperationProcInfo.OperationStepInfoStates'
        enum ns3__OperationProcInfo_x002eOperationStepInfoStates *State;
        /// Optional element 'ns3:StepType' of XML schema type 'ns4:OperationStepTypes'
        enum ns4__OperationStepTypes *StepType;
        /// Optional element 'ns3:SysTitle' of XML schema type 'xsd:string'
        std::string *SysTitle;
        /// Optional element 'ns3:Title' of XML schema type 'xsd:string'
        std::string *Title;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__OperationProcInfo_x002eOperationStepInfo, default initialized and not managed by a soap context
        virtual ns3__OperationProcInfo_x002eOperationStepInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__OperationProcInfo_x002eOperationStepInfo); }
      public:
        /// Constructor with default initializations
        ns3__OperationProcInfo_x002eOperationStepInfo() : BeginDateTime(), Description(), ElapsedMilliseconds(), EndDateTime(), State(), StepType(), SysTitle(), Title(), soap() { }
        virtual ~ns3__OperationProcInfo_x002eOperationStepInfo() { }
        /// Friend allocator used by soap_new_ns3__OperationProcInfo_x002eOperationStepInfo(struct soap*, int)
        friend SOAP_FMAC1 ns3__OperationProcInfo_x002eOperationStepInfo * SOAP_FMAC2 soap_instantiate_ns3__OperationProcInfo_x002eOperationStepInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:291 */
#ifndef SOAP_TYPE_ns4__ArrayOfAutoPlanItem
#define SOAP_TYPE_ns4__ArrayOfAutoPlanItem (52)
/* complex XML schema type 'ns4:ArrayOfAutoPlanItem': */
class SOAP_CMAC ns4__ArrayOfAutoPlanItem {
      public:
        /// Optional element 'ns4:AutoPlanItem' of XML schema type 'ns4:AutoPlanItem'
        std::vector<ns4__AutoPlanItem *> AutoPlanItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__ArrayOfAutoPlanItem
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__ArrayOfAutoPlanItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__ArrayOfAutoPlanItem, default initialized and not managed by a soap context
        virtual ns4__ArrayOfAutoPlanItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__ArrayOfAutoPlanItem); }
      public:
        /// Constructor with default initializations
        ns4__ArrayOfAutoPlanItem() : AutoPlanItem(), soap() { }
        virtual ~ns4__ArrayOfAutoPlanItem() { }
        /// Friend allocator used by soap_new_ns4__ArrayOfAutoPlanItem(struct soap*, int)
        friend SOAP_FMAC1 ns4__ArrayOfAutoPlanItem * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfAutoPlanItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:293 */
#ifndef SOAP_TYPE_ns4__AutoPlanItem
#define SOAP_TYPE_ns4__AutoPlanItem (53)
/* complex XML schema type 'ns4:AutoPlanItem': */
class SOAP_CMAC ns4__AutoPlanItem {
      public:
        /// Optional element 'ns4:Active' of XML schema type 'xsd:boolean'
        bool *Active;
        /// Optional element 'ns4:ItemPeriodicity' of XML schema type 'ns4:Periodicity'
        ns4__Periodicity *ItemPeriodicity;
        /// Optional element 'ns4:OperationName' of XML schema type 'xsd:string'
        std::string *OperationName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__AutoPlanItem
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__AutoPlanItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__AutoPlanItem, default initialized and not managed by a soap context
        virtual ns4__AutoPlanItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__AutoPlanItem); }
      public:
        /// Constructor with default initializations
        ns4__AutoPlanItem() : Active(), ItemPeriodicity(), OperationName(), soap() { }
        virtual ~ns4__AutoPlanItem() { }
        /// Friend allocator used by soap_new_ns4__AutoPlanItem(struct soap*, int)
        friend SOAP_FMAC1 ns4__AutoPlanItem * SOAP_FMAC2 soap_instantiate_ns4__AutoPlanItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:295 */
#ifndef SOAP_TYPE_ns4__Periodicity
#define SOAP_TYPE_ns4__Periodicity (54)
/* complex XML schema type 'ns4:Periodicity': */
class SOAP_CMAC ns4__Periodicity {
      public:
        /// Optional element 'ns4:Months' of XML schema type 'arr:ArrayOfboolean'
        arr__ArrayOfboolean *Months;
        /// Optional element 'ns4:Times' of XML schema type 'ns4:ArrayOfPeriodicity.Time'
        ns4__ArrayOfPeriodicity_x002eTime *Times;
        /// Optional element 'ns4:WeekDays' of XML schema type 'arr:ArrayOfboolean'
        arr__ArrayOfboolean *WeekDays;
        /// Optional element 'ns4:Weeks' of XML schema type 'arr:ArrayOfboolean'
        arr__ArrayOfboolean *Weeks;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__Periodicity
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__Periodicity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__Periodicity, default initialized and not managed by a soap context
        virtual ns4__Periodicity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__Periodicity); }
      public:
        /// Constructor with default initializations
        ns4__Periodicity() : Months(), Times(), WeekDays(), Weeks(), soap() { }
        virtual ~ns4__Periodicity() { }
        /// Friend allocator used by soap_new_ns4__Periodicity(struct soap*, int)
        friend SOAP_FMAC1 ns4__Periodicity * SOAP_FMAC2 soap_instantiate_ns4__Periodicity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:297 */
#ifndef SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime
#define SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime (55)
/* complex XML schema type 'ns4:ArrayOfPeriodicity.Time': */
class SOAP_CMAC ns4__ArrayOfPeriodicity_x002eTime {
      public:
        /// Optional element 'ns4:Periodicity.Time' of XML schema type 'ns4:Periodicity.Time'
        std::vector<ns4__Periodicity_x002eTime *> Periodicity_x002eTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__ArrayOfPeriodicity_x002eTime, default initialized and not managed by a soap context
        virtual ns4__ArrayOfPeriodicity_x002eTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__ArrayOfPeriodicity_x002eTime); }
      public:
        /// Constructor with default initializations
        ns4__ArrayOfPeriodicity_x002eTime() : Periodicity_x002eTime(), soap() { }
        virtual ~ns4__ArrayOfPeriodicity_x002eTime() { }
        /// Friend allocator used by soap_new_ns4__ArrayOfPeriodicity_x002eTime(struct soap*, int)
        friend SOAP_FMAC1 ns4__ArrayOfPeriodicity_x002eTime * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfPeriodicity_x002eTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:299 */
#ifndef SOAP_TYPE_ns4__Periodicity_x002eTime
#define SOAP_TYPE_ns4__Periodicity_x002eTime (56)
/* complex XML schema type 'ns4:Periodicity.Time': */
class SOAP_CMAC ns4__Periodicity_x002eTime {
      public:
        /// Optional element 'ns4:Value' of XML schema type 'xsd:dateTime'
        time_t *Value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__Periodicity_x002eTime
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__Periodicity_x002eTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__Periodicity_x002eTime, default initialized and not managed by a soap context
        virtual ns4__Periodicity_x002eTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__Periodicity_x002eTime); }
      public:
        /// Constructor with default initializations
        ns4__Periodicity_x002eTime() : Value(), soap() { }
        virtual ~ns4__Periodicity_x002eTime() { }
        /// Friend allocator used by soap_new_ns4__Periodicity_x002eTime(struct soap*, int)
        friend SOAP_FMAC1 ns4__Periodicity_x002eTime * SOAP_FMAC2 soap_instantiate_ns4__Periodicity_x002eTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:301 */
#ifndef SOAP_TYPE_ns4__ArrayOfControlledParametr
#define SOAP_TYPE_ns4__ArrayOfControlledParametr (57)
/* complex XML schema type 'ns4:ArrayOfControlledParametr': */
class SOAP_CMAC ns4__ArrayOfControlledParametr {
      public:
        /// Optional element 'ns4:ControlledParametr' of XML schema type 'ns4:ControlledParametr'
        std::vector<ns4__ControlledParametr *> ControlledParametr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__ArrayOfControlledParametr
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__ArrayOfControlledParametr; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__ArrayOfControlledParametr, default initialized and not managed by a soap context
        virtual ns4__ArrayOfControlledParametr *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__ArrayOfControlledParametr); }
      public:
        /// Constructor with default initializations
        ns4__ArrayOfControlledParametr() : ControlledParametr(), soap() { }
        virtual ~ns4__ArrayOfControlledParametr() { }
        /// Friend allocator used by soap_new_ns4__ArrayOfControlledParametr(struct soap*, int)
        friend SOAP_FMAC1 ns4__ArrayOfControlledParametr * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfControlledParametr(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:303 */
#ifndef SOAP_TYPE_ns4__ControlledParametr
#define SOAP_TYPE_ns4__ControlledParametr (58)
/* complex XML schema type 'ns4:ControlledParametr': */
class SOAP_CMAC ns4__ControlledParametr {
      public:
        /// Optional element 'ns4:ActionMessage' of XML schema type 'xsd:string'
        std::string *ActionMessage;
        /// Optional element 'ns4:ActionType' of XML schema type 'ns4:ControlledParametr.ControlActionType'
        enum ns4__ControlledParametr_x002eControlActionType *ActionType;
        /// Optional element 'ns4:Active' of XML schema type 'xsd:boolean'
        bool *Active;
        /// Optional element 'ns4:Condition' of XML schema type 'xsd:string'
        std::string *Condition;
        /// Optional element 'ns4:Formula' of XML schema type 'xsd:string'
        std::string *Formula;
        /// Optional element 'ns4:Name' of XML schema type 'xsd:string'
        std::string *Name;
        /// Optional element 'ns4:ShowUser' of XML schema type 'xsd:boolean'
        bool *ShowUser;
        /// Optional element 'ns4:Title' of XML schema type 'xsd:string'
        std::string *Title;
        /// Optional element 'ns4:UnitsName' of XML schema type 'xsd:string'
        std::string *UnitsName;
        /// Optional element 'ns4:ValueDigAfterPoint' of XML schema type 'xsd:unsignedByte'
        unsigned char *ValueDigAfterPoint;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__ControlledParametr
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__ControlledParametr; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__ControlledParametr, default initialized and not managed by a soap context
        virtual ns4__ControlledParametr *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__ControlledParametr); }
      public:
        /// Constructor with default initializations
        ns4__ControlledParametr() : ActionMessage(), ActionType(), Active(), Condition(), Formula(), Name(), ShowUser(), Title(), UnitsName(), ValueDigAfterPoint(), soap() { }
        virtual ~ns4__ControlledParametr() { }
        /// Friend allocator used by soap_new_ns4__ControlledParametr(struct soap*, int)
        friend SOAP_FMAC1 ns4__ControlledParametr * SOAP_FMAC2 soap_instantiate_ns4__ControlledParametr(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:305 */
#ifndef SOAP_TYPE_ns4__ArrayOfMeasuringComponent
#define SOAP_TYPE_ns4__ArrayOfMeasuringComponent (59)
/* complex XML schema type 'ns4:ArrayOfMeasuringComponent': */
class SOAP_CMAC ns4__ArrayOfMeasuringComponent {
      public:
        /// Optional element 'ns4:MeasuringComponent' of XML schema type 'ns4:MeasuringComponent'
        std::vector<ns4__MeasuringComponent *> MeasuringComponent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__ArrayOfMeasuringComponent
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__ArrayOfMeasuringComponent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__ArrayOfMeasuringComponent, default initialized and not managed by a soap context
        virtual ns4__ArrayOfMeasuringComponent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__ArrayOfMeasuringComponent); }
      public:
        /// Constructor with default initializations
        ns4__ArrayOfMeasuringComponent() : MeasuringComponent(), soap() { }
        virtual ~ns4__ArrayOfMeasuringComponent() { }
        /// Friend allocator used by soap_new_ns4__ArrayOfMeasuringComponent(struct soap*, int)
        friend SOAP_FMAC1 ns4__ArrayOfMeasuringComponent * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfMeasuringComponent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:307 */
#ifndef SOAP_TYPE_ns4__MeasuringComponent
#define SOAP_TYPE_ns4__MeasuringComponent (60)
/* complex XML schema type 'ns4:MeasuringComponent': */
class SOAP_CMAC ns4__MeasuringComponent {
      public:
        /// Optional element 'ns4:CASCode' of XML schema type 'xsd:string'
        std::string *CASCode;
        /// Optional element 'ns4:Code' of XML schema type 'xsd:int'
        int *Code;
        /// Optional element 'ns4:Control_Accuracy' of XML schema type 'xsd:string'
        std::string *Control_USCOREAccuracy;
        /// Optional element 'ns4:Control_AccuracyStandardValue' of XML schema type 'xsd:decimal'
        std::string *Control_USCOREAccuracyStandardValue;
        /// Optional element 'ns4:Control_Periodicity' of XML schema type 'xsd:string'
        std::string *Control_USCOREPeriodicity;
        /// Optional element 'ns4:Formula' of XML schema type 'xsd:string'
        std::string *Formula;
        /// Optional element 'ns4:Name' of XML schema type 'xsd:string'
        std::string *Name;
        /// Optional element 'ns4:Register' of XML schema type 'xsd:string'
        std::string *Register;
        /// Optional element 'ns4:UnitsName' of XML schema type 'xsd:string'
        std::string *UnitsName;
        /// Optional element 'ns4:ValueDigAfterPoint' of XML schema type 'xsd:unsignedByte'
        unsigned char *ValueDigAfterPoint;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__MeasuringComponent
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__MeasuringComponent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__MeasuringComponent, default initialized and not managed by a soap context
        virtual ns4__MeasuringComponent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__MeasuringComponent); }
      public:
        /// Constructor with default initializations
        ns4__MeasuringComponent() : CASCode(), Code(), Control_USCOREAccuracy(), Control_USCOREAccuracyStandardValue(), Control_USCOREPeriodicity(), Formula(), Name(), Register(), UnitsName(), ValueDigAfterPoint(), soap() { }
        virtual ~ns4__MeasuringComponent() { }
        /// Friend allocator used by soap_new_ns4__MeasuringComponent(struct soap*, int)
        friend SOAP_FMAC1 ns4__MeasuringComponent * SOAP_FMAC2 soap_instantiate_ns4__MeasuringComponent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:309 */
#ifndef SOAP_TYPE_ns4__ArrayOfOperation
#define SOAP_TYPE_ns4__ArrayOfOperation (61)
/* complex XML schema type 'ns4:ArrayOfOperation': */
class SOAP_CMAC ns4__ArrayOfOperation {
      public:
        /// Optional element 'ns4:Operation' of XML schema type 'ns4:Operation'
        std::vector<ns4__Operation *> Operation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__ArrayOfOperation
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__ArrayOfOperation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__ArrayOfOperation, default initialized and not managed by a soap context
        virtual ns4__ArrayOfOperation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__ArrayOfOperation); }
      public:
        /// Constructor with default initializations
        ns4__ArrayOfOperation() : Operation(), soap() { }
        virtual ~ns4__ArrayOfOperation() { }
        /// Friend allocator used by soap_new_ns4__ArrayOfOperation(struct soap*, int)
        friend SOAP_FMAC1 ns4__ArrayOfOperation * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfOperation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:311 */
#ifndef SOAP_TYPE_ns4__Operation
#define SOAP_TYPE_ns4__Operation (62)
/* complex XML schema type 'ns4:Operation': */
class SOAP_CMAC ns4__Operation {
      public:
        /// Optional element 'ns4:Name' of XML schema type 'xsd:string'
        std::string *Name;
        /// Optional element 'ns4:OperationSteps' of XML schema type 'ns4:ArrayOfOperationStep'
        ns4__ArrayOfOperationStep *OperationSteps;
        /// Optional element 'ns4:OperationType' of XML schema type 'ns4:OperationTypes'
        enum ns4__OperationTypes *OperationType;
        /// Optional element 'ns4:Title' of XML schema type 'xsd:string'
        std::string *Title;
        /// Optional element 'ns4:UserVisible' of XML schema type 'xsd:boolean'
        bool *UserVisible;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__Operation
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__Operation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__Operation, default initialized and not managed by a soap context
        virtual ns4__Operation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__Operation); }
      public:
        /// Constructor with default initializations
        ns4__Operation() : Name(), OperationSteps(), OperationType(), Title(), UserVisible(), soap() { }
        virtual ~ns4__Operation() { }
        /// Friend allocator used by soap_new_ns4__Operation(struct soap*, int)
        friend SOAP_FMAC1 ns4__Operation * SOAP_FMAC2 soap_instantiate_ns4__Operation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:313 */
#ifndef SOAP_TYPE_ns4__ArrayOfOperationStep
#define SOAP_TYPE_ns4__ArrayOfOperationStep (63)
/* complex XML schema type 'ns4:ArrayOfOperationStep': */
class SOAP_CMAC ns4__ArrayOfOperationStep {
      public:
        /// Optional element 'ns4:OperationStep' of XML schema type 'ns4:OperationStep'
        std::vector<ns4__OperationStep *> OperationStep;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__ArrayOfOperationStep
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__ArrayOfOperationStep; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__ArrayOfOperationStep, default initialized and not managed by a soap context
        virtual ns4__ArrayOfOperationStep *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__ArrayOfOperationStep); }
      public:
        /// Constructor with default initializations
        ns4__ArrayOfOperationStep() : OperationStep(), soap() { }
        virtual ~ns4__ArrayOfOperationStep() { }
        /// Friend allocator used by soap_new_ns4__ArrayOfOperationStep(struct soap*, int)
        friend SOAP_FMAC1 ns4__ArrayOfOperationStep * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfOperationStep(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:315 */
#ifndef SOAP_TYPE_ns4__OperationStep
#define SOAP_TYPE_ns4__OperationStep (64)
/* complex XML schema type 'ns4:OperationStep': */
class SOAP_CMAC ns4__OperationStep {
      public:
        /// Optional element 'ns4:Active' of XML schema type 'xsd:boolean'
        bool *Active;
        /// Optional element 'ns4:ControlParams' of XML schema type 'ns4:ArrayOfOperationStep.UsingControlledParametr'
        ns4__ArrayOfOperationStep_x002eUsingControlledParametr *ControlParams;
        /// Optional element 'ns4:Number' of XML schema type 'xsd:int'
        int *Number;
        /// Optional element 'ns4:Params' of XML schema type 'xsd:string'
        std::string *Params;
        /// Optional element 'ns4:RequiredChromMode' of XML schema type 'ns9:ChromatographMode'
        enum ns9__ChromatographMode *RequiredChromMode;
        /// Optional element 'ns4:StepType' of XML schema type 'ns4:OperationStepTypes'
        enum ns4__OperationStepTypes *StepType;
        /// Optional element 'ns4:Title' of XML schema type 'xsd:string'
        std::string *Title;
        /// Required element 'xsd:duration' of XML schema type 'xsd:int'
        int xsd__duration;	///< initialized with default value = 7
        /// Optional element 'ns4:WaitBefore' of XML schema type 'xsd:int'
        int *WaitBefore;
        /// Optional element 'ns4:WaitBeforeXml' of XML schema type 'xsd:long'
        LONG64 *WaitBeforeXml;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__OperationStep
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__OperationStep; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__OperationStep, default initialized and not managed by a soap context
        virtual ns4__OperationStep *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__OperationStep); }
      public:
        /// Constructor with default initializations
        ns4__OperationStep() : Active(), ControlParams(), Number(), Params(), RequiredChromMode(), StepType(), Title(), xsd__duration(7), WaitBefore(), WaitBeforeXml(), soap() { }
        virtual ~ns4__OperationStep() { }
        /// Friend allocator used by soap_new_ns4__OperationStep(struct soap*, int)
        friend SOAP_FMAC1 ns4__OperationStep * SOAP_FMAC2 soap_instantiate_ns4__OperationStep(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:317 */
#ifndef SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr
#define SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr (65)
/* complex XML schema type 'ns4:ArrayOfOperationStep.UsingControlledParametr': */
class SOAP_CMAC ns4__ArrayOfOperationStep_x002eUsingControlledParametr {
      public:
        /// Optional element 'ns4:OperationStep.UsingControlledParametr' of XML schema type 'ns4:OperationStep.UsingControlledParametr'
        std::vector<ns4__OperationStep_x002eUsingControlledParametr *> OperationStep_x002eUsingControlledParametr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__ArrayOfOperationStep_x002eUsingControlledParametr, default initialized and not managed by a soap context
        virtual ns4__ArrayOfOperationStep_x002eUsingControlledParametr *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__ArrayOfOperationStep_x002eUsingControlledParametr); }
      public:
        /// Constructor with default initializations
        ns4__ArrayOfOperationStep_x002eUsingControlledParametr() : OperationStep_x002eUsingControlledParametr(), soap() { }
        virtual ~ns4__ArrayOfOperationStep_x002eUsingControlledParametr() { }
        /// Friend allocator used by soap_new_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(struct soap*, int)
        friend SOAP_FMAC1 ns4__ArrayOfOperationStep_x002eUsingControlledParametr * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:319 */
#ifndef SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr
#define SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr (66)
/* complex XML schema type 'ns4:OperationStep.UsingControlledParametr': */
class SOAP_CMAC ns4__OperationStep_x002eUsingControlledParametr {
      public:
        /// Optional element 'ns4:Active' of XML schema type 'xsd:boolean'
        bool *Active;
        /// Optional element 'ns4:ParamName' of XML schema type 'xsd:string'
        std::string *ParamName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__OperationStep_x002eUsingControlledParametr, default initialized and not managed by a soap context
        virtual ns4__OperationStep_x002eUsingControlledParametr *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__OperationStep_x002eUsingControlledParametr); }
      public:
        /// Constructor with default initializations
        ns4__OperationStep_x002eUsingControlledParametr() : Active(), ParamName(), soap() { }
        virtual ~ns4__OperationStep_x002eUsingControlledParametr() { }
        /// Friend allocator used by soap_new_ns4__OperationStep_x002eUsingControlledParametr(struct soap*, int)
        friend SOAP_FMAC1 ns4__OperationStep_x002eUsingControlledParametr * SOAP_FMAC2 soap_instantiate_ns4__OperationStep_x002eUsingControlledParametr(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:321 */
#ifndef SOAP_TYPE_arr__ArrayOfstring
#define SOAP_TYPE_arr__ArrayOfstring (67)
/* complex XML schema type 'arr:ArrayOfstring': */
class SOAP_CMAC arr__ArrayOfstring {
      public:
        /// Optional element 'arr:string' of XML schema type 'xsd:string'
        std::vector<std::string> string;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_arr__ArrayOfstring
        virtual long soap_type(void) const { return SOAP_TYPE_arr__ArrayOfstring; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type arr__ArrayOfstring, default initialized and not managed by a soap context
        virtual arr__ArrayOfstring *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(arr__ArrayOfstring); }
      public:
        /// Constructor with default initializations
        arr__ArrayOfstring() : string(), soap() { }
        virtual ~arr__ArrayOfstring() { }
        /// Friend allocator used by soap_new_arr__ArrayOfstring(struct soap*, int)
        friend SOAP_FMAC1 arr__ArrayOfstring * SOAP_FMAC2 soap_instantiate_arr__ArrayOfstring(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:323 */
#ifndef SOAP_TYPE_arr__ArrayOfboolean
#define SOAP_TYPE_arr__ArrayOfboolean (68)
/* complex XML schema type 'arr:ArrayOfboolean': */
class SOAP_CMAC arr__ArrayOfboolean {
      public:
        /// Optional element 'arr:boolean' of XML schema type 'xsd:boolean'
        std::vector<bool> boolean;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_arr__ArrayOfboolean
        virtual long soap_type(void) const { return SOAP_TYPE_arr__ArrayOfboolean; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type arr__ArrayOfboolean, default initialized and not managed by a soap context
        virtual arr__ArrayOfboolean *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(arr__ArrayOfboolean); }
      public:
        /// Constructor with default initializations
        arr__ArrayOfboolean() : boolean(), soap() { }
        virtual ~arr__ArrayOfboolean() { }
        /// Friend allocator used by soap_new_arr__ArrayOfboolean(struct soap*, int)
        friend SOAP_FMAC1 arr__ArrayOfboolean * SOAP_FMAC2 soap_instantiate_arr__ArrayOfboolean(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:325 */
#ifndef SOAP_TYPE_ns5__SystemConfigurations
#define SOAP_TYPE_ns5__SystemConfigurations (69)
/* complex XML schema type 'ns5:SystemConfigurations': */
class SOAP_CMAC ns5__SystemConfigurations {
      public:
        /// Optional element 'ns5:AutoPlanItems' of XML schema type 'ns4:ArrayOfAutoPlanItem'
        ns4__ArrayOfAutoPlanItem *AutoPlanItems;
        /// Optional element 'ns5:Aux2Device_Active' of XML schema type 'xsd:boolean'
        bool *Aux2Device_USCOREActive;
        /// Optional element 'ns5:Aux2Device_Configuration' of XML schema type 'ns6:Aux2Config'
        ns6__Aux2Config *Aux2Device_USCOREConfiguration;
        /// Optional element 'ns5:AuxDevice_Active' of XML schema type 'xsd:boolean'
        bool *AuxDevice_USCOREActive;
        /// Optional element 'ns5:AuxDevice_Configuration' of XML schema type 'ns7:AuxControllerConfiguration'
        ns7__AuxControllerConfiguration *AuxDevice_USCOREConfiguration;
        /// Optional element 'ns5:ChromatecDirectAnalyticSlaveAddress' of XML schema type 'xsd:unsignedByte'
        unsigned char *ChromatecDirectAnalyticSlaveAddress;
        /// Optional element 'ns5:ChromatecDirectPanelSlaveAddress' of XML schema type 'xsd:unsignedByte'
        unsigned char *ChromatecDirectPanelSlaveAddress;
        /// Optional element 'ns5:ChromatecMODBUSServiceAddress' of XML schema type 'xsd:string'
        std::string *ChromatecMODBUSServiceAddress;
        /// Optional element 'ns5:Clearing_UseCriticalZone' of XML schema type 'xsd:boolean'
        bool *Clearing_USCOREUseCriticalZone;
        /// Optional element 'ns5:Clearing_UseWaitTime' of XML schema type 'xsd:boolean'
        bool *Clearing_USCOREUseWaitTime;
        /// Optional element 'ns5:Clearing_WaitTimeSeconds' of XML schema type 'xsd:int'
        int *Clearing_USCOREWaitTimeSeconds;
        /// Optional element 'ns5:Common_ConfiguratorPasswordHash' of XML schema type 'xsd:string'
        std::string *Common_USCOREConfiguratorPasswordHash;
        /// Optional element 'ns5:Common_ConfiguratorPasswordSalt' of XML schema type 'xsd:string'
        std::string *Common_USCOREConfiguratorPasswordSalt;
        /// Optional element 'ns5:Common_LogLevel' of XML schema type 'ns8:Logger.LogLevel'
        enum ns8__Logger_x002eLogLevel *Common_USCORELogLevel;
        /// Optional element 'ns5:Common_ServiceName' of XML schema type 'xsd:string'
        std::string *Common_USCOREServiceName;
        /// Optional element 'ns5:Common_WCFServicePrefix' of XML schema type 'xsd:string'
        std::string *Common_USCOREWCFServicePrefix;
        /// Optional element 'ns5:Common_WindowTitle' of XML schema type 'xsd:string'
        std::string *Common_USCOREWindowTitle;
        /// Optional element 'ns5:ControlledParametrs' of XML schema type 'ns4:ArrayOfControlledParametr'
        ns4__ArrayOfControlledParametr *ControlledParametrs;
        /// Optional element 'ns5:MeasuringComponents' of XML schema type 'ns4:ArrayOfMeasuringComponent'
        ns4__ArrayOfMeasuringComponent *MeasuringComponents;
        /// Optional element 'ns5:Operations' of XML schema type 'ns4:ArrayOfOperation'
        ns4__ArrayOfOperation *Operations;
        /// Optional element 'ns5:StopAutoPlanOnOperationError' of XML schema type 'xsd:boolean'
        bool *StopAutoPlanOnOperationError;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SystemConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__SystemConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SystemConfigurations, default initialized and not managed by a soap context
        virtual ns5__SystemConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns5__SystemConfigurations); }
      public:
        /// Constructor with default initializations
        ns5__SystemConfigurations() : AutoPlanItems(), Aux2Device_USCOREActive(), Aux2Device_USCOREConfiguration(), AuxDevice_USCOREActive(), AuxDevice_USCOREConfiguration(), ChromatecDirectAnalyticSlaveAddress(), ChromatecDirectPanelSlaveAddress(), ChromatecMODBUSServiceAddress(), Clearing_USCOREUseCriticalZone(), Clearing_USCOREUseWaitTime(), Clearing_USCOREWaitTimeSeconds(), Common_USCOREConfiguratorPasswordHash(), Common_USCOREConfiguratorPasswordSalt(), Common_USCORELogLevel(), Common_USCOREServiceName(), Common_USCOREWCFServicePrefix(), Common_USCOREWindowTitle(), ControlledParametrs(), MeasuringComponents(), Operations(), StopAutoPlanOnOperationError(), soap() { }
        virtual ~ns5__SystemConfigurations() { }
        /// Friend allocator used by soap_new_ns5__SystemConfigurations(struct soap*, int)
        friend SOAP_FMAC1 ns5__SystemConfigurations * SOAP_FMAC2 soap_instantiate_ns5__SystemConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:327 */
#ifndef SOAP_TYPE_ns6__Aux2Config
#define SOAP_TYPE_ns6__Aux2Config (70)
/* complex XML schema type 'ns6:Aux2Config': */
class SOAP_CMAC ns6__Aux2Config {
      public:
        /// Optional element 'ns6:PortNumber' of XML schema type 'xsd:string'
        std::string *PortNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__Aux2Config
        virtual long soap_type(void) const { return SOAP_TYPE_ns6__Aux2Config; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__Aux2Config, default initialized and not managed by a soap context
        virtual ns6__Aux2Config *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns6__Aux2Config); }
      public:
        /// Constructor with default initializations
        ns6__Aux2Config() : PortNumber(), soap() { }
        virtual ~ns6__Aux2Config() { }
        /// Friend allocator used by soap_new_ns6__Aux2Config(struct soap*, int)
        friend SOAP_FMAC1 ns6__Aux2Config * SOAP_FMAC2 soap_instantiate_ns6__Aux2Config(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:329 */
#ifndef SOAP_TYPE_ns7__AuxControllerConfiguration
#define SOAP_TYPE_ns7__AuxControllerConfiguration (71)
/* complex XML schema type 'ns7:AuxControllerConfiguration': */
class SOAP_CMAC ns7__AuxControllerConfiguration {
      public:
        /// Optional element 'ns7:CommandExecuteRetries' of XML schema type 'xsd:int'
        int *CommandExecuteRetries;
        /// Optional element 'ns7:CommandExecuteRetriesDelay' of XML schema type 'xsd:int'
        int *CommandExecuteRetriesDelay;
        /// Optional element 'ns7:Devices' of XML schema type 'ns7:ArrayOfAuxDevice'
        ns7__ArrayOfAuxDevice *Devices;
        /// Optional element 'ns7:PortNumber' of XML schema type 'xsd:string'
        std::string *PortNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__AuxControllerConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_ns7__AuxControllerConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__AuxControllerConfiguration, default initialized and not managed by a soap context
        virtual ns7__AuxControllerConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns7__AuxControllerConfiguration); }
      public:
        /// Constructor with default initializations
        ns7__AuxControllerConfiguration() : CommandExecuteRetries(), CommandExecuteRetriesDelay(), Devices(), PortNumber(), soap() { }
        virtual ~ns7__AuxControllerConfiguration() { }
        /// Friend allocator used by soap_new_ns7__AuxControllerConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns7__AuxControllerConfiguration * SOAP_FMAC2 soap_instantiate_ns7__AuxControllerConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:331 */
#ifndef SOAP_TYPE_ns7__ArrayOfAuxDevice
#define SOAP_TYPE_ns7__ArrayOfAuxDevice (72)
/* complex XML schema type 'ns7:ArrayOfAuxDevice': */
class SOAP_CMAC ns7__ArrayOfAuxDevice {
      public:
        /// Optional element 'ns7:AuxDevice' of XML schema type 'ns7:AuxDevice'
        std::vector<ns7__AuxDevice *> AuxDevice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__ArrayOfAuxDevice
        virtual long soap_type(void) const { return SOAP_TYPE_ns7__ArrayOfAuxDevice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__ArrayOfAuxDevice, default initialized and not managed by a soap context
        virtual ns7__ArrayOfAuxDevice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns7__ArrayOfAuxDevice); }
      public:
        /// Constructor with default initializations
        ns7__ArrayOfAuxDevice() : AuxDevice(), soap() { }
        virtual ~ns7__ArrayOfAuxDevice() { }
        /// Friend allocator used by soap_new_ns7__ArrayOfAuxDevice(struct soap*, int)
        friend SOAP_FMAC1 ns7__ArrayOfAuxDevice * SOAP_FMAC2 soap_instantiate_ns7__ArrayOfAuxDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:333 */
#ifndef SOAP_TYPE_ns7__AuxDevice
#define SOAP_TYPE_ns7__AuxDevice (73)
/* complex XML schema type 'ns7:AuxDevice': */
class SOAP_CMAC ns7__AuxDevice {
      public:
        /// Optional element 'ns7:Caption' of XML schema type 'xsd:string'
        std::string *Caption;
        /// Optional element 'ns7:Id' of XML schema type 'xsd:unsignedByte'
        unsigned char *Id;
        /// Optional element 'ns7:States' of XML schema type 'ns7:ArrayOfAuxDeviceState'
        ns7__ArrayOfAuxDeviceState *States;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__AuxDevice
        virtual long soap_type(void) const { return SOAP_TYPE_ns7__AuxDevice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__AuxDevice, default initialized and not managed by a soap context
        virtual ns7__AuxDevice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns7__AuxDevice); }
      public:
        /// Constructor with default initializations
        ns7__AuxDevice() : Caption(), Id(), States(), soap() { }
        virtual ~ns7__AuxDevice() { }
        /// Friend allocator used by soap_new_ns7__AuxDevice(struct soap*, int)
        friend SOAP_FMAC1 ns7__AuxDevice * SOAP_FMAC2 soap_instantiate_ns7__AuxDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:335 */
#ifndef SOAP_TYPE_ns7__ArrayOfAuxDeviceState
#define SOAP_TYPE_ns7__ArrayOfAuxDeviceState (74)
/* complex XML schema type 'ns7:ArrayOfAuxDeviceState': */
class SOAP_CMAC ns7__ArrayOfAuxDeviceState {
      public:
        /// Optional element 'ns7:AuxDeviceState' of XML schema type 'ns7:AuxDeviceState'
        std::vector<ns7__AuxDeviceState *> AuxDeviceState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__ArrayOfAuxDeviceState
        virtual long soap_type(void) const { return SOAP_TYPE_ns7__ArrayOfAuxDeviceState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__ArrayOfAuxDeviceState, default initialized and not managed by a soap context
        virtual ns7__ArrayOfAuxDeviceState *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns7__ArrayOfAuxDeviceState); }
      public:
        /// Constructor with default initializations
        ns7__ArrayOfAuxDeviceState() : AuxDeviceState(), soap() { }
        virtual ~ns7__ArrayOfAuxDeviceState() { }
        /// Friend allocator used by soap_new_ns7__ArrayOfAuxDeviceState(struct soap*, int)
        friend SOAP_FMAC1 ns7__ArrayOfAuxDeviceState * SOAP_FMAC2 soap_instantiate_ns7__ArrayOfAuxDeviceState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:337 */
#ifndef SOAP_TYPE_ns7__AuxDeviceState
#define SOAP_TYPE_ns7__AuxDeviceState (75)
/* complex XML schema type 'ns7:AuxDeviceState': */
class SOAP_CMAC ns7__AuxDeviceState {
      public:
        /// Optional element 'ns7:BitCommand' of XML schema type 'xsd:string'
        std::string *BitCommand;
        /// Optional element 'ns7:BitMask' of XML schema type 'xsd:string'
        std::string *BitMask;
        /// Optional element 'ns7:BitStatus' of XML schema type 'xsd:string'
        std::string *BitStatus;
        /// Optional element 'ns7:Caption' of XML schema type 'xsd:string'
        std::string *Caption;
        /// Optional element 'ns7:Id' of XML schema type 'xsd:unsignedByte'
        unsigned char *Id;
        /// Optional element 'ns7:IsDefault' of XML schema type 'xsd:boolean'
        bool *IsDefault;
        /// Optional element 'ns7:StateChangeDelay' of XML schema type 'xsd:int'
        int *StateChangeDelay;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__AuxDeviceState
        virtual long soap_type(void) const { return SOAP_TYPE_ns7__AuxDeviceState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__AuxDeviceState, default initialized and not managed by a soap context
        virtual ns7__AuxDeviceState *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns7__AuxDeviceState); }
      public:
        /// Constructor with default initializations
        ns7__AuxDeviceState() : BitCommand(), BitMask(), BitStatus(), Caption(), Id(), IsDefault(), StateChangeDelay(), soap() { }
        virtual ~ns7__AuxDeviceState() { }
        /// Friend allocator used by soap_new_ns7__AuxDeviceState(struct soap*, int)
        friend SOAP_FMAC1 ns7__AuxDeviceState * SOAP_FMAC2 soap_instantiate_ns7__AuxDeviceState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:339 */
#ifndef SOAP_TYPE_ns10__ArrayOfESample
#define SOAP_TYPE_ns10__ArrayOfESample (76)
/* complex XML schema type 'ns10:ArrayOfESample': */
class SOAP_CMAC ns10__ArrayOfESample {
      public:
        /// Optional element 'ns10:ESample' of XML schema type 'ns10:ESample'
        std::vector<ns10__ESample *> ESample;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__ArrayOfESample
        virtual long soap_type(void) const { return SOAP_TYPE_ns10__ArrayOfESample; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__ArrayOfESample, default initialized and not managed by a soap context
        virtual ns10__ArrayOfESample *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns10__ArrayOfESample); }
      public:
        /// Constructor with default initializations
        ns10__ArrayOfESample() : ESample(), soap() { }
        virtual ~ns10__ArrayOfESample() { }
        /// Friend allocator used by soap_new_ns10__ArrayOfESample(struct soap*, int)
        friend SOAP_FMAC1 ns10__ArrayOfESample * SOAP_FMAC2 soap_instantiate_ns10__ArrayOfESample(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:341 */
#ifndef SOAP_TYPE_ns10__ESample
#define SOAP_TYPE_ns10__ESample (77)
/* complex XML schema type 'ns10:ESample': */
class SOAP_CMAC ns10__ESample {
      public:
        /// Optional element 'ns10:BeginAnalyzingDateTime' of XML schema type 'xsd:dateTime'
        time_t *BeginAnalyzingDateTime;
        /// Optional element 'ns10:BeginSamplingDateTime' of XML schema type 'xsd:dateTime'
        time_t *BeginSamplingDateTime;
        /// Optional element 'ns10:ChromNumber' of XML schema type 'xsd:string'
        std::string *ChromNumber;
        /// Optional element 'ns10:EndAnalyzingDateTime' of XML schema type 'xsd:dateTime'
        time_t *EndAnalyzingDateTime;
        /// Optional element 'ns10:EndSamplingDateTime' of XML schema type 'xsd:dateTime'
        time_t *EndSamplingDateTime;
        /// Optional element 'ns10:Id' of XML schema type 'xsd:int'
        int *Id;
        /// Optional element 'ns10:Results' of XML schema type 'ns10:ArrayOfEResult'
        ns10__ArrayOfEResult *Results;
        /// Optional element 'ns10:SampleType' of XML schema type 'ns10:ESampleTypes'
        enum ns10__ESampleTypes *SampleType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__ESample
        virtual long soap_type(void) const { return SOAP_TYPE_ns10__ESample; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__ESample, default initialized and not managed by a soap context
        virtual ns10__ESample *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns10__ESample); }
      public:
        /// Constructor with default initializations
        ns10__ESample() : BeginAnalyzingDateTime(), BeginSamplingDateTime(), ChromNumber(), EndAnalyzingDateTime(), EndSamplingDateTime(), Id(), Results(), SampleType(), soap() { }
        virtual ~ns10__ESample() { }
        /// Friend allocator used by soap_new_ns10__ESample(struct soap*, int)
        friend SOAP_FMAC1 ns10__ESample * SOAP_FMAC2 soap_instantiate_ns10__ESample(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:343 */
#ifndef SOAP_TYPE_ns10__ArrayOfEResult
#define SOAP_TYPE_ns10__ArrayOfEResult (78)
/* complex XML schema type 'ns10:ArrayOfEResult': */
class SOAP_CMAC ns10__ArrayOfEResult {
      public:
        /// Optional element 'ns10:EResult' of XML schema type 'ns10:EResult'
        std::vector<ns10__EResult *> EResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__ArrayOfEResult
        virtual long soap_type(void) const { return SOAP_TYPE_ns10__ArrayOfEResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__ArrayOfEResult, default initialized and not managed by a soap context
        virtual ns10__ArrayOfEResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns10__ArrayOfEResult); }
      public:
        /// Constructor with default initializations
        ns10__ArrayOfEResult() : EResult(), soap() { }
        virtual ~ns10__ArrayOfEResult() { }
        /// Friend allocator used by soap_new_ns10__ArrayOfEResult(struct soap*, int)
        friend SOAP_FMAC1 ns10__ArrayOfEResult * SOAP_FMAC2 soap_instantiate_ns10__ArrayOfEResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:345 */
#ifndef SOAP_TYPE_ns10__EResult
#define SOAP_TYPE_ns10__EResult (79)
/* Type ns10__EResult is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ns10:EResult': */
class SOAP_CMAC ns10__EResult {
      public:
        /// Optional element 'ns10:AccuracyStatus' of XML schema type 'ns10:EResultStatus'
        enum ns10__EResultStatus *AccuracyStatus;
        /// Optional element 'ns10:AccuracyStatusInfo' of XML schema type 'xsd:string'
        std::string *AccuracyStatusInfo;
        /// Optional element 'ns10:ComponentCode' of XML schema type 'xsd:int'
        int *ComponentCode;
        /// Optional element 'ns10:ComponentName' of XML schema type 'xsd:string'
        std::string *ComponentName;
        /// Optional element 'ns10:Id' of XML schema type 'xsd:int'
        int *Id;
        /// Optional element 'ns10:IntervalValueBorder' of XML schema type 'xsd:decimal'
        std::string *IntervalValueBorder;
        /// Optional element 'ns10:PeriodicityStatus' of XML schema type 'ns10:EResultStatus'
        enum ns10__EResultStatus *PeriodicityStatus;
        /// Optional element 'ns10:PeriodicityStatusInfo' of XML schema type 'xsd:string'
        std::string *PeriodicityStatusInfo;
        /// Optional element 'ns10:ResultDetails' of XML schema type 'xsd:string'
        std::string *ResultDetails;
        /// Optional element 'ns10:Sample' of XML schema type 'ns10:ESample'
        ns10__ESample *Sample;
        /// Optional element 'ns10:UnitsName' of XML schema type 'xsd:string'
        std::string *UnitsName;
        /// Optional element 'ns10:Value' of XML schema type 'xsd:decimal'
        std::string *Value;
        /// Optional element 'ns10:ValueDigAfterPoint' of XML schema type 'xsd:int'
        int *ValueDigAfterPoint;
        /// Optional element 'ns10:ValueStatus' of XML schema type 'ns10:EResultValueStatus'
        enum ns10__EResultValueStatus *ValueStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__EResult
        virtual long soap_type(void) const { return SOAP_TYPE_ns10__EResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__EResult, default initialized and not managed by a soap context
        virtual ns10__EResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns10__EResult); }
      public:
        /// Constructor with default initializations
        ns10__EResult() : AccuracyStatus(), AccuracyStatusInfo(), ComponentCode(), ComponentName(), Id(), IntervalValueBorder(), PeriodicityStatus(), PeriodicityStatusInfo(), ResultDetails(), Sample(), UnitsName(), Value(), ValueDigAfterPoint(), ValueStatus(), soap() { }
        virtual ~ns10__EResult() { }
        /// Friend allocator used by soap_new_ns10__EResult(struct soap*, int)
        friend SOAP_FMAC1 ns10__EResult * SOAP_FMAC2 soap_instantiate_ns10__EResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:347 */
#ifndef SOAP_TYPE_ns10__ArrayOfEEvent
#define SOAP_TYPE_ns10__ArrayOfEEvent (80)
/* complex XML schema type 'ns10:ArrayOfEEvent': */
class SOAP_CMAC ns10__ArrayOfEEvent {
      public:
        /// Optional element 'ns10:EEvent' of XML schema type 'ns10:EEvent'
        std::vector<ns10__EEvent *> EEvent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__ArrayOfEEvent
        virtual long soap_type(void) const { return SOAP_TYPE_ns10__ArrayOfEEvent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__ArrayOfEEvent, default initialized and not managed by a soap context
        virtual ns10__ArrayOfEEvent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns10__ArrayOfEEvent); }
      public:
        /// Constructor with default initializations
        ns10__ArrayOfEEvent() : EEvent(), soap() { }
        virtual ~ns10__ArrayOfEEvent() { }
        /// Friend allocator used by soap_new_ns10__ArrayOfEEvent(struct soap*, int)
        friend SOAP_FMAC1 ns10__ArrayOfEEvent * SOAP_FMAC2 soap_instantiate_ns10__ArrayOfEEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:349 */
#ifndef SOAP_TYPE_ns10__EEvent
#define SOAP_TYPE_ns10__EEvent (81)
/* complex XML schema type 'ns10:EEvent': */
class SOAP_CMAC ns10__EEvent {
      public:
        /// Optional element 'ns10:Confirmed' of XML schema type 'xsd:boolean'
        bool *Confirmed;
        /// Optional element 'ns10:Description' of XML schema type 'xsd:string'
        std::string *Description;
        /// Optional element 'ns10:EventDateTime' of XML schema type 'xsd:dateTime'
        time_t *EventDateTime;
        /// Optional element 'ns10:EventType' of XML schema type 'ns10:EEventTypes'
        enum ns10__EEventTypes *EventType;
        /// Optional element 'ns10:Id' of XML schema type 'xsd:int'
        int *Id;
        /// Optional element 'ns10:Title' of XML schema type 'xsd:string'
        std::string *Title;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__EEvent
        virtual long soap_type(void) const { return SOAP_TYPE_ns10__EEvent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__EEvent, default initialized and not managed by a soap context
        virtual ns10__EEvent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns10__EEvent); }
      public:
        /// Constructor with default initializations
        ns10__EEvent() : Confirmed(), Description(), EventDateTime(), EventType(), Id(), Title(), soap() { }
        virtual ~ns10__EEvent() { }
        /// Friend allocator used by soap_new_ns10__EEvent(struct soap*, int)
        friend SOAP_FMAC1 ns10__EEvent * SOAP_FMAC2 soap_instantiate_ns10__EEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:2847 */
#ifndef SOAP_TYPE___tempuri__StartAutoPlan
#define SOAP_TYPE___tempuri__StartAutoPlan (172)
/* Wrapper: */
struct SOAP_CMAC __tempuri__StartAutoPlan {
      public:
        /** Optional element 'ns2:StartAutoPlan' of XML schema type 'ns2:StartAutoPlan' */
        _ns2__StartAutoPlan *ns2__StartAutoPlan;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__StartAutoPlan */
        long soap_type() const { return SOAP_TYPE___tempuri__StartAutoPlan; }
        /** Constructor with member initializations */
        __tempuri__StartAutoPlan() : ns2__StartAutoPlan() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__StartAutoPlan * SOAP_FMAC2 soap_instantiate___tempuri__StartAutoPlan(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:2917 */
#ifndef SOAP_TYPE___tempuri__StartOperation
#define SOAP_TYPE___tempuri__StartOperation (176)
/* Wrapper: */
struct SOAP_CMAC __tempuri__StartOperation {
      public:
        /** Optional element 'ns2:StartOperation' of XML schema type 'ns2:StartOperation' */
        _ns2__StartOperation *ns2__StartOperation;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__StartOperation */
        long soap_type() const { return SOAP_TYPE___tempuri__StartOperation; }
        /** Constructor with member initializations */
        __tempuri__StartOperation() : ns2__StartOperation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__StartOperation * SOAP_FMAC2 soap_instantiate___tempuri__StartOperation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:2987 */
#ifndef SOAP_TYPE___tempuri__StopAnalyzing
#define SOAP_TYPE___tempuri__StopAnalyzing (180)
/* Wrapper: */
struct SOAP_CMAC __tempuri__StopAnalyzing {
      public:
        /** Optional element 'ns2:StopAnalyzing' of XML schema type 'ns2:StopAnalyzing' */
        _ns2__StopAnalyzing *ns2__StopAnalyzing;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__StopAnalyzing */
        long soap_type() const { return SOAP_TYPE___tempuri__StopAnalyzing; }
        /** Constructor with member initializations */
        __tempuri__StopAnalyzing() : ns2__StopAnalyzing() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__StopAnalyzing * SOAP_FMAC2 soap_instantiate___tempuri__StopAnalyzing(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:3057 */
#ifndef SOAP_TYPE___tempuri__AbortAnalyzing
#define SOAP_TYPE___tempuri__AbortAnalyzing (184)
/* Wrapper: */
struct SOAP_CMAC __tempuri__AbortAnalyzing {
      public:
        /** Optional element 'ns2:AbortAnalyzing' of XML schema type 'ns2:AbortAnalyzing' */
        _ns2__AbortAnalyzing *ns2__AbortAnalyzing;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__AbortAnalyzing */
        long soap_type() const { return SOAP_TYPE___tempuri__AbortAnalyzing; }
        /** Constructor with member initializations */
        __tempuri__AbortAnalyzing() : ns2__AbortAnalyzing() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__AbortAnalyzing * SOAP_FMAC2 soap_instantiate___tempuri__AbortAnalyzing(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:3127 */
#ifndef SOAP_TYPE___tempuri__GetProcessingInfo
#define SOAP_TYPE___tempuri__GetProcessingInfo (188)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetProcessingInfo {
      public:
        /** Optional element 'ns2:GetProcessingInfo' of XML schema type 'ns2:GetProcessingInfo' */
        _ns2__GetProcessingInfo *ns2__GetProcessingInfo;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetProcessingInfo */
        long soap_type() const { return SOAP_TYPE___tempuri__GetProcessingInfo; }
        /** Constructor with member initializations */
        __tempuri__GetProcessingInfo() : ns2__GetProcessingInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetProcessingInfo * SOAP_FMAC2 soap_instantiate___tempuri__GetProcessingInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:3197 */
#ifndef SOAP_TYPE___tempuri__SetIgnoreClearing
#define SOAP_TYPE___tempuri__SetIgnoreClearing (192)
/* Wrapper: */
struct SOAP_CMAC __tempuri__SetIgnoreClearing {
      public:
        /** Optional element 'ns2:SetIgnoreClearing' of XML schema type 'ns2:SetIgnoreClearing' */
        _ns2__SetIgnoreClearing *ns2__SetIgnoreClearing;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__SetIgnoreClearing */
        long soap_type() const { return SOAP_TYPE___tempuri__SetIgnoreClearing; }
        /** Constructor with member initializations */
        __tempuri__SetIgnoreClearing() : ns2__SetIgnoreClearing() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__SetIgnoreClearing * SOAP_FMAC2 soap_instantiate___tempuri__SetIgnoreClearing(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:3267 */
#ifndef SOAP_TYPE___tempuri__GetSystemConfigurations
#define SOAP_TYPE___tempuri__GetSystemConfigurations (196)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetSystemConfigurations {
      public:
        /** Optional element 'ns2:GetSystemConfigurations' of XML schema type 'ns2:GetSystemConfigurations' */
        _ns2__GetSystemConfigurations *ns2__GetSystemConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetSystemConfigurations */
        long soap_type() const { return SOAP_TYPE___tempuri__GetSystemConfigurations; }
        /** Constructor with member initializations */
        __tempuri__GetSystemConfigurations() : ns2__GetSystemConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetSystemConfigurations * SOAP_FMAC2 soap_instantiate___tempuri__GetSystemConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:3337 */
#ifndef SOAP_TYPE___tempuri__SetSystemConfigurations
#define SOAP_TYPE___tempuri__SetSystemConfigurations (200)
/* Wrapper: */
struct SOAP_CMAC __tempuri__SetSystemConfigurations {
      public:
        /** Optional element 'ns2:SetSystemConfigurations' of XML schema type 'ns2:SetSystemConfigurations' */
        _ns2__SetSystemConfigurations *ns2__SetSystemConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__SetSystemConfigurations */
        long soap_type() const { return SOAP_TYPE___tempuri__SetSystemConfigurations; }
        /** Constructor with member initializations */
        __tempuri__SetSystemConfigurations() : ns2__SetSystemConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__SetSystemConfigurations * SOAP_FMAC2 soap_instantiate___tempuri__SetSystemConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:3407 */
#ifndef SOAP_TYPE___tempuri__GetResults
#define SOAP_TYPE___tempuri__GetResults (204)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetResults {
      public:
        /** Optional element 'ns2:GetResults' of XML schema type 'ns2:GetResults' */
        _ns2__GetResults *ns2__GetResults;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetResults */
        long soap_type() const { return SOAP_TYPE___tempuri__GetResults; }
        /** Constructor with member initializations */
        __tempuri__GetResults() : ns2__GetResults() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetResults * SOAP_FMAC2 soap_instantiate___tempuri__GetResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:3477 */
#ifndef SOAP_TYPE___tempuri__GetLastResult
#define SOAP_TYPE___tempuri__GetLastResult (208)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetLastResult {
      public:
        /** Optional element 'ns2:GetLastResult' of XML schema type 'ns2:GetLastResult' */
        _ns2__GetLastResult *ns2__GetLastResult;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetLastResult */
        long soap_type() const { return SOAP_TYPE___tempuri__GetLastResult; }
        /** Constructor with member initializations */
        __tempuri__GetLastResult() : ns2__GetLastResult() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetLastResult * SOAP_FMAC2 soap_instantiate___tempuri__GetLastResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:3547 */
#ifndef SOAP_TYPE___tempuri__GetLastResultId
#define SOAP_TYPE___tempuri__GetLastResultId (212)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetLastResultId {
      public:
        /** Optional element 'ns2:GetLastResultId' of XML schema type 'ns2:GetLastResultId' */
        _ns2__GetLastResultId *ns2__GetLastResultId;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetLastResultId */
        long soap_type() const { return SOAP_TYPE___tempuri__GetLastResultId; }
        /** Constructor with member initializations */
        __tempuri__GetLastResultId() : ns2__GetLastResultId() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetLastResultId * SOAP_FMAC2 soap_instantiate___tempuri__GetLastResultId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:3617 */
#ifndef SOAP_TYPE___tempuri__GetResultsSinceId
#define SOAP_TYPE___tempuri__GetResultsSinceId (216)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetResultsSinceId {
      public:
        /** Optional element 'ns2:GetResultsSinceId' of XML schema type 'ns2:GetResultsSinceId' */
        _ns2__GetResultsSinceId *ns2__GetResultsSinceId;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetResultsSinceId */
        long soap_type() const { return SOAP_TYPE___tempuri__GetResultsSinceId; }
        /** Constructor with member initializations */
        __tempuri__GetResultsSinceId() : ns2__GetResultsSinceId() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetResultsSinceId * SOAP_FMAC2 soap_instantiate___tempuri__GetResultsSinceId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:3687 */
#ifndef SOAP_TYPE___tempuri__GetEvents
#define SOAP_TYPE___tempuri__GetEvents (220)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetEvents {
      public:
        /** Optional element 'ns2:GetEvents' of XML schema type 'ns2:GetEvents' */
        _ns2__GetEvents *ns2__GetEvents;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetEvents */
        long soap_type() const { return SOAP_TYPE___tempuri__GetEvents; }
        /** Constructor with member initializations */
        __tempuri__GetEvents() : ns2__GetEvents() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetEvents * SOAP_FMAC2 soap_instantiate___tempuri__GetEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:3757 */
#ifndef SOAP_TYPE___tempuri__GetLastEventId
#define SOAP_TYPE___tempuri__GetLastEventId (224)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetLastEventId {
      public:
        /** Optional element 'ns2:GetLastEventId' of XML schema type 'ns2:GetLastEventId' */
        _ns2__GetLastEventId *ns2__GetLastEventId;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetLastEventId */
        long soap_type() const { return SOAP_TYPE___tempuri__GetLastEventId; }
        /** Constructor with member initializations */
        __tempuri__GetLastEventId() : ns2__GetLastEventId() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetLastEventId * SOAP_FMAC2 soap_instantiate___tempuri__GetLastEventId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* liga.h:3827 */
#ifndef SOAP_TYPE___tempuri__GetEventsSinceId
#define SOAP_TYPE___tempuri__GetEventsSinceId (228)
/* Wrapper: */
struct SOAP_CMAC __tempuri__GetEventsSinceId {
      public:
        /** Optional element 'ns2:GetEventsSinceId' of XML schema type 'ns2:GetEventsSinceId' */
        _ns2__GetEventsSinceId *ns2__GetEventsSinceId;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__GetEventsSinceId */
        long soap_type() const { return SOAP_TYPE___tempuri__GetEventsSinceId; }
        /** Constructor with member initializations */
        __tempuri__GetEventsSinceId() : ns2__GetEventsSinceId() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__GetEventsSinceId * SOAP_FMAC2 soap_instantiate___tempuri__GetEventsSinceId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:64 */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (229)
/* complex XML schema type 'wsa5:EndpointReferenceType': */
struct SOAP_CMAC wsa5__EndpointReferenceType {
      public:
        /** Required element 'wsa5:Address' of XML schema type 'xsd:string' */
        char *Address;
        /** Optional element 'wsa5:ReferenceParameters' of XML schema type 'wsa5:ReferenceParametersType' */
        struct wsa5__ReferenceParametersType *ReferenceParameters;
        /** Optional element 'wsa5:Metadata' of XML schema type 'wsa5:MetadataType' */
        struct wsa5__MetadataType *Metadata;
        /** Sequence of elements '-any' of XML schema type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__EndpointReferenceType */
        long soap_type() const { return SOAP_TYPE_wsa5__EndpointReferenceType; }
        /** Constructor with member initializations */
        wsa5__EndpointReferenceType() : Address(), ReferenceParameters(), Metadata(), __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:67 */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (230)
/* complex XML schema type 'wsa5:ReferenceParametersType': */
struct SOAP_CMAC wsa5__ReferenceParametersType {
      public:
        /** Optional element 'chan:ChannelInstance' of XML schema type 'xsd:int' */
        int *chan__ChannelInstance;
        /** Sequence of elements '-any' of XML schema type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__ReferenceParametersType */
        long soap_type() const { return SOAP_TYPE_wsa5__ReferenceParametersType; }
        /** Constructor with member initializations */
        wsa5__ReferenceParametersType() : chan__ChannelInstance(), __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:70 */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (231)
/* complex XML schema type 'wsa5:MetadataType': */
struct SOAP_CMAC wsa5__MetadataType {
      public:
        /** Sequence of elements '-any' of XML schema type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__MetadataType */
        long soap_type() const { return SOAP_TYPE_wsa5__MetadataType; }
        /** Constructor with member initializations */
        wsa5__MetadataType() : __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:85 */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (233)
/* complex XML schema type 'wsa5:ProblemActionType': */
struct SOAP_CMAC wsa5__ProblemActionType {
      public:
        /** Optional element 'wsa5:Action' of XML schema type 'xsd:string' */
        char *Action;
        /** Optional element 'wsa5:SoapAction' of XML schema type 'xsd:string' */
        char *SoapAction;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__ProblemActionType */
        long soap_type() const { return SOAP_TYPE_wsa5__ProblemActionType; }
        /** Constructor with member initializations */
        wsa5__ProblemActionType() : Action(), SoapAction(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:73 */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (232)
/* simple XML schema type 'wsa5:RelatesToType': */
struct SOAP_CMAC wsa5__RelatesToType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'RelationshipType' of XML schema type 'wsa5:RelationshipTypeOpenEnum' */
        char *RelationshipType;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__RelatesToType */
        long soap_type() const { return SOAP_TYPE_wsa5__RelatesToType; }
        /** Constructor with member initializations */
        wsa5__RelatesToType() : __item(), RelationshipType(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:259 */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (257)
/* simple XML schema type 'chan:ChannelInstanceType': */
struct SOAP_CMAC chan__ChannelInstanceType {
      public:
        /** Simple content of XML schema type 'xsd:int' wrapped by this struct */
        int __item;
        /** Optional attribute 'wsa5:IsReferenceParameter' of XML schema type 'wsa5:IsReferenceParameter' */
        enum _wsa5__IsReferenceParameter wsa5__IsReferenceParameter;	 /**< initialized with default value = (enum _wsa5__IsReferenceParameter)0 */
      public:
        /** Return unique type id SOAP_TYPE_chan__ChannelInstanceType */
        long soap_type() const { return SOAP_TYPE_chan__ChannelInstanceType; }
        /** Constructor with member initializations */
        chan__ChannelInstanceType() : __item(), wsa5__IsReferenceParameter((enum _wsa5__IsReferenceParameter)0) { }
        /** Friend allocator */
        friend SOAP_FMAC1 chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:265 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (258)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Optional element 'wsa5:MessageID' of XML schema type 'wsa5:MessageID' */
        char *wsa5__MessageID;
        /** Optional element 'wsa5:RelatesTo' of XML schema type 'wsa5:RelatesTo' */
        struct wsa5__RelatesToType *wsa5__RelatesTo;
        /** Optional element 'wsa5:From' of XML schema type 'wsa5:From' */
        struct wsa5__EndpointReferenceType *wsa5__From;
        /** MustUnderstand */
        struct wsa5__EndpointReferenceType *wsa5__ReplyTo;
        /** MustUnderstand */
        struct wsa5__EndpointReferenceType *wsa5__FaultTo;
        /** MustUnderstand */
        char *wsa5__To;
        /** MustUnderstand */
        char *wsa5__Action;
        /** Optional element 'chan:ChannelInstance' of XML schema type 'chan:ChannelInstanceType' */
        struct chan__ChannelInstanceType *chan__ChannelInstance;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() : wsa5__MessageID(), wsa5__RelatesTo(), wsa5__From(), wsa5__ReplyTo(), wsa5__FaultTo(), wsa5__To(), wsa5__Action(), chan__ChannelInstance() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:282 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (264)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:283 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (266)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:284 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (268)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:289 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (271)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* liga.h:206 */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (13)
typedef unsigned char xsd__unsignedByte;
#endif

/* liga.h:209 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (15)
typedef std::string xsd__decimal;
#endif

/* wsa5.h:88 */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (234)
typedef char *wsa5__RelationshipTypeOpenEnum;
#endif

/* wsa5.h:91 */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (235)
typedef char *wsa5__FaultCodesOpenEnumType;
#endif

/* wsa5.h:210 */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (241)
typedef struct wsa5__EndpointReferenceType _wsa5__EndpointReference;
#endif

/* wsa5.h:213 */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (242)
typedef struct wsa5__ReferenceParametersType _wsa5__ReferenceParameters;
#endif

/* wsa5.h:216 */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (243)
typedef struct wsa5__MetadataType _wsa5__Metadata;
#endif

/* wsa5.h:219 */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (244)
typedef char *_wsa5__MessageID;
#endif

/* wsa5.h:222 */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (245)
typedef struct wsa5__RelatesToType _wsa5__RelatesTo;
#endif

/* wsa5.h:225 */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (246)
typedef struct wsa5__EndpointReferenceType _wsa5__ReplyTo;
#endif

/* wsa5.h:228 */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (247)
typedef struct wsa5__EndpointReferenceType _wsa5__From;
#endif

/* wsa5.h:231 */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (248)
typedef struct wsa5__EndpointReferenceType _wsa5__FaultTo;
#endif

/* wsa5.h:234 */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (249)
typedef char *_wsa5__To;
#endif

/* wsa5.h:237 */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (250)
typedef char *_wsa5__Action;
#endif

/* wsa5.h:240 */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (252)
typedef ULONG64 _wsa5__RetryAfter;
#endif

/* wsa5.h:243 */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (253)
typedef _QName _wsa5__ProblemHeaderQName;
#endif

/* wsa5.h:246 */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (254)
typedef char *_wsa5__ProblemIRI;
#endif

/* wsa5.h:249 */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (255)
typedef struct wsa5__ProblemActionType _wsa5__ProblemAction;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_LONG64
#define SOAP_TYPE_LONG64 (141)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (115)
#endif

/* xsd__unsignedByte has binding name 'xsd__unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (13)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (12)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (11)
#endif

/* _wsa5__RetryAfter has binding name '_wsa5__RetryAfter' for type '' */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (252)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (251)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (99)
#endif

/* enum _wsa5__IsReferenceParameter has binding name '_wsa5__IsReferenceParameter' for type 'wsa5:IsReferenceParameter' */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (256)
#endif

/* enum wsa5__FaultCodesType has binding name 'wsa5__FaultCodesType' for type 'wsa5:FaultCodesType' */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (237)
#endif

/* enum wsa5__RelationshipType has binding name 'wsa5__RelationshipType' for type 'wsa5:RelationshipType' */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (236)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (96)
#endif

/* enum ns10__EEventTypes has binding name 'ns10__EEventTypes' for type 'ns10:EEventTypes' */
#ifndef SOAP_TYPE_ns10__EEventTypes
#define SOAP_TYPE_ns10__EEventTypes (92)
#endif

/* enum ns10__EResultValueStatus has binding name 'ns10__EResultValueStatus' for type 'ns10:EResultValueStatus' */
#ifndef SOAP_TYPE_ns10__EResultValueStatus
#define SOAP_TYPE_ns10__EResultValueStatus (91)
#endif

/* enum ns10__EResultStatus has binding name 'ns10__EResultStatus' for type 'ns10:EResultStatus' */
#ifndef SOAP_TYPE_ns10__EResultStatus
#define SOAP_TYPE_ns10__EResultStatus (90)
#endif

/* enum ns10__ESampleTypes has binding name 'ns10__ESampleTypes' for type 'ns10:ESampleTypes' */
#ifndef SOAP_TYPE_ns10__ESampleTypes
#define SOAP_TYPE_ns10__ESampleTypes (89)
#endif

/* enum ns9__ChromatographMode has binding name 'ns9__ChromatographMode' for type 'ns9:ChromatographMode' */
#ifndef SOAP_TYPE_ns9__ChromatographMode
#define SOAP_TYPE_ns9__ChromatographMode (88)
#endif

/* enum ns8__Logger_x002eLogLevel has binding name 'ns8__Logger_x002eLogLevel' for type 'ns8:Logger.LogLevel' */
#ifndef SOAP_TYPE_ns8__Logger_x002eLogLevel
#define SOAP_TYPE_ns8__Logger_x002eLogLevel (87)
#endif

/* enum ns4__OperationTypes has binding name 'ns4__OperationTypes' for type 'ns4:OperationTypes' */
#ifndef SOAP_TYPE_ns4__OperationTypes
#define SOAP_TYPE_ns4__OperationTypes (86)
#endif

/* enum ns4__ControlledParametr_x002eControlActionType has binding name 'ns4__ControlledParametr_x002eControlActionType' for type 'ns4:ControlledParametr.ControlActionType' */
#ifndef SOAP_TYPE_ns4__ControlledParametr_x002eControlActionType
#define SOAP_TYPE_ns4__ControlledParametr_x002eControlActionType (85)
#endif

/* enum ns4__OperationStepTypes has binding name 'ns4__OperationStepTypes' for type 'ns4:OperationStepTypes' */
#ifndef SOAP_TYPE_ns4__OperationStepTypes
#define SOAP_TYPE_ns4__OperationStepTypes (84)
#endif

/* enum ns3__ProcessingModes has binding name 'ns3__ProcessingModes' for type 'ns3:ProcessingModes' */
#ifndef SOAP_TYPE_ns3__ProcessingModes
#define SOAP_TYPE_ns3__ProcessingModes (83)
#endif

/* enum ns3__OperationProcInfo_x002eOperationStepInfoStates has binding name 'ns3__OperationProcInfo_x002eOperationStepInfoStates' for type 'ns3:OperationProcInfo.OperationStepInfoStates' */
#ifndef SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfoStates
#define SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfoStates (82)
#endif

/* ns10__EEvent has binding name 'ns10__EEvent' for type 'ns10:EEvent' */
#ifndef SOAP_TYPE_ns10__EEvent
#define SOAP_TYPE_ns10__EEvent (81)
#endif

/* ns10__ArrayOfEEvent has binding name 'ns10__ArrayOfEEvent' for type 'ns10:ArrayOfEEvent' */
#ifndef SOAP_TYPE_ns10__ArrayOfEEvent
#define SOAP_TYPE_ns10__ArrayOfEEvent (80)
#endif

/* ns10__EResult has binding name 'ns10__EResult' for type 'ns10:EResult' */
#ifndef SOAP_TYPE_ns10__EResult
#define SOAP_TYPE_ns10__EResult (79)
#endif

/* ns10__ArrayOfEResult has binding name 'ns10__ArrayOfEResult' for type 'ns10:ArrayOfEResult' */
#ifndef SOAP_TYPE_ns10__ArrayOfEResult
#define SOAP_TYPE_ns10__ArrayOfEResult (78)
#endif

/* ns10__ESample has binding name 'ns10__ESample' for type 'ns10:ESample' */
#ifndef SOAP_TYPE_ns10__ESample
#define SOAP_TYPE_ns10__ESample (77)
#endif

/* ns10__ArrayOfESample has binding name 'ns10__ArrayOfESample' for type 'ns10:ArrayOfESample' */
#ifndef SOAP_TYPE_ns10__ArrayOfESample
#define SOAP_TYPE_ns10__ArrayOfESample (76)
#endif

/* ns7__AuxDeviceState has binding name 'ns7__AuxDeviceState' for type 'ns7:AuxDeviceState' */
#ifndef SOAP_TYPE_ns7__AuxDeviceState
#define SOAP_TYPE_ns7__AuxDeviceState (75)
#endif

/* ns7__ArrayOfAuxDeviceState has binding name 'ns7__ArrayOfAuxDeviceState' for type 'ns7:ArrayOfAuxDeviceState' */
#ifndef SOAP_TYPE_ns7__ArrayOfAuxDeviceState
#define SOAP_TYPE_ns7__ArrayOfAuxDeviceState (74)
#endif

/* ns7__AuxDevice has binding name 'ns7__AuxDevice' for type 'ns7:AuxDevice' */
#ifndef SOAP_TYPE_ns7__AuxDevice
#define SOAP_TYPE_ns7__AuxDevice (73)
#endif

/* ns7__ArrayOfAuxDevice has binding name 'ns7__ArrayOfAuxDevice' for type 'ns7:ArrayOfAuxDevice' */
#ifndef SOAP_TYPE_ns7__ArrayOfAuxDevice
#define SOAP_TYPE_ns7__ArrayOfAuxDevice (72)
#endif

/* ns7__AuxControllerConfiguration has binding name 'ns7__AuxControllerConfiguration' for type 'ns7:AuxControllerConfiguration' */
#ifndef SOAP_TYPE_ns7__AuxControllerConfiguration
#define SOAP_TYPE_ns7__AuxControllerConfiguration (71)
#endif

/* ns6__Aux2Config has binding name 'ns6__Aux2Config' for type 'ns6:Aux2Config' */
#ifndef SOAP_TYPE_ns6__Aux2Config
#define SOAP_TYPE_ns6__Aux2Config (70)
#endif

/* ns5__SystemConfigurations has binding name 'ns5__SystemConfigurations' for type 'ns5:SystemConfigurations' */
#ifndef SOAP_TYPE_ns5__SystemConfigurations
#define SOAP_TYPE_ns5__SystemConfigurations (69)
#endif

/* arr__ArrayOfboolean has binding name 'arr__ArrayOfboolean' for type 'arr:ArrayOfboolean' */
#ifndef SOAP_TYPE_arr__ArrayOfboolean
#define SOAP_TYPE_arr__ArrayOfboolean (68)
#endif

/* arr__ArrayOfstring has binding name 'arr__ArrayOfstring' for type 'arr:ArrayOfstring' */
#ifndef SOAP_TYPE_arr__ArrayOfstring
#define SOAP_TYPE_arr__ArrayOfstring (67)
#endif

/* ns4__OperationStep_x002eUsingControlledParametr has binding name 'ns4__OperationStep_x002eUsingControlledParametr' for type 'ns4:OperationStep.UsingControlledParametr' */
#ifndef SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr
#define SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr (66)
#endif

/* ns4__ArrayOfOperationStep_x002eUsingControlledParametr has binding name 'ns4__ArrayOfOperationStep_x002eUsingControlledParametr' for type 'ns4:ArrayOfOperationStep.UsingControlledParametr' */
#ifndef SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr
#define SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr (65)
#endif

/* ns4__OperationStep has binding name 'ns4__OperationStep' for type 'ns4:OperationStep' */
#ifndef SOAP_TYPE_ns4__OperationStep
#define SOAP_TYPE_ns4__OperationStep (64)
#endif

/* ns4__ArrayOfOperationStep has binding name 'ns4__ArrayOfOperationStep' for type 'ns4:ArrayOfOperationStep' */
#ifndef SOAP_TYPE_ns4__ArrayOfOperationStep
#define SOAP_TYPE_ns4__ArrayOfOperationStep (63)
#endif

/* ns4__Operation has binding name 'ns4__Operation' for type 'ns4:Operation' */
#ifndef SOAP_TYPE_ns4__Operation
#define SOAP_TYPE_ns4__Operation (62)
#endif

/* ns4__ArrayOfOperation has binding name 'ns4__ArrayOfOperation' for type 'ns4:ArrayOfOperation' */
#ifndef SOAP_TYPE_ns4__ArrayOfOperation
#define SOAP_TYPE_ns4__ArrayOfOperation (61)
#endif

/* ns4__MeasuringComponent has binding name 'ns4__MeasuringComponent' for type 'ns4:MeasuringComponent' */
#ifndef SOAP_TYPE_ns4__MeasuringComponent
#define SOAP_TYPE_ns4__MeasuringComponent (60)
#endif

/* ns4__ArrayOfMeasuringComponent has binding name 'ns4__ArrayOfMeasuringComponent' for type 'ns4:ArrayOfMeasuringComponent' */
#ifndef SOAP_TYPE_ns4__ArrayOfMeasuringComponent
#define SOAP_TYPE_ns4__ArrayOfMeasuringComponent (59)
#endif

/* ns4__ControlledParametr has binding name 'ns4__ControlledParametr' for type 'ns4:ControlledParametr' */
#ifndef SOAP_TYPE_ns4__ControlledParametr
#define SOAP_TYPE_ns4__ControlledParametr (58)
#endif

/* ns4__ArrayOfControlledParametr has binding name 'ns4__ArrayOfControlledParametr' for type 'ns4:ArrayOfControlledParametr' */
#ifndef SOAP_TYPE_ns4__ArrayOfControlledParametr
#define SOAP_TYPE_ns4__ArrayOfControlledParametr (57)
#endif

/* ns4__Periodicity_x002eTime has binding name 'ns4__Periodicity_x002eTime' for type 'ns4:Periodicity.Time' */
#ifndef SOAP_TYPE_ns4__Periodicity_x002eTime
#define SOAP_TYPE_ns4__Periodicity_x002eTime (56)
#endif

/* ns4__ArrayOfPeriodicity_x002eTime has binding name 'ns4__ArrayOfPeriodicity_x002eTime' for type 'ns4:ArrayOfPeriodicity.Time' */
#ifndef SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime
#define SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime (55)
#endif

/* ns4__Periodicity has binding name 'ns4__Periodicity' for type 'ns4:Periodicity' */
#ifndef SOAP_TYPE_ns4__Periodicity
#define SOAP_TYPE_ns4__Periodicity (54)
#endif

/* ns4__AutoPlanItem has binding name 'ns4__AutoPlanItem' for type 'ns4:AutoPlanItem' */
#ifndef SOAP_TYPE_ns4__AutoPlanItem
#define SOAP_TYPE_ns4__AutoPlanItem (53)
#endif

/* ns4__ArrayOfAutoPlanItem has binding name 'ns4__ArrayOfAutoPlanItem' for type 'ns4:ArrayOfAutoPlanItem' */
#ifndef SOAP_TYPE_ns4__ArrayOfAutoPlanItem
#define SOAP_TYPE_ns4__ArrayOfAutoPlanItem (52)
#endif

/* ns3__OperationProcInfo_x002eOperationStepInfo has binding name 'ns3__OperationProcInfo_x002eOperationStepInfo' for type 'ns3:OperationProcInfo.OperationStepInfo' */
#ifndef SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo
#define SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo (51)
#endif

/* ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo has binding name 'ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo' for type 'ns3:ArrayOfOperationProcInfo.OperationStepInfo' */
#ifndef SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo
#define SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo (50)
#endif

/* ns3__OperationProcInfo_x002eControlParamInfo has binding name 'ns3__OperationProcInfo_x002eControlParamInfo' for type 'ns3:OperationProcInfo.ControlParamInfo' */
#ifndef SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo
#define SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo (49)
#endif

/* ns3__ArrayOfOperationProcInfo_x002eControlParamInfo has binding name 'ns3__ArrayOfOperationProcInfo_x002eControlParamInfo' for type 'ns3:ArrayOfOperationProcInfo.ControlParamInfo' */
#ifndef SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo
#define SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo (48)
#endif

/* ns3__OperationProcInfo has binding name 'ns3__OperationProcInfo' for type 'ns3:OperationProcInfo' */
#ifndef SOAP_TYPE_ns3__OperationProcInfo
#define SOAP_TYPE_ns3__OperationProcInfo (47)
#endif

/* ns3__ProcessingInfo has binding name 'ns3__ProcessingInfo' for type 'ns3:ProcessingInfo' */
#ifndef SOAP_TYPE_ns3__ProcessingInfo
#define SOAP_TYPE_ns3__ProcessingInfo (46)
#endif

/* _ns2__GetEventsSinceIdResponse has binding name '_ns2__GetEventsSinceIdResponse' for type '' */
#ifndef SOAP_TYPE__ns2__GetEventsSinceIdResponse
#define SOAP_TYPE__ns2__GetEventsSinceIdResponse (45)
#endif

/* _ns2__GetEventsSinceId has binding name '_ns2__GetEventsSinceId' for type '' */
#ifndef SOAP_TYPE__ns2__GetEventsSinceId
#define SOAP_TYPE__ns2__GetEventsSinceId (44)
#endif

/* _ns2__GetLastEventIdResponse has binding name '_ns2__GetLastEventIdResponse' for type '' */
#ifndef SOAP_TYPE__ns2__GetLastEventIdResponse
#define SOAP_TYPE__ns2__GetLastEventIdResponse (43)
#endif

/* _ns2__GetLastEventId has binding name '_ns2__GetLastEventId' for type '' */
#ifndef SOAP_TYPE__ns2__GetLastEventId
#define SOAP_TYPE__ns2__GetLastEventId (42)
#endif

/* _ns2__GetEventsResponse has binding name '_ns2__GetEventsResponse' for type '' */
#ifndef SOAP_TYPE__ns2__GetEventsResponse
#define SOAP_TYPE__ns2__GetEventsResponse (41)
#endif

/* _ns2__GetEvents has binding name '_ns2__GetEvents' for type '' */
#ifndef SOAP_TYPE__ns2__GetEvents
#define SOAP_TYPE__ns2__GetEvents (40)
#endif

/* _ns2__GetResultsSinceIdResponse has binding name '_ns2__GetResultsSinceIdResponse' for type '' */
#ifndef SOAP_TYPE__ns2__GetResultsSinceIdResponse
#define SOAP_TYPE__ns2__GetResultsSinceIdResponse (39)
#endif

/* _ns2__GetResultsSinceId has binding name '_ns2__GetResultsSinceId' for type '' */
#ifndef SOAP_TYPE__ns2__GetResultsSinceId
#define SOAP_TYPE__ns2__GetResultsSinceId (38)
#endif

/* _ns2__GetLastResultIdResponse has binding name '_ns2__GetLastResultIdResponse' for type '' */
#ifndef SOAP_TYPE__ns2__GetLastResultIdResponse
#define SOAP_TYPE__ns2__GetLastResultIdResponse (37)
#endif

/* _ns2__GetLastResultId has binding name '_ns2__GetLastResultId' for type '' */
#ifndef SOAP_TYPE__ns2__GetLastResultId
#define SOAP_TYPE__ns2__GetLastResultId (36)
#endif

/* _ns2__GetLastResultResponse has binding name '_ns2__GetLastResultResponse' for type '' */
#ifndef SOAP_TYPE__ns2__GetLastResultResponse
#define SOAP_TYPE__ns2__GetLastResultResponse (35)
#endif

/* _ns2__GetLastResult has binding name '_ns2__GetLastResult' for type '' */
#ifndef SOAP_TYPE__ns2__GetLastResult
#define SOAP_TYPE__ns2__GetLastResult (34)
#endif

/* _ns2__GetResultsResponse has binding name '_ns2__GetResultsResponse' for type '' */
#ifndef SOAP_TYPE__ns2__GetResultsResponse
#define SOAP_TYPE__ns2__GetResultsResponse (33)
#endif

/* _ns2__GetResults has binding name '_ns2__GetResults' for type '' */
#ifndef SOAP_TYPE__ns2__GetResults
#define SOAP_TYPE__ns2__GetResults (32)
#endif

/* _ns2__SetSystemConfigurationsResponse has binding name '_ns2__SetSystemConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns2__SetSystemConfigurationsResponse
#define SOAP_TYPE__ns2__SetSystemConfigurationsResponse (31)
#endif

/* _ns2__SetSystemConfigurations has binding name '_ns2__SetSystemConfigurations' for type '' */
#ifndef SOAP_TYPE__ns2__SetSystemConfigurations
#define SOAP_TYPE__ns2__SetSystemConfigurations (30)
#endif

/* _ns2__GetSystemConfigurationsResponse has binding name '_ns2__GetSystemConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns2__GetSystemConfigurationsResponse
#define SOAP_TYPE__ns2__GetSystemConfigurationsResponse (29)
#endif

/* _ns2__GetSystemConfigurations has binding name '_ns2__GetSystemConfigurations' for type '' */
#ifndef SOAP_TYPE__ns2__GetSystemConfigurations
#define SOAP_TYPE__ns2__GetSystemConfigurations (28)
#endif

/* _ns2__SetIgnoreClearingResponse has binding name '_ns2__SetIgnoreClearingResponse' for type '' */
#ifndef SOAP_TYPE__ns2__SetIgnoreClearingResponse
#define SOAP_TYPE__ns2__SetIgnoreClearingResponse (27)
#endif

/* _ns2__SetIgnoreClearing has binding name '_ns2__SetIgnoreClearing' for type '' */
#ifndef SOAP_TYPE__ns2__SetIgnoreClearing
#define SOAP_TYPE__ns2__SetIgnoreClearing (26)
#endif

/* _ns2__GetProcessingInfoResponse has binding name '_ns2__GetProcessingInfoResponse' for type '' */
#ifndef SOAP_TYPE__ns2__GetProcessingInfoResponse
#define SOAP_TYPE__ns2__GetProcessingInfoResponse (25)
#endif

/* _ns2__GetProcessingInfo has binding name '_ns2__GetProcessingInfo' for type '' */
#ifndef SOAP_TYPE__ns2__GetProcessingInfo
#define SOAP_TYPE__ns2__GetProcessingInfo (24)
#endif

/* _ns2__AbortAnalyzingResponse has binding name '_ns2__AbortAnalyzingResponse' for type '' */
#ifndef SOAP_TYPE__ns2__AbortAnalyzingResponse
#define SOAP_TYPE__ns2__AbortAnalyzingResponse (23)
#endif

/* _ns2__AbortAnalyzing has binding name '_ns2__AbortAnalyzing' for type '' */
#ifndef SOAP_TYPE__ns2__AbortAnalyzing
#define SOAP_TYPE__ns2__AbortAnalyzing (22)
#endif

/* _ns2__StopAnalyzingResponse has binding name '_ns2__StopAnalyzingResponse' for type '' */
#ifndef SOAP_TYPE__ns2__StopAnalyzingResponse
#define SOAP_TYPE__ns2__StopAnalyzingResponse (21)
#endif

/* _ns2__StopAnalyzing has binding name '_ns2__StopAnalyzing' for type '' */
#ifndef SOAP_TYPE__ns2__StopAnalyzing
#define SOAP_TYPE__ns2__StopAnalyzing (20)
#endif

/* _ns2__StartOperationResponse has binding name '_ns2__StartOperationResponse' for type '' */
#ifndef SOAP_TYPE__ns2__StartOperationResponse
#define SOAP_TYPE__ns2__StartOperationResponse (19)
#endif

/* _ns2__StartOperation has binding name '_ns2__StartOperation' for type '' */
#ifndef SOAP_TYPE__ns2__StartOperation
#define SOAP_TYPE__ns2__StartOperation (18)
#endif

/* _ns2__StartAutoPlanResponse has binding name '_ns2__StartAutoPlanResponse' for type '' */
#ifndef SOAP_TYPE__ns2__StartAutoPlanResponse
#define SOAP_TYPE__ns2__StartAutoPlanResponse (17)
#endif

/* _ns2__StartAutoPlan has binding name '_ns2__StartAutoPlan' for type '' */
#ifndef SOAP_TYPE__ns2__StartAutoPlan
#define SOAP_TYPE__ns2__StartAutoPlan (16)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (15)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (14)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (271)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (268)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (266)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (264)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (258)
#endif

/* struct chan__ChannelInstanceType has binding name 'chan__ChannelInstanceType' for type 'chan:ChannelInstanceType' */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (257)
#endif

/* _wsa5__ProblemAction has binding name '_wsa5__ProblemAction' for type '' */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (255)
#endif

/* _wsa5__FaultTo has binding name '_wsa5__FaultTo' for type '' */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (248)
#endif

/* _wsa5__From has binding name '_wsa5__From' for type '' */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (247)
#endif

/* _wsa5__ReplyTo has binding name '_wsa5__ReplyTo' for type '' */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (246)
#endif

/* _wsa5__RelatesTo has binding name '_wsa5__RelatesTo' for type '' */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (245)
#endif

/* _wsa5__Metadata has binding name '_wsa5__Metadata' for type '' */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (243)
#endif

/* _wsa5__ReferenceParameters has binding name '_wsa5__ReferenceParameters' for type '' */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (242)
#endif

/* _wsa5__EndpointReference has binding name '_wsa5__EndpointReference' for type '' */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (241)
#endif

/* struct wsa5__ProblemActionType has binding name 'wsa5__ProblemActionType' for type 'wsa5:ProblemActionType' */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (233)
#endif

/* struct wsa5__RelatesToType has binding name 'wsa5__RelatesToType' for type 'wsa5:RelatesToType' */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (232)
#endif

/* struct wsa5__MetadataType has binding name 'wsa5__MetadataType' for type 'wsa5:MetadataType' */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (231)
#endif

/* struct wsa5__ReferenceParametersType has binding name 'wsa5__ReferenceParametersType' for type 'wsa5:ReferenceParametersType' */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (230)
#endif

/* struct wsa5__EndpointReferenceType has binding name 'wsa5__EndpointReferenceType' for type 'wsa5:EndpointReferenceType' */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (229)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (269)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (267)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (265)
#endif

/* struct chan__ChannelInstanceType * has binding name 'PointerTochan__ChannelInstanceType' for type 'chan:ChannelInstanceType' */
#ifndef SOAP_TYPE_PointerTochan__ChannelInstanceType
#define SOAP_TYPE_PointerTochan__ChannelInstanceType (263)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__FaultTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__FaultTo
#define SOAP_TYPE_PointerTo_wsa5__FaultTo (262)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__ReplyTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__ReplyTo
#define SOAP_TYPE_PointerTo_wsa5__ReplyTo (261)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__From' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__From
#define SOAP_TYPE_PointerTo_wsa5__From (260)
#endif

/* struct wsa5__RelatesToType * has binding name 'PointerTo_wsa5__RelatesTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__RelatesTo
#define SOAP_TYPE_PointerTo_wsa5__RelatesTo (259)
#endif

/* _wsa5__ProblemIRI has binding name '_wsa5__ProblemIRI' for type '' */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (254)
#endif

/* _wsa5__ProblemHeaderQName has binding name '_wsa5__ProblemHeaderQName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (253)
#endif

/* _wsa5__Action has binding name '_wsa5__Action' for type '' */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (250)
#endif

/* _wsa5__To has binding name '_wsa5__To' for type '' */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (249)
#endif

/* _wsa5__MessageID has binding name '_wsa5__MessageID' for type '' */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (244)
#endif

/* char ** has binding name 'PointerTo_XML' for type '' */
#ifndef SOAP_TYPE_PointerTo_XML
#define SOAP_TYPE_PointerTo_XML (240)
#endif

/* struct wsa5__MetadataType * has binding name 'PointerTowsa5__MetadataType' for type 'wsa5:MetadataType' */
#ifndef SOAP_TYPE_PointerTowsa5__MetadataType
#define SOAP_TYPE_PointerTowsa5__MetadataType (239)
#endif

/* struct wsa5__ReferenceParametersType * has binding name 'PointerTowsa5__ReferenceParametersType' for type 'wsa5:ReferenceParametersType' */
#ifndef SOAP_TYPE_PointerTowsa5__ReferenceParametersType
#define SOAP_TYPE_PointerTowsa5__ReferenceParametersType (238)
#endif

/* wsa5__FaultCodesOpenEnumType has binding name 'wsa5__FaultCodesOpenEnumType' for type 'wsa5:FaultCodesOpenEnumType' */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (235)
#endif

/* wsa5__RelationshipTypeOpenEnum has binding name 'wsa5__RelationshipTypeOpenEnum' for type 'wsa5:RelationshipTypeOpenEnum' */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (234)
#endif

/* _ns2__GetEventsSinceId * has binding name 'PointerTo_ns2__GetEventsSinceId' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__GetEventsSinceId
#define SOAP_TYPE_PointerTo_ns2__GetEventsSinceId (225)
#endif

/* _ns2__GetLastEventId * has binding name 'PointerTo_ns2__GetLastEventId' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__GetLastEventId
#define SOAP_TYPE_PointerTo_ns2__GetLastEventId (221)
#endif

/* _ns2__GetEvents * has binding name 'PointerTo_ns2__GetEvents' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__GetEvents
#define SOAP_TYPE_PointerTo_ns2__GetEvents (217)
#endif

/* _ns2__GetResultsSinceId * has binding name 'PointerTo_ns2__GetResultsSinceId' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__GetResultsSinceId
#define SOAP_TYPE_PointerTo_ns2__GetResultsSinceId (213)
#endif

/* _ns2__GetLastResultId * has binding name 'PointerTo_ns2__GetLastResultId' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__GetLastResultId
#define SOAP_TYPE_PointerTo_ns2__GetLastResultId (209)
#endif

/* _ns2__GetLastResult * has binding name 'PointerTo_ns2__GetLastResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__GetLastResult
#define SOAP_TYPE_PointerTo_ns2__GetLastResult (205)
#endif

/* _ns2__GetResults * has binding name 'PointerTo_ns2__GetResults' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__GetResults
#define SOAP_TYPE_PointerTo_ns2__GetResults (201)
#endif

/* _ns2__SetSystemConfigurations * has binding name 'PointerTo_ns2__SetSystemConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__SetSystemConfigurations
#define SOAP_TYPE_PointerTo_ns2__SetSystemConfigurations (197)
#endif

/* _ns2__GetSystemConfigurations * has binding name 'PointerTo_ns2__GetSystemConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__GetSystemConfigurations
#define SOAP_TYPE_PointerTo_ns2__GetSystemConfigurations (193)
#endif

/* _ns2__SetIgnoreClearing * has binding name 'PointerTo_ns2__SetIgnoreClearing' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__SetIgnoreClearing
#define SOAP_TYPE_PointerTo_ns2__SetIgnoreClearing (189)
#endif

/* _ns2__GetProcessingInfo * has binding name 'PointerTo_ns2__GetProcessingInfo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__GetProcessingInfo
#define SOAP_TYPE_PointerTo_ns2__GetProcessingInfo (185)
#endif

/* _ns2__AbortAnalyzing * has binding name 'PointerTo_ns2__AbortAnalyzing' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__AbortAnalyzing
#define SOAP_TYPE_PointerTo_ns2__AbortAnalyzing (181)
#endif

/* _ns2__StopAnalyzing * has binding name 'PointerTo_ns2__StopAnalyzing' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__StopAnalyzing
#define SOAP_TYPE_PointerTo_ns2__StopAnalyzing (177)
#endif

/* _ns2__StartOperation * has binding name 'PointerTo_ns2__StartOperation' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__StartOperation
#define SOAP_TYPE_PointerTo_ns2__StartOperation (173)
#endif

/* _ns2__StartAutoPlan * has binding name 'PointerTo_ns2__StartAutoPlan' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__StartAutoPlan
#define SOAP_TYPE_PointerTo_ns2__StartAutoPlan (169)
#endif

/* enum ns10__EEventTypes * has binding name 'PointerTons10__EEventTypes' for type 'ns10:EEventTypes' */
#ifndef SOAP_TYPE_PointerTons10__EEventTypes
#define SOAP_TYPE_PointerTons10__EEventTypes (168)
#endif

/* ns10__EEvent * has binding name 'PointerTons10__EEvent' for type 'ns10:EEvent' */
#ifndef SOAP_TYPE_PointerTons10__EEvent
#define SOAP_TYPE_PointerTons10__EEvent (166)
#endif

/* enum ns10__EResultValueStatus * has binding name 'PointerTons10__EResultValueStatus' for type 'ns10:EResultValueStatus' */
#ifndef SOAP_TYPE_PointerTons10__EResultValueStatus
#define SOAP_TYPE_PointerTons10__EResultValueStatus (165)
#endif

/* enum ns10__EResultStatus * has binding name 'PointerTons10__EResultStatus' for type 'ns10:EResultStatus' */
#ifndef SOAP_TYPE_PointerTons10__EResultStatus
#define SOAP_TYPE_PointerTons10__EResultStatus (164)
#endif

/* ns10__EResult * has binding name 'PointerTons10__EResult' for type 'ns10:EResult' */
#ifndef SOAP_TYPE_PointerTons10__EResult
#define SOAP_TYPE_PointerTons10__EResult (162)
#endif

/* ns10__ArrayOfEResult * has binding name 'PointerTons10__ArrayOfEResult' for type 'ns10:ArrayOfEResult' */
#ifndef SOAP_TYPE_PointerTons10__ArrayOfEResult
#define SOAP_TYPE_PointerTons10__ArrayOfEResult (161)
#endif

/* ns7__AuxDeviceState * has binding name 'PointerTons7__AuxDeviceState' for type 'ns7:AuxDeviceState' */
#ifndef SOAP_TYPE_PointerTons7__AuxDeviceState
#define SOAP_TYPE_PointerTons7__AuxDeviceState (158)
#endif

/* ns7__ArrayOfAuxDeviceState * has binding name 'PointerTons7__ArrayOfAuxDeviceState' for type 'ns7:ArrayOfAuxDeviceState' */
#ifndef SOAP_TYPE_PointerTons7__ArrayOfAuxDeviceState
#define SOAP_TYPE_PointerTons7__ArrayOfAuxDeviceState (157)
#endif

/* ns7__AuxDevice * has binding name 'PointerTons7__AuxDevice' for type 'ns7:AuxDevice' */
#ifndef SOAP_TYPE_PointerTons7__AuxDevice
#define SOAP_TYPE_PointerTons7__AuxDevice (155)
#endif

/* ns7__ArrayOfAuxDevice * has binding name 'PointerTons7__ArrayOfAuxDevice' for type 'ns7:ArrayOfAuxDevice' */
#ifndef SOAP_TYPE_PointerTons7__ArrayOfAuxDevice
#define SOAP_TYPE_PointerTons7__ArrayOfAuxDevice (154)
#endif

/* ns4__ArrayOfOperation * has binding name 'PointerTons4__ArrayOfOperation' for type 'ns4:ArrayOfOperation' */
#ifndef SOAP_TYPE_PointerTons4__ArrayOfOperation
#define SOAP_TYPE_PointerTons4__ArrayOfOperation (153)
#endif

/* ns4__ArrayOfMeasuringComponent * has binding name 'PointerTons4__ArrayOfMeasuringComponent' for type 'ns4:ArrayOfMeasuringComponent' */
#ifndef SOAP_TYPE_PointerTons4__ArrayOfMeasuringComponent
#define SOAP_TYPE_PointerTons4__ArrayOfMeasuringComponent (152)
#endif

/* ns4__ArrayOfControlledParametr * has binding name 'PointerTons4__ArrayOfControlledParametr' for type 'ns4:ArrayOfControlledParametr' */
#ifndef SOAP_TYPE_PointerTons4__ArrayOfControlledParametr
#define SOAP_TYPE_PointerTons4__ArrayOfControlledParametr (151)
#endif

/* enum ns8__Logger_x002eLogLevel * has binding name 'PointerTons8__Logger_x002eLogLevel' for type 'ns8:Logger.LogLevel' */
#ifndef SOAP_TYPE_PointerTons8__Logger_x002eLogLevel
#define SOAP_TYPE_PointerTons8__Logger_x002eLogLevel (150)
#endif

/* ns7__AuxControllerConfiguration * has binding name 'PointerTons7__AuxControllerConfiguration' for type 'ns7:AuxControllerConfiguration' */
#ifndef SOAP_TYPE_PointerTons7__AuxControllerConfiguration
#define SOAP_TYPE_PointerTons7__AuxControllerConfiguration (149)
#endif

/* ns6__Aux2Config * has binding name 'PointerTons6__Aux2Config' for type 'ns6:Aux2Config' */
#ifndef SOAP_TYPE_PointerTons6__Aux2Config
#define SOAP_TYPE_PointerTons6__Aux2Config (148)
#endif

/* ns4__ArrayOfAutoPlanItem * has binding name 'PointerTons4__ArrayOfAutoPlanItem' for type 'ns4:ArrayOfAutoPlanItem' */
#ifndef SOAP_TYPE_PointerTons4__ArrayOfAutoPlanItem
#define SOAP_TYPE_PointerTons4__ArrayOfAutoPlanItem (147)
#endif

/* ns4__OperationStep_x002eUsingControlledParametr * has binding name 'PointerTons4__OperationStep_x002eUsingControlledParametr' for type 'ns4:OperationStep.UsingControlledParametr' */
#ifndef SOAP_TYPE_PointerTons4__OperationStep_x002eUsingControlledParametr
#define SOAP_TYPE_PointerTons4__OperationStep_x002eUsingControlledParametr (143)
#endif

/* LONG64 * has binding name 'PointerToLONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_PointerToLONG64
#define SOAP_TYPE_PointerToLONG64 (142)
#endif

/* enum ns9__ChromatographMode * has binding name 'PointerTons9__ChromatographMode' for type 'ns9:ChromatographMode' */
#ifndef SOAP_TYPE_PointerTons9__ChromatographMode
#define SOAP_TYPE_PointerTons9__ChromatographMode (140)
#endif

/* ns4__ArrayOfOperationStep_x002eUsingControlledParametr * has binding name 'PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr' for type 'ns4:ArrayOfOperationStep.UsingControlledParametr' */
#ifndef SOAP_TYPE_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr
#define SOAP_TYPE_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr (139)
#endif

/* ns4__OperationStep * has binding name 'PointerTons4__OperationStep' for type 'ns4:OperationStep' */
#ifndef SOAP_TYPE_PointerTons4__OperationStep
#define SOAP_TYPE_PointerTons4__OperationStep (137)
#endif

/* enum ns4__OperationTypes * has binding name 'PointerTons4__OperationTypes' for type 'ns4:OperationTypes' */
#ifndef SOAP_TYPE_PointerTons4__OperationTypes
#define SOAP_TYPE_PointerTons4__OperationTypes (136)
#endif

/* ns4__ArrayOfOperationStep * has binding name 'PointerTons4__ArrayOfOperationStep' for type 'ns4:ArrayOfOperationStep' */
#ifndef SOAP_TYPE_PointerTons4__ArrayOfOperationStep
#define SOAP_TYPE_PointerTons4__ArrayOfOperationStep (135)
#endif

/* ns4__Operation * has binding name 'PointerTons4__Operation' for type 'ns4:Operation' */
#ifndef SOAP_TYPE_PointerTons4__Operation
#define SOAP_TYPE_PointerTons4__Operation (133)
#endif

/* std::string * has binding name 'PointerToxsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_PointerToxsd__decimal
#define SOAP_TYPE_PointerToxsd__decimal (132)
#endif

/* ns4__MeasuringComponent * has binding name 'PointerTons4__MeasuringComponent' for type 'ns4:MeasuringComponent' */
#ifndef SOAP_TYPE_PointerTons4__MeasuringComponent
#define SOAP_TYPE_PointerTons4__MeasuringComponent (130)
#endif

/* unsigned char * has binding name 'PointerToxsd__unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerToxsd__unsignedByte
#define SOAP_TYPE_PointerToxsd__unsignedByte (129)
#endif

/* enum ns4__ControlledParametr_x002eControlActionType * has binding name 'PointerTons4__ControlledParametr_x002eControlActionType' for type 'ns4:ControlledParametr.ControlActionType' */
#ifndef SOAP_TYPE_PointerTons4__ControlledParametr_x002eControlActionType
#define SOAP_TYPE_PointerTons4__ControlledParametr_x002eControlActionType (128)
#endif

/* ns4__ControlledParametr * has binding name 'PointerTons4__ControlledParametr' for type 'ns4:ControlledParametr' */
#ifndef SOAP_TYPE_PointerTons4__ControlledParametr
#define SOAP_TYPE_PointerTons4__ControlledParametr (126)
#endif

/* ns4__Periodicity_x002eTime * has binding name 'PointerTons4__Periodicity_x002eTime' for type 'ns4:Periodicity.Time' */
#ifndef SOAP_TYPE_PointerTons4__Periodicity_x002eTime
#define SOAP_TYPE_PointerTons4__Periodicity_x002eTime (124)
#endif

/* ns4__ArrayOfPeriodicity_x002eTime * has binding name 'PointerTons4__ArrayOfPeriodicity_x002eTime' for type 'ns4:ArrayOfPeriodicity.Time' */
#ifndef SOAP_TYPE_PointerTons4__ArrayOfPeriodicity_x002eTime
#define SOAP_TYPE_PointerTons4__ArrayOfPeriodicity_x002eTime (123)
#endif

/* arr__ArrayOfboolean * has binding name 'PointerToarr__ArrayOfboolean' for type 'arr:ArrayOfboolean' */
#ifndef SOAP_TYPE_PointerToarr__ArrayOfboolean
#define SOAP_TYPE_PointerToarr__ArrayOfboolean (122)
#endif

/* ns4__Periodicity * has binding name 'PointerTons4__Periodicity' for type 'ns4:Periodicity' */
#ifndef SOAP_TYPE_PointerTons4__Periodicity
#define SOAP_TYPE_PointerTons4__Periodicity (121)
#endif

/* ns4__AutoPlanItem * has binding name 'PointerTons4__AutoPlanItem' for type 'ns4:AutoPlanItem' */
#ifndef SOAP_TYPE_PointerTons4__AutoPlanItem
#define SOAP_TYPE_PointerTons4__AutoPlanItem (119)
#endif

/* enum ns4__OperationStepTypes * has binding name 'PointerTons4__OperationStepTypes' for type 'ns4:OperationStepTypes' */
#ifndef SOAP_TYPE_PointerTons4__OperationStepTypes
#define SOAP_TYPE_PointerTons4__OperationStepTypes (118)
#endif

/* enum ns3__OperationProcInfo_x002eOperationStepInfoStates * has binding name 'PointerTons3__OperationProcInfo_x002eOperationStepInfoStates' for type 'ns3:OperationProcInfo.OperationStepInfoStates' */
#ifndef SOAP_TYPE_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates
#define SOAP_TYPE_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates (117)
#endif

/* double * has binding name 'PointerTodouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_PointerTodouble
#define SOAP_TYPE_PointerTodouble (116)
#endif

/* ns3__OperationProcInfo_x002eOperationStepInfo * has binding name 'PointerTons3__OperationProcInfo_x002eOperationStepInfo' for type 'ns3:OperationProcInfo.OperationStepInfo' */
#ifndef SOAP_TYPE_PointerTons3__OperationProcInfo_x002eOperationStepInfo
#define SOAP_TYPE_PointerTons3__OperationProcInfo_x002eOperationStepInfo (113)
#endif

/* ns3__OperationProcInfo_x002eControlParamInfo * has binding name 'PointerTons3__OperationProcInfo_x002eControlParamInfo' for type 'ns3:OperationProcInfo.ControlParamInfo' */
#ifndef SOAP_TYPE_PointerTons3__OperationProcInfo_x002eControlParamInfo
#define SOAP_TYPE_PointerTons3__OperationProcInfo_x002eControlParamInfo (111)
#endif

/* arr__ArrayOfstring * has binding name 'PointerToarr__ArrayOfstring' for type 'arr:ArrayOfstring' */
#ifndef SOAP_TYPE_PointerToarr__ArrayOfstring
#define SOAP_TYPE_PointerToarr__ArrayOfstring (110)
#endif

/* ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo * has binding name 'PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo' for type 'ns3:ArrayOfOperationProcInfo.OperationStepInfo' */
#ifndef SOAP_TYPE_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo
#define SOAP_TYPE_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo (109)
#endif

/* ns3__ArrayOfOperationProcInfo_x002eControlParamInfo * has binding name 'PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo' for type 'ns3:ArrayOfOperationProcInfo.ControlParamInfo' */
#ifndef SOAP_TYPE_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo
#define SOAP_TYPE_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo (108)
#endif

/* enum ns3__ProcessingModes * has binding name 'PointerTons3__ProcessingModes' for type 'ns3:ProcessingModes' */
#ifndef SOAP_TYPE_PointerTons3__ProcessingModes
#define SOAP_TYPE_PointerTons3__ProcessingModes (107)
#endif

/* ns3__OperationProcInfo * has binding name 'PointerTons3__OperationProcInfo' for type 'ns3:OperationProcInfo' */
#ifndef SOAP_TYPE_PointerTons3__OperationProcInfo
#define SOAP_TYPE_PointerTons3__OperationProcInfo (106)
#endif

/* ns10__ArrayOfEEvent * has binding name 'PointerTons10__ArrayOfEEvent' for type 'ns10:ArrayOfEEvent' */
#ifndef SOAP_TYPE_PointerTons10__ArrayOfEEvent
#define SOAP_TYPE_PointerTons10__ArrayOfEEvent (105)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (104)
#endif

/* ns10__ESample * has binding name 'PointerTons10__ESample' for type 'ns10:ESample' */
#ifndef SOAP_TYPE_PointerTons10__ESample
#define SOAP_TYPE_PointerTons10__ESample (103)
#endif

/* ns10__ArrayOfESample * has binding name 'PointerTons10__ArrayOfESample' for type 'ns10:ArrayOfESample' */
#ifndef SOAP_TYPE_PointerTons10__ArrayOfESample
#define SOAP_TYPE_PointerTons10__ArrayOfESample (102)
#endif

/* enum ns10__ESampleTypes * has binding name 'PointerTons10__ESampleTypes' for type 'ns10:ESampleTypes' */
#ifndef SOAP_TYPE_PointerTons10__ESampleTypes
#define SOAP_TYPE_PointerTons10__ESampleTypes (101)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (100)
#endif

/* ns5__SystemConfigurations * has binding name 'PointerTons5__SystemConfigurations' for type 'ns5:SystemConfigurations' */
#ifndef SOAP_TYPE_PointerTons5__SystemConfigurations
#define SOAP_TYPE_PointerTons5__SystemConfigurations (98)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (97)
#endif

/* ns3__ProcessingInfo * has binding name 'PointerTons3__ProcessingInfo' for type 'ns3:ProcessingInfo' */
#ifndef SOAP_TYPE_PointerTons3__ProcessingInfo
#define SOAP_TYPE_PointerTons3__ProcessingInfo (95)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (94)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns10__EEvent *>  has binding name 'std__vectorTemplateOfPointerTons10__EEvent' for type 'ns10:EEvent' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons10__EEvent
#define SOAP_TYPE_std__vectorTemplateOfPointerTons10__EEvent (167)
#endif

/* std::vector<ns10__EResult *>  has binding name 'std__vectorTemplateOfPointerTons10__EResult' for type 'ns10:EResult' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons10__EResult
#define SOAP_TYPE_std__vectorTemplateOfPointerTons10__EResult (163)
#endif

/* std::vector<ns10__ESample *>  has binding name 'std__vectorTemplateOfPointerTons10__ESample' for type 'ns10:ESample' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons10__ESample
#define SOAP_TYPE_std__vectorTemplateOfPointerTons10__ESample (160)
#endif

/* std::vector<ns7__AuxDeviceState *>  has binding name 'std__vectorTemplateOfPointerTons7__AuxDeviceState' for type 'ns7:AuxDeviceState' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons7__AuxDeviceState
#define SOAP_TYPE_std__vectorTemplateOfPointerTons7__AuxDeviceState (159)
#endif

/* std::vector<ns7__AuxDevice *>  has binding name 'std__vectorTemplateOfPointerTons7__AuxDevice' for type 'ns7:AuxDevice' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons7__AuxDevice
#define SOAP_TYPE_std__vectorTemplateOfPointerTons7__AuxDevice (156)
#endif

/* std::vector<bool>  has binding name 'std__vectorTemplateOfbool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_std__vectorTemplateOfbool
#define SOAP_TYPE_std__vectorTemplateOfbool (146)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (145)
#endif

/* std::vector<ns4__OperationStep_x002eUsingControlledParametr *>  has binding name 'std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr' for type 'ns4:OperationStep.UsingControlledParametr' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr
#define SOAP_TYPE_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr (144)
#endif

/* std::vector<ns4__OperationStep *>  has binding name 'std__vectorTemplateOfPointerTons4__OperationStep' for type 'ns4:OperationStep' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons4__OperationStep
#define SOAP_TYPE_std__vectorTemplateOfPointerTons4__OperationStep (138)
#endif

/* std::vector<ns4__Operation *>  has binding name 'std__vectorTemplateOfPointerTons4__Operation' for type 'ns4:Operation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons4__Operation
#define SOAP_TYPE_std__vectorTemplateOfPointerTons4__Operation (134)
#endif

/* std::vector<ns4__MeasuringComponent *>  has binding name 'std__vectorTemplateOfPointerTons4__MeasuringComponent' for type 'ns4:MeasuringComponent' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons4__MeasuringComponent
#define SOAP_TYPE_std__vectorTemplateOfPointerTons4__MeasuringComponent (131)
#endif

/* std::vector<ns4__ControlledParametr *>  has binding name 'std__vectorTemplateOfPointerTons4__ControlledParametr' for type 'ns4:ControlledParametr' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons4__ControlledParametr
#define SOAP_TYPE_std__vectorTemplateOfPointerTons4__ControlledParametr (127)
#endif

/* std::vector<ns4__Periodicity_x002eTime *>  has binding name 'std__vectorTemplateOfPointerTons4__Periodicity_x002eTime' for type 'ns4:Periodicity.Time' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime
#define SOAP_TYPE_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime (125)
#endif

/* std::vector<ns4__AutoPlanItem *>  has binding name 'std__vectorTemplateOfPointerTons4__AutoPlanItem' for type 'ns4:AutoPlanItem' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons4__AutoPlanItem
#define SOAP_TYPE_std__vectorTemplateOfPointerTons4__AutoPlanItem (120)
#endif

/* std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *>  has binding name 'std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo' for type 'ns3:OperationProcInfo.OperationStepInfo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo (114)
#endif

/* std::vector<ns3__OperationProcInfo_x002eControlParamInfo *>  has binding name 'std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo' for type 'ns3:OperationProcInfo.ControlParamInfo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo (112)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
