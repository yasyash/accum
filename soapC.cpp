/* soapC.cpp
   Generated by gSOAP 2.8.75 for liga.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.75 2020-01-12 20:19:15 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, tag, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, tag, NULL, "xsd:double");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_in_xsd__unsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_ULONG64:
		return soap_in_ULONG64(soap, tag, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_in__wsa5__IsReferenceParameter(soap, tag, NULL, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_in_wsa5__FaultCodesType(soap, tag, NULL, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_in_wsa5__RelationshipType(soap, tag, NULL, "wsa5:RelationshipType");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_ns10__EEventTypes:
		return soap_in_ns10__EEventTypes(soap, tag, NULL, "ns10:EEventTypes");
	case SOAP_TYPE_ns10__EResultValueStatus:
		return soap_in_ns10__EResultValueStatus(soap, tag, NULL, "ns10:EResultValueStatus");
	case SOAP_TYPE_ns10__EResultStatus:
		return soap_in_ns10__EResultStatus(soap, tag, NULL, "ns10:EResultStatus");
	case SOAP_TYPE_ns10__ESampleTypes:
		return soap_in_ns10__ESampleTypes(soap, tag, NULL, "ns10:ESampleTypes");
	case SOAP_TYPE_ns9__ChromatographMode:
		return soap_in_ns9__ChromatographMode(soap, tag, NULL, "ns9:ChromatographMode");
	case SOAP_TYPE_ns8__Logger_x002eLogLevel:
		return soap_in_ns8__Logger_x002eLogLevel(soap, tag, NULL, "ns8:Logger.LogLevel");
	case SOAP_TYPE_ns4__OperationTypes:
		return soap_in_ns4__OperationTypes(soap, tag, NULL, "ns4:OperationTypes");
	case SOAP_TYPE_ns4__ControlledParametr_x002eControlActionType:
		return soap_in_ns4__ControlledParametr_x002eControlActionType(soap, tag, NULL, "ns4:ControlledParametr.ControlActionType");
	case SOAP_TYPE_ns4__OperationStepTypes:
		return soap_in_ns4__OperationStepTypes(soap, tag, NULL, "ns4:OperationStepTypes");
	case SOAP_TYPE_ns3__ProcessingModes:
		return soap_in_ns3__ProcessingModes(soap, tag, NULL, "ns3:ProcessingModes");
	case SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfoStates:
		return soap_in_ns3__OperationProcInfo_x002eOperationStepInfoStates(soap, tag, NULL, "ns3:OperationProcInfo.OperationStepInfoStates");
	case SOAP_TYPE_ns10__EEvent:
		return soap_in_ns10__EEvent(soap, tag, NULL, "ns10:EEvent");
	case SOAP_TYPE_ns10__ArrayOfEEvent:
		return soap_in_ns10__ArrayOfEEvent(soap, tag, NULL, "ns10:ArrayOfEEvent");
	case SOAP_TYPE_ns10__EResult:
		return soap_in_ns10__EResult(soap, tag, NULL, "ns10:EResult");
	case SOAP_TYPE_ns10__ArrayOfEResult:
		return soap_in_ns10__ArrayOfEResult(soap, tag, NULL, "ns10:ArrayOfEResult");
	case SOAP_TYPE_ns10__ESample:
		return soap_in_ns10__ESample(soap, tag, NULL, "ns10:ESample");
	case SOAP_TYPE_ns10__ArrayOfESample:
		return soap_in_ns10__ArrayOfESample(soap, tag, NULL, "ns10:ArrayOfESample");
	case SOAP_TYPE_ns7__AuxDeviceState:
		return soap_in_ns7__AuxDeviceState(soap, tag, NULL, "ns7:AuxDeviceState");
	case SOAP_TYPE_ns7__ArrayOfAuxDeviceState:
		return soap_in_ns7__ArrayOfAuxDeviceState(soap, tag, NULL, "ns7:ArrayOfAuxDeviceState");
	case SOAP_TYPE_ns7__AuxDevice:
		return soap_in_ns7__AuxDevice(soap, tag, NULL, "ns7:AuxDevice");
	case SOAP_TYPE_ns7__ArrayOfAuxDevice:
		return soap_in_ns7__ArrayOfAuxDevice(soap, tag, NULL, "ns7:ArrayOfAuxDevice");
	case SOAP_TYPE_ns7__AuxControllerConfiguration:
		return soap_in_ns7__AuxControllerConfiguration(soap, tag, NULL, "ns7:AuxControllerConfiguration");
	case SOAP_TYPE_ns6__Aux2Config:
		return soap_in_ns6__Aux2Config(soap, tag, NULL, "ns6:Aux2Config");
	case SOAP_TYPE_ns5__SystemConfigurations:
		return soap_in_ns5__SystemConfigurations(soap, tag, NULL, "ns5:SystemConfigurations");
	case SOAP_TYPE_arr__ArrayOfboolean:
		return soap_in_arr__ArrayOfboolean(soap, tag, NULL, "arr:ArrayOfboolean");
	case SOAP_TYPE_arr__ArrayOfstring:
		return soap_in_arr__ArrayOfstring(soap, tag, NULL, "arr:ArrayOfstring");
	case SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr:
		return soap_in_ns4__OperationStep_x002eUsingControlledParametr(soap, tag, NULL, "ns4:OperationStep.UsingControlledParametr");
	case SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr:
		return soap_in_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, tag, NULL, "ns4:ArrayOfOperationStep.UsingControlledParametr");
	case SOAP_TYPE_ns4__OperationStep:
		return soap_in_ns4__OperationStep(soap, tag, NULL, "ns4:OperationStep");
	case SOAP_TYPE_ns4__ArrayOfOperationStep:
		return soap_in_ns4__ArrayOfOperationStep(soap, tag, NULL, "ns4:ArrayOfOperationStep");
	case SOAP_TYPE_ns4__Operation:
		return soap_in_ns4__Operation(soap, tag, NULL, "ns4:Operation");
	case SOAP_TYPE_ns4__ArrayOfOperation:
		return soap_in_ns4__ArrayOfOperation(soap, tag, NULL, "ns4:ArrayOfOperation");
	case SOAP_TYPE_ns4__MeasuringComponent:
		return soap_in_ns4__MeasuringComponent(soap, tag, NULL, "ns4:MeasuringComponent");
	case SOAP_TYPE_ns4__ArrayOfMeasuringComponent:
		return soap_in_ns4__ArrayOfMeasuringComponent(soap, tag, NULL, "ns4:ArrayOfMeasuringComponent");
	case SOAP_TYPE_ns4__ControlledParametr:
		return soap_in_ns4__ControlledParametr(soap, tag, NULL, "ns4:ControlledParametr");
	case SOAP_TYPE_ns4__ArrayOfControlledParametr:
		return soap_in_ns4__ArrayOfControlledParametr(soap, tag, NULL, "ns4:ArrayOfControlledParametr");
	case SOAP_TYPE_ns4__Periodicity_x002eTime:
		return soap_in_ns4__Periodicity_x002eTime(soap, tag, NULL, "ns4:Periodicity.Time");
	case SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime:
		return soap_in_ns4__ArrayOfPeriodicity_x002eTime(soap, tag, NULL, "ns4:ArrayOfPeriodicity.Time");
	case SOAP_TYPE_ns4__Periodicity:
		return soap_in_ns4__Periodicity(soap, tag, NULL, "ns4:Periodicity");
	case SOAP_TYPE_ns4__AutoPlanItem:
		return soap_in_ns4__AutoPlanItem(soap, tag, NULL, "ns4:AutoPlanItem");
	case SOAP_TYPE_ns4__ArrayOfAutoPlanItem:
		return soap_in_ns4__ArrayOfAutoPlanItem(soap, tag, NULL, "ns4:ArrayOfAutoPlanItem");
	case SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo:
		return soap_in_ns3__OperationProcInfo_x002eOperationStepInfo(soap, tag, NULL, "ns3:OperationProcInfo.OperationStepInfo");
	case SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo:
		return soap_in_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, tag, NULL, "ns3:ArrayOfOperationProcInfo.OperationStepInfo");
	case SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo:
		return soap_in_ns3__OperationProcInfo_x002eControlParamInfo(soap, tag, NULL, "ns3:OperationProcInfo.ControlParamInfo");
	case SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo:
		return soap_in_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, tag, NULL, "ns3:ArrayOfOperationProcInfo.ControlParamInfo");
	case SOAP_TYPE_ns3__OperationProcInfo:
		return soap_in_ns3__OperationProcInfo(soap, tag, NULL, "ns3:OperationProcInfo");
	case SOAP_TYPE_ns3__ProcessingInfo:
		return soap_in_ns3__ProcessingInfo(soap, tag, NULL, "ns3:ProcessingInfo");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, tag, NULL, "xsd:decimal");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_in_chan__ChannelInstanceType(soap, tag, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_in_wsa5__ProblemActionType(soap, tag, NULL, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_in_wsa5__RelatesToType(soap, tag, NULL, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_in_wsa5__MetadataType(soap, tag, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_in_wsa5__ReferenceParametersType(soap, tag, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_in_wsa5__EndpointReferenceType(soap, tag, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_in_PointerTochan__ChannelInstanceType(soap, tag, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_in_PointerTo_wsa5__FaultTo(soap, tag, NULL, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_in_PointerTo_wsa5__ReplyTo(soap, tag, NULL, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_in_PointerTo_wsa5__From(soap, tag, NULL, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_in_PointerTo_wsa5__RelatesTo(soap, tag, NULL, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
	{	char **s;
		s = soap_in__wsa5__ProblemHeaderQName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_in_PointerTowsa5__MetadataType(soap, tag, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
	{	char **s;
		s = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, NULL, "wsa5:FaultCodesOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
	{	char **s;
		s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, NULL, "wsa5:RelationshipTypeOpenEnum");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTo_ns2__GetEventsSinceId:
		return soap_in_PointerTo_ns2__GetEventsSinceId(soap, tag, NULL, "ns2:GetEventsSinceId");
	case SOAP_TYPE_PointerTo_ns2__GetLastEventId:
		return soap_in_PointerTo_ns2__GetLastEventId(soap, tag, NULL, "ns2:GetLastEventId");
	case SOAP_TYPE_PointerTo_ns2__GetEvents:
		return soap_in_PointerTo_ns2__GetEvents(soap, tag, NULL, "ns2:GetEvents");
	case SOAP_TYPE_PointerTo_ns2__GetResultsSinceId:
		return soap_in_PointerTo_ns2__GetResultsSinceId(soap, tag, NULL, "ns2:GetResultsSinceId");
	case SOAP_TYPE_PointerTo_ns2__GetLastResultId:
		return soap_in_PointerTo_ns2__GetLastResultId(soap, tag, NULL, "ns2:GetLastResultId");
	case SOAP_TYPE_PointerTo_ns2__GetLastResult:
		return soap_in_PointerTo_ns2__GetLastResult(soap, tag, NULL, "ns2:GetLastResult");
	case SOAP_TYPE_PointerTo_ns2__GetResults:
		return soap_in_PointerTo_ns2__GetResults(soap, tag, NULL, "ns2:GetResults");
	case SOAP_TYPE_PointerTo_ns2__SetSystemConfigurations:
		return soap_in_PointerTo_ns2__SetSystemConfigurations(soap, tag, NULL, "ns2:SetSystemConfigurations");
	case SOAP_TYPE_PointerTo_ns2__GetSystemConfigurations:
		return soap_in_PointerTo_ns2__GetSystemConfigurations(soap, tag, NULL, "ns2:GetSystemConfigurations");
	case SOAP_TYPE_PointerTo_ns2__SetIgnoreClearing:
		return soap_in_PointerTo_ns2__SetIgnoreClearing(soap, tag, NULL, "ns2:SetIgnoreClearing");
	case SOAP_TYPE_PointerTo_ns2__GetProcessingInfo:
		return soap_in_PointerTo_ns2__GetProcessingInfo(soap, tag, NULL, "ns2:GetProcessingInfo");
	case SOAP_TYPE_PointerTo_ns2__AbortAnalyzing:
		return soap_in_PointerTo_ns2__AbortAnalyzing(soap, tag, NULL, "ns2:AbortAnalyzing");
	case SOAP_TYPE_PointerTo_ns2__StopAnalyzing:
		return soap_in_PointerTo_ns2__StopAnalyzing(soap, tag, NULL, "ns2:StopAnalyzing");
	case SOAP_TYPE_PointerTo_ns2__StartOperation:
		return soap_in_PointerTo_ns2__StartOperation(soap, tag, NULL, "ns2:StartOperation");
	case SOAP_TYPE_PointerTo_ns2__StartAutoPlan:
		return soap_in_PointerTo_ns2__StartAutoPlan(soap, tag, NULL, "ns2:StartAutoPlan");
	case SOAP_TYPE_PointerTons10__EEventTypes:
		return soap_in_PointerTons10__EEventTypes(soap, tag, NULL, "ns10:EEventTypes");
	case SOAP_TYPE_PointerTons10__EEvent:
		return soap_in_PointerTons10__EEvent(soap, tag, NULL, "ns10:EEvent");
	case SOAP_TYPE_PointerTons10__EResultValueStatus:
		return soap_in_PointerTons10__EResultValueStatus(soap, tag, NULL, "ns10:EResultValueStatus");
	case SOAP_TYPE_PointerTons10__EResultStatus:
		return soap_in_PointerTons10__EResultStatus(soap, tag, NULL, "ns10:EResultStatus");
	case SOAP_TYPE_PointerTons10__EResult:
		return soap_in_PointerTons10__EResult(soap, tag, NULL, "ns10:EResult");
	case SOAP_TYPE_PointerTons10__ArrayOfEResult:
		return soap_in_PointerTons10__ArrayOfEResult(soap, tag, NULL, "ns10:ArrayOfEResult");
	case SOAP_TYPE_PointerTons7__AuxDeviceState:
		return soap_in_PointerTons7__AuxDeviceState(soap, tag, NULL, "ns7:AuxDeviceState");
	case SOAP_TYPE_PointerTons7__ArrayOfAuxDeviceState:
		return soap_in_PointerTons7__ArrayOfAuxDeviceState(soap, tag, NULL, "ns7:ArrayOfAuxDeviceState");
	case SOAP_TYPE_PointerTons7__AuxDevice:
		return soap_in_PointerTons7__AuxDevice(soap, tag, NULL, "ns7:AuxDevice");
	case SOAP_TYPE_PointerTons7__ArrayOfAuxDevice:
		return soap_in_PointerTons7__ArrayOfAuxDevice(soap, tag, NULL, "ns7:ArrayOfAuxDevice");
	case SOAP_TYPE_PointerTons4__ArrayOfOperation:
		return soap_in_PointerTons4__ArrayOfOperation(soap, tag, NULL, "ns4:ArrayOfOperation");
	case SOAP_TYPE_PointerTons4__ArrayOfMeasuringComponent:
		return soap_in_PointerTons4__ArrayOfMeasuringComponent(soap, tag, NULL, "ns4:ArrayOfMeasuringComponent");
	case SOAP_TYPE_PointerTons4__ArrayOfControlledParametr:
		return soap_in_PointerTons4__ArrayOfControlledParametr(soap, tag, NULL, "ns4:ArrayOfControlledParametr");
	case SOAP_TYPE_PointerTons8__Logger_x002eLogLevel:
		return soap_in_PointerTons8__Logger_x002eLogLevel(soap, tag, NULL, "ns8:Logger.LogLevel");
	case SOAP_TYPE_PointerTons7__AuxControllerConfiguration:
		return soap_in_PointerTons7__AuxControllerConfiguration(soap, tag, NULL, "ns7:AuxControllerConfiguration");
	case SOAP_TYPE_PointerTons6__Aux2Config:
		return soap_in_PointerTons6__Aux2Config(soap, tag, NULL, "ns6:Aux2Config");
	case SOAP_TYPE_PointerTons4__ArrayOfAutoPlanItem:
		return soap_in_PointerTons4__ArrayOfAutoPlanItem(soap, tag, NULL, "ns4:ArrayOfAutoPlanItem");
	case SOAP_TYPE_PointerTons4__OperationStep_x002eUsingControlledParametr:
		return soap_in_PointerTons4__OperationStep_x002eUsingControlledParametr(soap, tag, NULL, "ns4:OperationStep.UsingControlledParametr");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, tag, NULL, "xsd:long");
	case SOAP_TYPE_PointerTons9__ChromatographMode:
		return soap_in_PointerTons9__ChromatographMode(soap, tag, NULL, "ns9:ChromatographMode");
	case SOAP_TYPE_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr:
		return soap_in_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, tag, NULL, "ns4:ArrayOfOperationStep.UsingControlledParametr");
	case SOAP_TYPE_PointerTons4__OperationStep:
		return soap_in_PointerTons4__OperationStep(soap, tag, NULL, "ns4:OperationStep");
	case SOAP_TYPE_PointerTons4__OperationTypes:
		return soap_in_PointerTons4__OperationTypes(soap, tag, NULL, "ns4:OperationTypes");
	case SOAP_TYPE_PointerTons4__ArrayOfOperationStep:
		return soap_in_PointerTons4__ArrayOfOperationStep(soap, tag, NULL, "ns4:ArrayOfOperationStep");
	case SOAP_TYPE_PointerTons4__Operation:
		return soap_in_PointerTons4__Operation(soap, tag, NULL, "ns4:Operation");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_in_PointerToxsd__decimal(soap, tag, NULL, "xsd:decimal");
	case SOAP_TYPE_PointerTons4__MeasuringComponent:
		return soap_in_PointerTons4__MeasuringComponent(soap, tag, NULL, "ns4:MeasuringComponent");
	case SOAP_TYPE_PointerToxsd__unsignedByte:
		return soap_in_PointerToxsd__unsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_PointerTons4__ControlledParametr_x002eControlActionType:
		return soap_in_PointerTons4__ControlledParametr_x002eControlActionType(soap, tag, NULL, "ns4:ControlledParametr.ControlActionType");
	case SOAP_TYPE_PointerTons4__ControlledParametr:
		return soap_in_PointerTons4__ControlledParametr(soap, tag, NULL, "ns4:ControlledParametr");
	case SOAP_TYPE_PointerTons4__Periodicity_x002eTime:
		return soap_in_PointerTons4__Periodicity_x002eTime(soap, tag, NULL, "ns4:Periodicity.Time");
	case SOAP_TYPE_PointerTons4__ArrayOfPeriodicity_x002eTime:
		return soap_in_PointerTons4__ArrayOfPeriodicity_x002eTime(soap, tag, NULL, "ns4:ArrayOfPeriodicity.Time");
	case SOAP_TYPE_PointerToarr__ArrayOfboolean:
		return soap_in_PointerToarr__ArrayOfboolean(soap, tag, NULL, "arr:ArrayOfboolean");
	case SOAP_TYPE_PointerTons4__Periodicity:
		return soap_in_PointerTons4__Periodicity(soap, tag, NULL, "ns4:Periodicity");
	case SOAP_TYPE_PointerTons4__AutoPlanItem:
		return soap_in_PointerTons4__AutoPlanItem(soap, tag, NULL, "ns4:AutoPlanItem");
	case SOAP_TYPE_PointerTons4__OperationStepTypes:
		return soap_in_PointerTons4__OperationStepTypes(soap, tag, NULL, "ns4:OperationStepTypes");
	case SOAP_TYPE_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates:
		return soap_in_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates(soap, tag, NULL, "ns3:OperationProcInfo.OperationStepInfoStates");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, tag, NULL, "xsd:double");
	case SOAP_TYPE_PointerTons3__OperationProcInfo_x002eOperationStepInfo:
		return soap_in_PointerTons3__OperationProcInfo_x002eOperationStepInfo(soap, tag, NULL, "ns3:OperationProcInfo.OperationStepInfo");
	case SOAP_TYPE_PointerTons3__OperationProcInfo_x002eControlParamInfo:
		return soap_in_PointerTons3__OperationProcInfo_x002eControlParamInfo(soap, tag, NULL, "ns3:OperationProcInfo.ControlParamInfo");
	case SOAP_TYPE_PointerToarr__ArrayOfstring:
		return soap_in_PointerToarr__ArrayOfstring(soap, tag, NULL, "arr:ArrayOfstring");
	case SOAP_TYPE_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo:
		return soap_in_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, tag, NULL, "ns3:ArrayOfOperationProcInfo.OperationStepInfo");
	case SOAP_TYPE_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo:
		return soap_in_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, tag, NULL, "ns3:ArrayOfOperationProcInfo.ControlParamInfo");
	case SOAP_TYPE_PointerTons3__ProcessingModes:
		return soap_in_PointerTons3__ProcessingModes(soap, tag, NULL, "ns3:ProcessingModes");
	case SOAP_TYPE_PointerTons3__OperationProcInfo:
		return soap_in_PointerTons3__OperationProcInfo(soap, tag, NULL, "ns3:OperationProcInfo");
	case SOAP_TYPE_PointerTons10__ArrayOfEEvent:
		return soap_in_PointerTons10__ArrayOfEEvent(soap, tag, NULL, "ns10:ArrayOfEEvent");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_PointerTons10__ESample:
		return soap_in_PointerTons10__ESample(soap, tag, NULL, "ns10:ESample");
	case SOAP_TYPE_PointerTons10__ArrayOfESample:
		return soap_in_PointerTons10__ArrayOfESample(soap, tag, NULL, "ns10:ArrayOfESample");
	case SOAP_TYPE_PointerTons10__ESampleTypes:
		return soap_in_PointerTons10__ESampleTypes(soap, tag, NULL, "ns10:ESampleTypes");
	case SOAP_TYPE_PointerTodateTime:
		return soap_in_PointerTodateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons5__SystemConfigurations:
		return soap_in_PointerTons5__SystemConfigurations(soap, tag, NULL, "ns5:SystemConfigurations");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons3__ProcessingInfo:
		return soap_in_PointerTons3__ProcessingInfo(soap, tag, NULL, "ns3:ProcessingInfo");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns10:EEvent"))
		{	*type = SOAP_TYPE_ns10__EEvent;
			return soap_in_ns10__EEvent(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:ArrayOfEEvent"))
		{	*type = SOAP_TYPE_ns10__ArrayOfEEvent;
			return soap_in_ns10__ArrayOfEEvent(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:EResult"))
		{	*type = SOAP_TYPE_ns10__EResult;
			return soap_in_ns10__EResult(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:ArrayOfEResult"))
		{	*type = SOAP_TYPE_ns10__ArrayOfEResult;
			return soap_in_ns10__ArrayOfEResult(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:ESample"))
		{	*type = SOAP_TYPE_ns10__ESample;
			return soap_in_ns10__ESample(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:ArrayOfESample"))
		{	*type = SOAP_TYPE_ns10__ArrayOfESample;
			return soap_in_ns10__ArrayOfESample(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:AuxDeviceState"))
		{	*type = SOAP_TYPE_ns7__AuxDeviceState;
			return soap_in_ns7__AuxDeviceState(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ArrayOfAuxDeviceState"))
		{	*type = SOAP_TYPE_ns7__ArrayOfAuxDeviceState;
			return soap_in_ns7__ArrayOfAuxDeviceState(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:AuxDevice"))
		{	*type = SOAP_TYPE_ns7__AuxDevice;
			return soap_in_ns7__AuxDevice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ArrayOfAuxDevice"))
		{	*type = SOAP_TYPE_ns7__ArrayOfAuxDevice;
			return soap_in_ns7__ArrayOfAuxDevice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:AuxControllerConfiguration"))
		{	*type = SOAP_TYPE_ns7__AuxControllerConfiguration;
			return soap_in_ns7__AuxControllerConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:Aux2Config"))
		{	*type = SOAP_TYPE_ns6__Aux2Config;
			return soap_in_ns6__Aux2Config(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SystemConfigurations"))
		{	*type = SOAP_TYPE_ns5__SystemConfigurations;
			return soap_in_ns5__SystemConfigurations(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "arr:ArrayOfboolean"))
		{	*type = SOAP_TYPE_arr__ArrayOfboolean;
			return soap_in_arr__ArrayOfboolean(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "arr:ArrayOfstring"))
		{	*type = SOAP_TYPE_arr__ArrayOfstring;
			return soap_in_arr__ArrayOfstring(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:OperationStep.UsingControlledParametr"))
		{	*type = SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr;
			return soap_in_ns4__OperationStep_x002eUsingControlledParametr(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfOperationStep.UsingControlledParametr"))
		{	*type = SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr;
			return soap_in_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:OperationStep"))
		{	*type = SOAP_TYPE_ns4__OperationStep;
			return soap_in_ns4__OperationStep(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfOperationStep"))
		{	*type = SOAP_TYPE_ns4__ArrayOfOperationStep;
			return soap_in_ns4__ArrayOfOperationStep(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Operation"))
		{	*type = SOAP_TYPE_ns4__Operation;
			return soap_in_ns4__Operation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfOperation"))
		{	*type = SOAP_TYPE_ns4__ArrayOfOperation;
			return soap_in_ns4__ArrayOfOperation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:MeasuringComponent"))
		{	*type = SOAP_TYPE_ns4__MeasuringComponent;
			return soap_in_ns4__MeasuringComponent(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfMeasuringComponent"))
		{	*type = SOAP_TYPE_ns4__ArrayOfMeasuringComponent;
			return soap_in_ns4__ArrayOfMeasuringComponent(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ControlledParametr"))
		{	*type = SOAP_TYPE_ns4__ControlledParametr;
			return soap_in_ns4__ControlledParametr(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfControlledParametr"))
		{	*type = SOAP_TYPE_ns4__ArrayOfControlledParametr;
			return soap_in_ns4__ArrayOfControlledParametr(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Periodicity.Time"))
		{	*type = SOAP_TYPE_ns4__Periodicity_x002eTime;
			return soap_in_ns4__Periodicity_x002eTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfPeriodicity.Time"))
		{	*type = SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime;
			return soap_in_ns4__ArrayOfPeriodicity_x002eTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Periodicity"))
		{	*type = SOAP_TYPE_ns4__Periodicity;
			return soap_in_ns4__Periodicity(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:AutoPlanItem"))
		{	*type = SOAP_TYPE_ns4__AutoPlanItem;
			return soap_in_ns4__AutoPlanItem(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfAutoPlanItem"))
		{	*type = SOAP_TYPE_ns4__ArrayOfAutoPlanItem;
			return soap_in_ns4__ArrayOfAutoPlanItem(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:OperationProcInfo.OperationStepInfo"))
		{	*type = SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo;
			return soap_in_ns3__OperationProcInfo_x002eOperationStepInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfOperationProcInfo.OperationStepInfo"))
		{	*type = SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo;
			return soap_in_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:OperationProcInfo.ControlParamInfo"))
		{	*type = SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo;
			return soap_in_ns3__OperationProcInfo_x002eControlParamInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfOperationProcInfo.ControlParamInfo"))
		{	*type = SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo;
			return soap_in_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:OperationProcInfo"))
		{	*type = SOAP_TYPE_ns3__OperationProcInfo;
			return soap_in_ns3__OperationProcInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ProcessingInfo"))
		{	*type = SOAP_TYPE_ns3__ProcessingInfo;
			return soap_in_ns3__ProcessingInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_xsd__unsignedByte;
			return soap_in_xsd__unsignedByte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_ULONG64;
			return soap_in_ULONG64(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:IsReferenceParameter"))
		{	*type = SOAP_TYPE__wsa5__IsReferenceParameter;
			return soap_in__wsa5__IsReferenceParameter(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesType"))
		{	*type = SOAP_TYPE_wsa5__FaultCodesType;
			return soap_in_wsa5__FaultCodesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipType"))
		{	*type = SOAP_TYPE_wsa5__RelationshipType;
			return soap_in_wsa5__RelationshipType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:EEventTypes"))
		{	*type = SOAP_TYPE_ns10__EEventTypes;
			return soap_in_ns10__EEventTypes(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:EResultValueStatus"))
		{	*type = SOAP_TYPE_ns10__EResultValueStatus;
			return soap_in_ns10__EResultValueStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:EResultStatus"))
		{	*type = SOAP_TYPE_ns10__EResultStatus;
			return soap_in_ns10__EResultStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:ESampleTypes"))
		{	*type = SOAP_TYPE_ns10__ESampleTypes;
			return soap_in_ns10__ESampleTypes(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns9:ChromatographMode"))
		{	*type = SOAP_TYPE_ns9__ChromatographMode;
			return soap_in_ns9__ChromatographMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns8:Logger.LogLevel"))
		{	*type = SOAP_TYPE_ns8__Logger_x002eLogLevel;
			return soap_in_ns8__Logger_x002eLogLevel(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:OperationTypes"))
		{	*type = SOAP_TYPE_ns4__OperationTypes;
			return soap_in_ns4__OperationTypes(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ControlledParametr.ControlActionType"))
		{	*type = SOAP_TYPE_ns4__ControlledParametr_x002eControlActionType;
			return soap_in_ns4__ControlledParametr_x002eControlActionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:OperationStepTypes"))
		{	*type = SOAP_TYPE_ns4__OperationStepTypes;
			return soap_in_ns4__OperationStepTypes(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ProcessingModes"))
		{	*type = SOAP_TYPE_ns3__ProcessingModes;
			return soap_in_ns3__ProcessingModes(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:OperationProcInfo.OperationStepInfoStates"))
		{	*type = SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfoStates;
			return soap_in_ns3__OperationProcInfo_x002eOperationStepInfoStates(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "chan:ChannelInstanceType"))
		{	*type = SOAP_TYPE_chan__ChannelInstanceType;
			return soap_in_chan__ChannelInstanceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemActionType"))
		{	*type = SOAP_TYPE_wsa5__ProblemActionType;
			return soap_in_wsa5__ProblemActionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesToType"))
		{	*type = SOAP_TYPE_wsa5__RelatesToType;
			return soap_in_wsa5__RelatesToType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:MetadataType"))
		{	*type = SOAP_TYPE_wsa5__MetadataType;
			return soap_in_wsa5__MetadataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa5__ReferenceParametersType;
			return soap_in_wsa5__ReferenceParametersType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa5__EndpointReferenceType;
			return soap_in_wsa5__EndpointReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemHeaderQName;
			s = soap_in__wsa5__ProblemHeaderQName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__FaultCodesOpenEnumType;
			s = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipTypeOpenEnum"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__RelationshipTypeOpenEnum;
			s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsa5:RetryAfter"))
		{	*type = SOAP_TYPE__wsa5__RetryAfter;
			return soap_in__wsa5__RetryAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetEventsSinceIdResponse"))
		{	*type = SOAP_TYPE__ns2__GetEventsSinceIdResponse;
			return soap_in__ns2__GetEventsSinceIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetEventsSinceId"))
		{	*type = SOAP_TYPE__ns2__GetEventsSinceId;
			return soap_in__ns2__GetEventsSinceId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetLastEventIdResponse"))
		{	*type = SOAP_TYPE__ns2__GetLastEventIdResponse;
			return soap_in__ns2__GetLastEventIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetLastEventId"))
		{	*type = SOAP_TYPE__ns2__GetLastEventId;
			return soap_in__ns2__GetLastEventId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetEventsResponse"))
		{	*type = SOAP_TYPE__ns2__GetEventsResponse;
			return soap_in__ns2__GetEventsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetEvents"))
		{	*type = SOAP_TYPE__ns2__GetEvents;
			return soap_in__ns2__GetEvents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetResultsSinceIdResponse"))
		{	*type = SOAP_TYPE__ns2__GetResultsSinceIdResponse;
			return soap_in__ns2__GetResultsSinceIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetResultsSinceId"))
		{	*type = SOAP_TYPE__ns2__GetResultsSinceId;
			return soap_in__ns2__GetResultsSinceId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetLastResultIdResponse"))
		{	*type = SOAP_TYPE__ns2__GetLastResultIdResponse;
			return soap_in__ns2__GetLastResultIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetLastResultId"))
		{	*type = SOAP_TYPE__ns2__GetLastResultId;
			return soap_in__ns2__GetLastResultId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetLastResultResponse"))
		{	*type = SOAP_TYPE__ns2__GetLastResultResponse;
			return soap_in__ns2__GetLastResultResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetLastResult"))
		{	*type = SOAP_TYPE__ns2__GetLastResult;
			return soap_in__ns2__GetLastResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetResultsResponse"))
		{	*type = SOAP_TYPE__ns2__GetResultsResponse;
			return soap_in__ns2__GetResultsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetResults"))
		{	*type = SOAP_TYPE__ns2__GetResults;
			return soap_in__ns2__GetResults(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SetSystemConfigurationsResponse"))
		{	*type = SOAP_TYPE__ns2__SetSystemConfigurationsResponse;
			return soap_in__ns2__SetSystemConfigurationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SetSystemConfigurations"))
		{	*type = SOAP_TYPE__ns2__SetSystemConfigurations;
			return soap_in__ns2__SetSystemConfigurations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetSystemConfigurationsResponse"))
		{	*type = SOAP_TYPE__ns2__GetSystemConfigurationsResponse;
			return soap_in__ns2__GetSystemConfigurationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetSystemConfigurations"))
		{	*type = SOAP_TYPE__ns2__GetSystemConfigurations;
			return soap_in__ns2__GetSystemConfigurations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SetIgnoreClearingResponse"))
		{	*type = SOAP_TYPE__ns2__SetIgnoreClearingResponse;
			return soap_in__ns2__SetIgnoreClearingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SetIgnoreClearing"))
		{	*type = SOAP_TYPE__ns2__SetIgnoreClearing;
			return soap_in__ns2__SetIgnoreClearing(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetProcessingInfoResponse"))
		{	*type = SOAP_TYPE__ns2__GetProcessingInfoResponse;
			return soap_in__ns2__GetProcessingInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetProcessingInfo"))
		{	*type = SOAP_TYPE__ns2__GetProcessingInfo;
			return soap_in__ns2__GetProcessingInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AbortAnalyzingResponse"))
		{	*type = SOAP_TYPE__ns2__AbortAnalyzingResponse;
			return soap_in__ns2__AbortAnalyzingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AbortAnalyzing"))
		{	*type = SOAP_TYPE__ns2__AbortAnalyzing;
			return soap_in__ns2__AbortAnalyzing(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StopAnalyzingResponse"))
		{	*type = SOAP_TYPE__ns2__StopAnalyzingResponse;
			return soap_in__ns2__StopAnalyzingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StopAnalyzing"))
		{	*type = SOAP_TYPE__ns2__StopAnalyzing;
			return soap_in__ns2__StopAnalyzing(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StartOperationResponse"))
		{	*type = SOAP_TYPE__ns2__StartOperationResponse;
			return soap_in__ns2__StartOperationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StartOperation"))
		{	*type = SOAP_TYPE__ns2__StartOperation;
			return soap_in__ns2__StartOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StartAutoPlanResponse"))
		{	*type = SOAP_TYPE__ns2__StartAutoPlanResponse;
			return soap_in__ns2__StartAutoPlanResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StartAutoPlan"))
		{	*type = SOAP_TYPE__ns2__StartAutoPlan;
			return soap_in__ns2__StartAutoPlan(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemAction"))
		{	*type = SOAP_TYPE__wsa5__ProblemAction;
			return soap_in__wsa5__ProblemAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultTo"))
		{	*type = SOAP_TYPE__wsa5__FaultTo;
			return soap_in__wsa5__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:From"))
		{	*type = SOAP_TYPE__wsa5__From;
			return soap_in__wsa5__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReplyTo"))
		{	*type = SOAP_TYPE__wsa5__ReplyTo;
			return soap_in__wsa5__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesTo"))
		{	*type = SOAP_TYPE__wsa5__RelatesTo;
			return soap_in__wsa5__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:Metadata"))
		{	*type = SOAP_TYPE__wsa5__Metadata;
			return soap_in__wsa5__Metadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParameters"))
		{	*type = SOAP_TYPE__wsa5__ReferenceParameters;
			return soap_in__wsa5__ReferenceParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReference"))
		{	*type = SOAP_TYPE__wsa5__EndpointReference;
			return soap_in__wsa5__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemIRI"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemIRI;
			s = soap_in__wsa5__ProblemIRI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__Action;
			s = soap_in__wsa5__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__To;
			s = soap_in__wsa5__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__MessageID;
			s = soap_in__wsa5__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_out_xsd__unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE__wsa5__RetryAfter:
		return soap_out__wsa5__RetryAfter(soap, "wsa5:RetryAfter", id, (const ULONG64 *)ptr, "");
	case SOAP_TYPE_ULONG64:
		return soap_out_ULONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_out__wsa5__IsReferenceParameter(soap, tag, id, (const enum _wsa5__IsReferenceParameter *)ptr, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_out_wsa5__FaultCodesType(soap, tag, id, (const enum wsa5__FaultCodesType *)ptr, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_out_wsa5__RelationshipType(soap, tag, id, (const enum wsa5__RelationshipType *)ptr, "wsa5:RelationshipType");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns10__EEventTypes:
		return soap_out_ns10__EEventTypes(soap, tag, id, (const enum ns10__EEventTypes *)ptr, "ns10:EEventTypes");
	case SOAP_TYPE_ns10__EResultValueStatus:
		return soap_out_ns10__EResultValueStatus(soap, tag, id, (const enum ns10__EResultValueStatus *)ptr, "ns10:EResultValueStatus");
	case SOAP_TYPE_ns10__EResultStatus:
		return soap_out_ns10__EResultStatus(soap, tag, id, (const enum ns10__EResultStatus *)ptr, "ns10:EResultStatus");
	case SOAP_TYPE_ns10__ESampleTypes:
		return soap_out_ns10__ESampleTypes(soap, tag, id, (const enum ns10__ESampleTypes *)ptr, "ns10:ESampleTypes");
	case SOAP_TYPE_ns9__ChromatographMode:
		return soap_out_ns9__ChromatographMode(soap, tag, id, (const enum ns9__ChromatographMode *)ptr, "ns9:ChromatographMode");
	case SOAP_TYPE_ns8__Logger_x002eLogLevel:
		return soap_out_ns8__Logger_x002eLogLevel(soap, tag, id, (const enum ns8__Logger_x002eLogLevel *)ptr, "ns8:Logger.LogLevel");
	case SOAP_TYPE_ns4__OperationTypes:
		return soap_out_ns4__OperationTypes(soap, tag, id, (const enum ns4__OperationTypes *)ptr, "ns4:OperationTypes");
	case SOAP_TYPE_ns4__ControlledParametr_x002eControlActionType:
		return soap_out_ns4__ControlledParametr_x002eControlActionType(soap, tag, id, (const enum ns4__ControlledParametr_x002eControlActionType *)ptr, "ns4:ControlledParametr.ControlActionType");
	case SOAP_TYPE_ns4__OperationStepTypes:
		return soap_out_ns4__OperationStepTypes(soap, tag, id, (const enum ns4__OperationStepTypes *)ptr, "ns4:OperationStepTypes");
	case SOAP_TYPE_ns3__ProcessingModes:
		return soap_out_ns3__ProcessingModes(soap, tag, id, (const enum ns3__ProcessingModes *)ptr, "ns3:ProcessingModes");
	case SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfoStates:
		return soap_out_ns3__OperationProcInfo_x002eOperationStepInfoStates(soap, tag, id, (const enum ns3__OperationProcInfo_x002eOperationStepInfoStates *)ptr, "ns3:OperationProcInfo.OperationStepInfoStates");
	case SOAP_TYPE_ns10__EEvent:
		return ((ns10__EEvent *)ptr)->soap_out(soap, tag, id, "ns10:EEvent");
	case SOAP_TYPE_ns10__ArrayOfEEvent:
		return ((ns10__ArrayOfEEvent *)ptr)->soap_out(soap, tag, id, "ns10:ArrayOfEEvent");
	case SOAP_TYPE_ns10__EResult:
		return ((ns10__EResult *)ptr)->soap_out(soap, tag, id, "ns10:EResult");
	case SOAP_TYPE_ns10__ArrayOfEResult:
		return ((ns10__ArrayOfEResult *)ptr)->soap_out(soap, tag, id, "ns10:ArrayOfEResult");
	case SOAP_TYPE_ns10__ESample:
		return ((ns10__ESample *)ptr)->soap_out(soap, tag, id, "ns10:ESample");
	case SOAP_TYPE_ns10__ArrayOfESample:
		return ((ns10__ArrayOfESample *)ptr)->soap_out(soap, tag, id, "ns10:ArrayOfESample");
	case SOAP_TYPE_ns7__AuxDeviceState:
		return ((ns7__AuxDeviceState *)ptr)->soap_out(soap, tag, id, "ns7:AuxDeviceState");
	case SOAP_TYPE_ns7__ArrayOfAuxDeviceState:
		return ((ns7__ArrayOfAuxDeviceState *)ptr)->soap_out(soap, tag, id, "ns7:ArrayOfAuxDeviceState");
	case SOAP_TYPE_ns7__AuxDevice:
		return ((ns7__AuxDevice *)ptr)->soap_out(soap, tag, id, "ns7:AuxDevice");
	case SOAP_TYPE_ns7__ArrayOfAuxDevice:
		return ((ns7__ArrayOfAuxDevice *)ptr)->soap_out(soap, tag, id, "ns7:ArrayOfAuxDevice");
	case SOAP_TYPE_ns7__AuxControllerConfiguration:
		return ((ns7__AuxControllerConfiguration *)ptr)->soap_out(soap, tag, id, "ns7:AuxControllerConfiguration");
	case SOAP_TYPE_ns6__Aux2Config:
		return ((ns6__Aux2Config *)ptr)->soap_out(soap, tag, id, "ns6:Aux2Config");
	case SOAP_TYPE_ns5__SystemConfigurations:
		return ((ns5__SystemConfigurations *)ptr)->soap_out(soap, tag, id, "ns5:SystemConfigurations");
	case SOAP_TYPE_arr__ArrayOfboolean:
		return ((arr__ArrayOfboolean *)ptr)->soap_out(soap, tag, id, "arr:ArrayOfboolean");
	case SOAP_TYPE_arr__ArrayOfstring:
		return ((arr__ArrayOfstring *)ptr)->soap_out(soap, tag, id, "arr:ArrayOfstring");
	case SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr:
		return ((ns4__OperationStep_x002eUsingControlledParametr *)ptr)->soap_out(soap, tag, id, "ns4:OperationStep.UsingControlledParametr");
	case SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr:
		return ((ns4__ArrayOfOperationStep_x002eUsingControlledParametr *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfOperationStep.UsingControlledParametr");
	case SOAP_TYPE_ns4__OperationStep:
		return ((ns4__OperationStep *)ptr)->soap_out(soap, tag, id, "ns4:OperationStep");
	case SOAP_TYPE_ns4__ArrayOfOperationStep:
		return ((ns4__ArrayOfOperationStep *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfOperationStep");
	case SOAP_TYPE_ns4__Operation:
		return ((ns4__Operation *)ptr)->soap_out(soap, tag, id, "ns4:Operation");
	case SOAP_TYPE_ns4__ArrayOfOperation:
		return ((ns4__ArrayOfOperation *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfOperation");
	case SOAP_TYPE_ns4__MeasuringComponent:
		return ((ns4__MeasuringComponent *)ptr)->soap_out(soap, tag, id, "ns4:MeasuringComponent");
	case SOAP_TYPE_ns4__ArrayOfMeasuringComponent:
		return ((ns4__ArrayOfMeasuringComponent *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfMeasuringComponent");
	case SOAP_TYPE_ns4__ControlledParametr:
		return ((ns4__ControlledParametr *)ptr)->soap_out(soap, tag, id, "ns4:ControlledParametr");
	case SOAP_TYPE_ns4__ArrayOfControlledParametr:
		return ((ns4__ArrayOfControlledParametr *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfControlledParametr");
	case SOAP_TYPE_ns4__Periodicity_x002eTime:
		return ((ns4__Periodicity_x002eTime *)ptr)->soap_out(soap, tag, id, "ns4:Periodicity.Time");
	case SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime:
		return ((ns4__ArrayOfPeriodicity_x002eTime *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfPeriodicity.Time");
	case SOAP_TYPE_ns4__Periodicity:
		return ((ns4__Periodicity *)ptr)->soap_out(soap, tag, id, "ns4:Periodicity");
	case SOAP_TYPE_ns4__AutoPlanItem:
		return ((ns4__AutoPlanItem *)ptr)->soap_out(soap, tag, id, "ns4:AutoPlanItem");
	case SOAP_TYPE_ns4__ArrayOfAutoPlanItem:
		return ((ns4__ArrayOfAutoPlanItem *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfAutoPlanItem");
	case SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo:
		return ((ns3__OperationProcInfo_x002eOperationStepInfo *)ptr)->soap_out(soap, tag, id, "ns3:OperationProcInfo.OperationStepInfo");
	case SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo:
		return ((ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfOperationProcInfo.OperationStepInfo");
	case SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo:
		return ((ns3__OperationProcInfo_x002eControlParamInfo *)ptr)->soap_out(soap, tag, id, "ns3:OperationProcInfo.ControlParamInfo");
	case SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo:
		return ((ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfOperationProcInfo.ControlParamInfo");
	case SOAP_TYPE_ns3__OperationProcInfo:
		return ((ns3__OperationProcInfo *)ptr)->soap_out(soap, tag, id, "ns3:OperationProcInfo");
	case SOAP_TYPE_ns3__ProcessingInfo:
		return ((ns3__ProcessingInfo *)ptr)->soap_out(soap, tag, id, "ns3:ProcessingInfo");
	case SOAP_TYPE__ns2__GetEventsSinceIdResponse:
		return ((_ns2__GetEventsSinceIdResponse *)ptr)->soap_out(soap, "ns2:GetEventsSinceIdResponse", id, "");
	case SOAP_TYPE__ns2__GetEventsSinceId:
		return ((_ns2__GetEventsSinceId *)ptr)->soap_out(soap, "ns2:GetEventsSinceId", id, "");
	case SOAP_TYPE__ns2__GetLastEventIdResponse:
		return ((_ns2__GetLastEventIdResponse *)ptr)->soap_out(soap, "ns2:GetLastEventIdResponse", id, "");
	case SOAP_TYPE__ns2__GetLastEventId:
		return ((_ns2__GetLastEventId *)ptr)->soap_out(soap, "ns2:GetLastEventId", id, "");
	case SOAP_TYPE__ns2__GetEventsResponse:
		return ((_ns2__GetEventsResponse *)ptr)->soap_out(soap, "ns2:GetEventsResponse", id, "");
	case SOAP_TYPE__ns2__GetEvents:
		return ((_ns2__GetEvents *)ptr)->soap_out(soap, "ns2:GetEvents", id, "");
	case SOAP_TYPE__ns2__GetResultsSinceIdResponse:
		return ((_ns2__GetResultsSinceIdResponse *)ptr)->soap_out(soap, "ns2:GetResultsSinceIdResponse", id, "");
	case SOAP_TYPE__ns2__GetResultsSinceId:
		return ((_ns2__GetResultsSinceId *)ptr)->soap_out(soap, "ns2:GetResultsSinceId", id, "");
	case SOAP_TYPE__ns2__GetLastResultIdResponse:
		return ((_ns2__GetLastResultIdResponse *)ptr)->soap_out(soap, "ns2:GetLastResultIdResponse", id, "");
	case SOAP_TYPE__ns2__GetLastResultId:
		return ((_ns2__GetLastResultId *)ptr)->soap_out(soap, "ns2:GetLastResultId", id, "");
	case SOAP_TYPE__ns2__GetLastResultResponse:
		return ((_ns2__GetLastResultResponse *)ptr)->soap_out(soap, "ns2:GetLastResultResponse", id, "");
	case SOAP_TYPE__ns2__GetLastResult:
		return ((_ns2__GetLastResult *)ptr)->soap_out(soap, "ns2:GetLastResult", id, "");
	case SOAP_TYPE__ns2__GetResultsResponse:
		return ((_ns2__GetResultsResponse *)ptr)->soap_out(soap, "ns2:GetResultsResponse", id, "");
	case SOAP_TYPE__ns2__GetResults:
		return ((_ns2__GetResults *)ptr)->soap_out(soap, "ns2:GetResults", id, "");
	case SOAP_TYPE__ns2__SetSystemConfigurationsResponse:
		return ((_ns2__SetSystemConfigurationsResponse *)ptr)->soap_out(soap, "ns2:SetSystemConfigurationsResponse", id, "");
	case SOAP_TYPE__ns2__SetSystemConfigurations:
		return ((_ns2__SetSystemConfigurations *)ptr)->soap_out(soap, "ns2:SetSystemConfigurations", id, "");
	case SOAP_TYPE__ns2__GetSystemConfigurationsResponse:
		return ((_ns2__GetSystemConfigurationsResponse *)ptr)->soap_out(soap, "ns2:GetSystemConfigurationsResponse", id, "");
	case SOAP_TYPE__ns2__GetSystemConfigurations:
		return ((_ns2__GetSystemConfigurations *)ptr)->soap_out(soap, "ns2:GetSystemConfigurations", id, "");
	case SOAP_TYPE__ns2__SetIgnoreClearingResponse:
		return ((_ns2__SetIgnoreClearingResponse *)ptr)->soap_out(soap, "ns2:SetIgnoreClearingResponse", id, "");
	case SOAP_TYPE__ns2__SetIgnoreClearing:
		return ((_ns2__SetIgnoreClearing *)ptr)->soap_out(soap, "ns2:SetIgnoreClearing", id, "");
	case SOAP_TYPE__ns2__GetProcessingInfoResponse:
		return ((_ns2__GetProcessingInfoResponse *)ptr)->soap_out(soap, "ns2:GetProcessingInfoResponse", id, "");
	case SOAP_TYPE__ns2__GetProcessingInfo:
		return ((_ns2__GetProcessingInfo *)ptr)->soap_out(soap, "ns2:GetProcessingInfo", id, "");
	case SOAP_TYPE__ns2__AbortAnalyzingResponse:
		return ((_ns2__AbortAnalyzingResponse *)ptr)->soap_out(soap, "ns2:AbortAnalyzingResponse", id, "");
	case SOAP_TYPE__ns2__AbortAnalyzing:
		return ((_ns2__AbortAnalyzing *)ptr)->soap_out(soap, "ns2:AbortAnalyzing", id, "");
	case SOAP_TYPE__ns2__StopAnalyzingResponse:
		return ((_ns2__StopAnalyzingResponse *)ptr)->soap_out(soap, "ns2:StopAnalyzingResponse", id, "");
	case SOAP_TYPE__ns2__StopAnalyzing:
		return ((_ns2__StopAnalyzing *)ptr)->soap_out(soap, "ns2:StopAnalyzing", id, "");
	case SOAP_TYPE__ns2__StartOperationResponse:
		return ((_ns2__StartOperationResponse *)ptr)->soap_out(soap, "ns2:StartOperationResponse", id, "");
	case SOAP_TYPE__ns2__StartOperation:
		return ((_ns2__StartOperation *)ptr)->soap_out(soap, "ns2:StartOperation", id, "");
	case SOAP_TYPE__ns2__StartAutoPlanResponse:
		return ((_ns2__StartAutoPlanResponse *)ptr)->soap_out(soap, "ns2:StartAutoPlanResponse", id, "");
	case SOAP_TYPE__ns2__StartAutoPlan:
		return ((_ns2__StartAutoPlan *)ptr)->soap_out(soap, "ns2:StartAutoPlan", id, "");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_out_chan__ChannelInstanceType(soap, tag, id, (const struct chan__ChannelInstanceType *)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE__wsa5__ProblemAction:
		return soap_out__wsa5__ProblemAction(soap, "wsa5:ProblemAction", id, (const struct wsa5__ProblemActionType *)ptr, "");
	case SOAP_TYPE__wsa5__FaultTo:
		return soap_out__wsa5__FaultTo(soap, "wsa5:FaultTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__From:
		return soap_out__wsa5__From(soap, "wsa5:From", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__ReplyTo:
		return soap_out__wsa5__ReplyTo(soap, "wsa5:ReplyTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__RelatesTo:
		return soap_out__wsa5__RelatesTo(soap, "wsa5:RelatesTo", id, (const struct wsa5__RelatesToType *)ptr, "");
	case SOAP_TYPE__wsa5__Metadata:
		return soap_out__wsa5__Metadata(soap, "wsa5:Metadata", id, (const struct wsa5__MetadataType *)ptr, "");
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return soap_out__wsa5__ReferenceParameters(soap, "wsa5:ReferenceParameters", id, (const struct wsa5__ReferenceParametersType *)ptr, "");
	case SOAP_TYPE__wsa5__EndpointReference:
		return soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_out_wsa5__ProblemActionType(soap, tag, id, (const struct wsa5__ProblemActionType *)ptr, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_out_wsa5__RelatesToType(soap, tag, id, (const struct wsa5__RelatesToType *)ptr, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_out_wsa5__MetadataType(soap, tag, id, (const struct wsa5__MetadataType *)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_out_wsa5__ReferenceParametersType(soap, tag, id, (const struct wsa5__ReferenceParametersType *)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_out_wsa5__EndpointReferenceType(soap, tag, id, (const struct wsa5__EndpointReferenceType *)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_out_PointerTochan__ChannelInstanceType(soap, tag, id, (struct chan__ChannelInstanceType *const*)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_out_PointerTo_wsa5__FaultTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_out_PointerTo_wsa5__ReplyTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_out_PointerTo_wsa5__From(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_out_PointerTo_wsa5__RelatesTo(soap, tag, id, (struct wsa5__RelatesToType *const*)ptr, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemIRI:
		return soap_out_string(soap, "wsa5:ProblemIRI", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE__wsa5__Action:
		return soap_out_string(soap, "wsa5:Action", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__To:
		return soap_out_string(soap, "wsa5:To", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__MessageID:
		return soap_out_string(soap, "wsa5:MessageID", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_out_PointerTowsa5__MetadataType(soap, tag, id, (struct wsa5__MetadataType *const*)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_out_PointerTowsa5__ReferenceParametersType(soap, tag, id, (struct wsa5__ReferenceParametersType *const*)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:FaultCodesOpenEnumType");
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:RelationshipTypeOpenEnum");
	case SOAP_TYPE_PointerTo_ns2__GetEventsSinceId:
		return soap_out_PointerTo_ns2__GetEventsSinceId(soap, tag, id, (_ns2__GetEventsSinceId *const*)ptr, "ns2:GetEventsSinceId");
	case SOAP_TYPE_PointerTo_ns2__GetLastEventId:
		return soap_out_PointerTo_ns2__GetLastEventId(soap, tag, id, (_ns2__GetLastEventId *const*)ptr, "ns2:GetLastEventId");
	case SOAP_TYPE_PointerTo_ns2__GetEvents:
		return soap_out_PointerTo_ns2__GetEvents(soap, tag, id, (_ns2__GetEvents *const*)ptr, "ns2:GetEvents");
	case SOAP_TYPE_PointerTo_ns2__GetResultsSinceId:
		return soap_out_PointerTo_ns2__GetResultsSinceId(soap, tag, id, (_ns2__GetResultsSinceId *const*)ptr, "ns2:GetResultsSinceId");
	case SOAP_TYPE_PointerTo_ns2__GetLastResultId:
		return soap_out_PointerTo_ns2__GetLastResultId(soap, tag, id, (_ns2__GetLastResultId *const*)ptr, "ns2:GetLastResultId");
	case SOAP_TYPE_PointerTo_ns2__GetLastResult:
		return soap_out_PointerTo_ns2__GetLastResult(soap, tag, id, (_ns2__GetLastResult *const*)ptr, "ns2:GetLastResult");
	case SOAP_TYPE_PointerTo_ns2__GetResults:
		return soap_out_PointerTo_ns2__GetResults(soap, tag, id, (_ns2__GetResults *const*)ptr, "ns2:GetResults");
	case SOAP_TYPE_PointerTo_ns2__SetSystemConfigurations:
		return soap_out_PointerTo_ns2__SetSystemConfigurations(soap, tag, id, (_ns2__SetSystemConfigurations *const*)ptr, "ns2:SetSystemConfigurations");
	case SOAP_TYPE_PointerTo_ns2__GetSystemConfigurations:
		return soap_out_PointerTo_ns2__GetSystemConfigurations(soap, tag, id, (_ns2__GetSystemConfigurations *const*)ptr, "ns2:GetSystemConfigurations");
	case SOAP_TYPE_PointerTo_ns2__SetIgnoreClearing:
		return soap_out_PointerTo_ns2__SetIgnoreClearing(soap, tag, id, (_ns2__SetIgnoreClearing *const*)ptr, "ns2:SetIgnoreClearing");
	case SOAP_TYPE_PointerTo_ns2__GetProcessingInfo:
		return soap_out_PointerTo_ns2__GetProcessingInfo(soap, tag, id, (_ns2__GetProcessingInfo *const*)ptr, "ns2:GetProcessingInfo");
	case SOAP_TYPE_PointerTo_ns2__AbortAnalyzing:
		return soap_out_PointerTo_ns2__AbortAnalyzing(soap, tag, id, (_ns2__AbortAnalyzing *const*)ptr, "ns2:AbortAnalyzing");
	case SOAP_TYPE_PointerTo_ns2__StopAnalyzing:
		return soap_out_PointerTo_ns2__StopAnalyzing(soap, tag, id, (_ns2__StopAnalyzing *const*)ptr, "ns2:StopAnalyzing");
	case SOAP_TYPE_PointerTo_ns2__StartOperation:
		return soap_out_PointerTo_ns2__StartOperation(soap, tag, id, (_ns2__StartOperation *const*)ptr, "ns2:StartOperation");
	case SOAP_TYPE_PointerTo_ns2__StartAutoPlan:
		return soap_out_PointerTo_ns2__StartAutoPlan(soap, tag, id, (_ns2__StartAutoPlan *const*)ptr, "ns2:StartAutoPlan");
	case SOAP_TYPE_PointerTons10__EEventTypes:
		return soap_out_PointerTons10__EEventTypes(soap, tag, id, (enum ns10__EEventTypes *const*)ptr, "ns10:EEventTypes");
	case SOAP_TYPE_PointerTons10__EEvent:
		return soap_out_PointerTons10__EEvent(soap, tag, id, (ns10__EEvent *const*)ptr, "ns10:EEvent");
	case SOAP_TYPE_PointerTons10__EResultValueStatus:
		return soap_out_PointerTons10__EResultValueStatus(soap, tag, id, (enum ns10__EResultValueStatus *const*)ptr, "ns10:EResultValueStatus");
	case SOAP_TYPE_PointerTons10__EResultStatus:
		return soap_out_PointerTons10__EResultStatus(soap, tag, id, (enum ns10__EResultStatus *const*)ptr, "ns10:EResultStatus");
	case SOAP_TYPE_PointerTons10__EResult:
		return soap_out_PointerTons10__EResult(soap, tag, id, (ns10__EResult *const*)ptr, "ns10:EResult");
	case SOAP_TYPE_PointerTons10__ArrayOfEResult:
		return soap_out_PointerTons10__ArrayOfEResult(soap, tag, id, (ns10__ArrayOfEResult *const*)ptr, "ns10:ArrayOfEResult");
	case SOAP_TYPE_PointerTons7__AuxDeviceState:
		return soap_out_PointerTons7__AuxDeviceState(soap, tag, id, (ns7__AuxDeviceState *const*)ptr, "ns7:AuxDeviceState");
	case SOAP_TYPE_PointerTons7__ArrayOfAuxDeviceState:
		return soap_out_PointerTons7__ArrayOfAuxDeviceState(soap, tag, id, (ns7__ArrayOfAuxDeviceState *const*)ptr, "ns7:ArrayOfAuxDeviceState");
	case SOAP_TYPE_PointerTons7__AuxDevice:
		return soap_out_PointerTons7__AuxDevice(soap, tag, id, (ns7__AuxDevice *const*)ptr, "ns7:AuxDevice");
	case SOAP_TYPE_PointerTons7__ArrayOfAuxDevice:
		return soap_out_PointerTons7__ArrayOfAuxDevice(soap, tag, id, (ns7__ArrayOfAuxDevice *const*)ptr, "ns7:ArrayOfAuxDevice");
	case SOAP_TYPE_PointerTons4__ArrayOfOperation:
		return soap_out_PointerTons4__ArrayOfOperation(soap, tag, id, (ns4__ArrayOfOperation *const*)ptr, "ns4:ArrayOfOperation");
	case SOAP_TYPE_PointerTons4__ArrayOfMeasuringComponent:
		return soap_out_PointerTons4__ArrayOfMeasuringComponent(soap, tag, id, (ns4__ArrayOfMeasuringComponent *const*)ptr, "ns4:ArrayOfMeasuringComponent");
	case SOAP_TYPE_PointerTons4__ArrayOfControlledParametr:
		return soap_out_PointerTons4__ArrayOfControlledParametr(soap, tag, id, (ns4__ArrayOfControlledParametr *const*)ptr, "ns4:ArrayOfControlledParametr");
	case SOAP_TYPE_PointerTons8__Logger_x002eLogLevel:
		return soap_out_PointerTons8__Logger_x002eLogLevel(soap, tag, id, (enum ns8__Logger_x002eLogLevel *const*)ptr, "ns8:Logger.LogLevel");
	case SOAP_TYPE_PointerTons7__AuxControllerConfiguration:
		return soap_out_PointerTons7__AuxControllerConfiguration(soap, tag, id, (ns7__AuxControllerConfiguration *const*)ptr, "ns7:AuxControllerConfiguration");
	case SOAP_TYPE_PointerTons6__Aux2Config:
		return soap_out_PointerTons6__Aux2Config(soap, tag, id, (ns6__Aux2Config *const*)ptr, "ns6:Aux2Config");
	case SOAP_TYPE_PointerTons4__ArrayOfAutoPlanItem:
		return soap_out_PointerTons4__ArrayOfAutoPlanItem(soap, tag, id, (ns4__ArrayOfAutoPlanItem *const*)ptr, "ns4:ArrayOfAutoPlanItem");
	case SOAP_TYPE_PointerTons4__OperationStep_x002eUsingControlledParametr:
		return soap_out_PointerTons4__OperationStep_x002eUsingControlledParametr(soap, tag, id, (ns4__OperationStep_x002eUsingControlledParametr *const*)ptr, "ns4:OperationStep.UsingControlledParametr");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerTons9__ChromatographMode:
		return soap_out_PointerTons9__ChromatographMode(soap, tag, id, (enum ns9__ChromatographMode *const*)ptr, "ns9:ChromatographMode");
	case SOAP_TYPE_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr:
		return soap_out_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, tag, id, (ns4__ArrayOfOperationStep_x002eUsingControlledParametr *const*)ptr, "ns4:ArrayOfOperationStep.UsingControlledParametr");
	case SOAP_TYPE_PointerTons4__OperationStep:
		return soap_out_PointerTons4__OperationStep(soap, tag, id, (ns4__OperationStep *const*)ptr, "ns4:OperationStep");
	case SOAP_TYPE_PointerTons4__OperationTypes:
		return soap_out_PointerTons4__OperationTypes(soap, tag, id, (enum ns4__OperationTypes *const*)ptr, "ns4:OperationTypes");
	case SOAP_TYPE_PointerTons4__ArrayOfOperationStep:
		return soap_out_PointerTons4__ArrayOfOperationStep(soap, tag, id, (ns4__ArrayOfOperationStep *const*)ptr, "ns4:ArrayOfOperationStep");
	case SOAP_TYPE_PointerTons4__Operation:
		return soap_out_PointerTons4__Operation(soap, tag, id, (ns4__Operation *const*)ptr, "ns4:Operation");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_out_PointerToxsd__decimal(soap, tag, id, (std::string *const*)ptr, "xsd:decimal");
	case SOAP_TYPE_PointerTons4__MeasuringComponent:
		return soap_out_PointerTons4__MeasuringComponent(soap, tag, id, (ns4__MeasuringComponent *const*)ptr, "ns4:MeasuringComponent");
	case SOAP_TYPE_PointerToxsd__unsignedByte:
		return soap_out_PointerToxsd__unsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_PointerTons4__ControlledParametr_x002eControlActionType:
		return soap_out_PointerTons4__ControlledParametr_x002eControlActionType(soap, tag, id, (enum ns4__ControlledParametr_x002eControlActionType *const*)ptr, "ns4:ControlledParametr.ControlActionType");
	case SOAP_TYPE_PointerTons4__ControlledParametr:
		return soap_out_PointerTons4__ControlledParametr(soap, tag, id, (ns4__ControlledParametr *const*)ptr, "ns4:ControlledParametr");
	case SOAP_TYPE_PointerTons4__Periodicity_x002eTime:
		return soap_out_PointerTons4__Periodicity_x002eTime(soap, tag, id, (ns4__Periodicity_x002eTime *const*)ptr, "ns4:Periodicity.Time");
	case SOAP_TYPE_PointerTons4__ArrayOfPeriodicity_x002eTime:
		return soap_out_PointerTons4__ArrayOfPeriodicity_x002eTime(soap, tag, id, (ns4__ArrayOfPeriodicity_x002eTime *const*)ptr, "ns4:ArrayOfPeriodicity.Time");
	case SOAP_TYPE_PointerToarr__ArrayOfboolean:
		return soap_out_PointerToarr__ArrayOfboolean(soap, tag, id, (arr__ArrayOfboolean *const*)ptr, "arr:ArrayOfboolean");
	case SOAP_TYPE_PointerTons4__Periodicity:
		return soap_out_PointerTons4__Periodicity(soap, tag, id, (ns4__Periodicity *const*)ptr, "ns4:Periodicity");
	case SOAP_TYPE_PointerTons4__AutoPlanItem:
		return soap_out_PointerTons4__AutoPlanItem(soap, tag, id, (ns4__AutoPlanItem *const*)ptr, "ns4:AutoPlanItem");
	case SOAP_TYPE_PointerTons4__OperationStepTypes:
		return soap_out_PointerTons4__OperationStepTypes(soap, tag, id, (enum ns4__OperationStepTypes *const*)ptr, "ns4:OperationStepTypes");
	case SOAP_TYPE_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates:
		return soap_out_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates(soap, tag, id, (enum ns3__OperationProcInfo_x002eOperationStepInfoStates *const*)ptr, "ns3:OperationProcInfo.OperationStepInfoStates");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTons3__OperationProcInfo_x002eOperationStepInfo:
		return soap_out_PointerTons3__OperationProcInfo_x002eOperationStepInfo(soap, tag, id, (ns3__OperationProcInfo_x002eOperationStepInfo *const*)ptr, "ns3:OperationProcInfo.OperationStepInfo");
	case SOAP_TYPE_PointerTons3__OperationProcInfo_x002eControlParamInfo:
		return soap_out_PointerTons3__OperationProcInfo_x002eControlParamInfo(soap, tag, id, (ns3__OperationProcInfo_x002eControlParamInfo *const*)ptr, "ns3:OperationProcInfo.ControlParamInfo");
	case SOAP_TYPE_PointerToarr__ArrayOfstring:
		return soap_out_PointerToarr__ArrayOfstring(soap, tag, id, (arr__ArrayOfstring *const*)ptr, "arr:ArrayOfstring");
	case SOAP_TYPE_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo:
		return soap_out_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, tag, id, (ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *const*)ptr, "ns3:ArrayOfOperationProcInfo.OperationStepInfo");
	case SOAP_TYPE_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo:
		return soap_out_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, tag, id, (ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *const*)ptr, "ns3:ArrayOfOperationProcInfo.ControlParamInfo");
	case SOAP_TYPE_PointerTons3__ProcessingModes:
		return soap_out_PointerTons3__ProcessingModes(soap, tag, id, (enum ns3__ProcessingModes *const*)ptr, "ns3:ProcessingModes");
	case SOAP_TYPE_PointerTons3__OperationProcInfo:
		return soap_out_PointerTons3__OperationProcInfo(soap, tag, id, (ns3__OperationProcInfo *const*)ptr, "ns3:OperationProcInfo");
	case SOAP_TYPE_PointerTons10__ArrayOfEEvent:
		return soap_out_PointerTons10__ArrayOfEEvent(soap, tag, id, (ns10__ArrayOfEEvent *const*)ptr, "ns10:ArrayOfEEvent");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTons10__ESample:
		return soap_out_PointerTons10__ESample(soap, tag, id, (ns10__ESample *const*)ptr, "ns10:ESample");
	case SOAP_TYPE_PointerTons10__ArrayOfESample:
		return soap_out_PointerTons10__ArrayOfESample(soap, tag, id, (ns10__ArrayOfESample *const*)ptr, "ns10:ArrayOfESample");
	case SOAP_TYPE_PointerTons10__ESampleTypes:
		return soap_out_PointerTons10__ESampleTypes(soap, tag, id, (enum ns10__ESampleTypes *const*)ptr, "ns10:ESampleTypes");
	case SOAP_TYPE_PointerTodateTime:
		return soap_out_PointerTodateTime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons5__SystemConfigurations:
		return soap_out_PointerTons5__SystemConfigurations(soap, tag, id, (ns5__SystemConfigurations *const*)ptr, "ns5:SystemConfigurations");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons3__ProcessingInfo:
		return soap_out_PointerTons3__ProcessingInfo(soap, tag, id, (ns3__ProcessingInfo *const*)ptr, "ns3:ProcessingInfo");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns10__EEvent:
		((ns10__EEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns10__ArrayOfEEvent:
		((ns10__ArrayOfEEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns10__EResult:
		((ns10__EResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns10__ArrayOfEResult:
		((ns10__ArrayOfEResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns10__ESample:
		((ns10__ESample *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns10__ArrayOfESample:
		((ns10__ArrayOfESample *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__AuxDeviceState:
		((ns7__AuxDeviceState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__ArrayOfAuxDeviceState:
		((ns7__ArrayOfAuxDeviceState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__AuxDevice:
		((ns7__AuxDevice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__ArrayOfAuxDevice:
		((ns7__ArrayOfAuxDevice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__AuxControllerConfiguration:
		((ns7__AuxControllerConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__Aux2Config:
		((ns6__Aux2Config *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SystemConfigurations:
		((ns5__SystemConfigurations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_arr__ArrayOfboolean:
		((arr__ArrayOfboolean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_arr__ArrayOfstring:
		((arr__ArrayOfstring *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr:
		((ns4__OperationStep_x002eUsingControlledParametr *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr:
		((ns4__ArrayOfOperationStep_x002eUsingControlledParametr *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__OperationStep:
		((ns4__OperationStep *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfOperationStep:
		((ns4__ArrayOfOperationStep *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Operation:
		((ns4__Operation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfOperation:
		((ns4__ArrayOfOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__MeasuringComponent:
		((ns4__MeasuringComponent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfMeasuringComponent:
		((ns4__ArrayOfMeasuringComponent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ControlledParametr:
		((ns4__ControlledParametr *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfControlledParametr:
		((ns4__ArrayOfControlledParametr *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Periodicity_x002eTime:
		((ns4__Periodicity_x002eTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime:
		((ns4__ArrayOfPeriodicity_x002eTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Periodicity:
		((ns4__Periodicity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__AutoPlanItem:
		((ns4__AutoPlanItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfAutoPlanItem:
		((ns4__ArrayOfAutoPlanItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo:
		((ns3__OperationProcInfo_x002eOperationStepInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo:
		((ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo:
		((ns3__OperationProcInfo_x002eControlParamInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo:
		((ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__OperationProcInfo:
		((ns3__OperationProcInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ProcessingInfo:
		((ns3__ProcessingInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetEventsSinceIdResponse:
		((_ns2__GetEventsSinceIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetEventsSinceId:
		((_ns2__GetEventsSinceId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetLastEventIdResponse:
		((_ns2__GetLastEventIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetLastEventId:
		((_ns2__GetLastEventId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetEventsResponse:
		((_ns2__GetEventsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetEvents:
		((_ns2__GetEvents *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetResultsSinceIdResponse:
		((_ns2__GetResultsSinceIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetResultsSinceId:
		((_ns2__GetResultsSinceId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetLastResultIdResponse:
		((_ns2__GetLastResultIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetLastResultId:
		((_ns2__GetLastResultId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetLastResultResponse:
		((_ns2__GetLastResultResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetLastResult:
		((_ns2__GetLastResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetResultsResponse:
		((_ns2__GetResultsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetResults:
		((_ns2__GetResults *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__SetSystemConfigurationsResponse:
		((_ns2__SetSystemConfigurationsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__SetSystemConfigurations:
		((_ns2__SetSystemConfigurations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetSystemConfigurationsResponse:
		((_ns2__GetSystemConfigurationsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetSystemConfigurations:
		((_ns2__GetSystemConfigurations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__SetIgnoreClearingResponse:
		((_ns2__SetIgnoreClearingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__SetIgnoreClearing:
		((_ns2__SetIgnoreClearing *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetProcessingInfoResponse:
		((_ns2__GetProcessingInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetProcessingInfo:
		((_ns2__GetProcessingInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__AbortAnalyzingResponse:
		((_ns2__AbortAnalyzingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__AbortAnalyzing:
		((_ns2__AbortAnalyzing *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__StopAnalyzingResponse:
		((_ns2__StopAnalyzingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__StopAnalyzing:
		((_ns2__StopAnalyzing *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__StartOperationResponse:
		((_ns2__StartOperationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__StartOperation:
		((_ns2__StartOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__StartAutoPlanResponse:
		((_ns2__StartAutoPlanResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__StartAutoPlan:
		((_ns2__StartAutoPlan *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		soap_serialize_chan__ChannelInstanceType(soap, (const struct chan__ChannelInstanceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		soap_serialize__wsa5__ProblemAction(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		soap_serialize__wsa5__FaultTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__From:
		soap_serialize__wsa5__From(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		soap_serialize__wsa5__ReplyTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		soap_serialize__wsa5__RelatesTo(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		soap_serialize__wsa5__Metadata(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		soap_serialize__wsa5__ReferenceParameters(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		soap_serialize__wsa5__EndpointReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		soap_serialize_wsa5__ProblemActionType(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		soap_serialize_wsa5__RelatesToType(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		soap_serialize_wsa5__MetadataType(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		soap_serialize_wsa5__ReferenceParametersType(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		soap_serialize_wsa5__EndpointReferenceType(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetEventsSinceId:
		soap_serialize___tempuri__GetEventsSinceId(soap, (const struct __tempuri__GetEventsSinceId *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetLastEventId:
		soap_serialize___tempuri__GetLastEventId(soap, (const struct __tempuri__GetLastEventId *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetEvents:
		soap_serialize___tempuri__GetEvents(soap, (const struct __tempuri__GetEvents *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetResultsSinceId:
		soap_serialize___tempuri__GetResultsSinceId(soap, (const struct __tempuri__GetResultsSinceId *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetLastResultId:
		soap_serialize___tempuri__GetLastResultId(soap, (const struct __tempuri__GetLastResultId *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetLastResult:
		soap_serialize___tempuri__GetLastResult(soap, (const struct __tempuri__GetLastResult *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetResults:
		soap_serialize___tempuri__GetResults(soap, (const struct __tempuri__GetResults *)ptr);
		break;
	case SOAP_TYPE___tempuri__SetSystemConfigurations:
		soap_serialize___tempuri__SetSystemConfigurations(soap, (const struct __tempuri__SetSystemConfigurations *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetSystemConfigurations:
		soap_serialize___tempuri__GetSystemConfigurations(soap, (const struct __tempuri__GetSystemConfigurations *)ptr);
		break;
	case SOAP_TYPE___tempuri__SetIgnoreClearing:
		soap_serialize___tempuri__SetIgnoreClearing(soap, (const struct __tempuri__SetIgnoreClearing *)ptr);
		break;
	case SOAP_TYPE___tempuri__GetProcessingInfo:
		soap_serialize___tempuri__GetProcessingInfo(soap, (const struct __tempuri__GetProcessingInfo *)ptr);
		break;
	case SOAP_TYPE___tempuri__AbortAnalyzing:
		soap_serialize___tempuri__AbortAnalyzing(soap, (const struct __tempuri__AbortAnalyzing *)ptr);
		break;
	case SOAP_TYPE___tempuri__StopAnalyzing:
		soap_serialize___tempuri__StopAnalyzing(soap, (const struct __tempuri__StopAnalyzing *)ptr);
		break;
	case SOAP_TYPE___tempuri__StartOperation:
		soap_serialize___tempuri__StartOperation(soap, (const struct __tempuri__StartOperation *)ptr);
		break;
	case SOAP_TYPE___tempuri__StartAutoPlan:
		soap_serialize___tempuri__StartAutoPlan(soap, (const struct __tempuri__StartAutoPlan *)ptr);
		break;
	case SOAP_TYPE___ser__anyType:
		soap_serialize___ser__anyType(soap, (const struct __ser__anyType *)ptr);
		break;
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		soap_serialize_PointerTochan__ChannelInstanceType(soap, (struct chan__ChannelInstanceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		soap_serialize_PointerTo_wsa5__FaultTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		soap_serialize_PointerTo_wsa5__ReplyTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__From:
		soap_serialize_PointerTo_wsa5__From(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		soap_serialize_PointerTo_wsa5__RelatesTo(soap, (struct wsa5__RelatesToType *const*)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemIRI:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__Action:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__To:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__MessageID:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		soap_serialize_PointerTowsa5__MetadataType(soap, (struct wsa5__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		soap_serialize_PointerTowsa5__ReferenceParametersType(soap, (struct wsa5__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GetEventsSinceId:
		soap_serialize_PointerTo_ns2__GetEventsSinceId(soap, (_ns2__GetEventsSinceId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GetLastEventId:
		soap_serialize_PointerTo_ns2__GetLastEventId(soap, (_ns2__GetLastEventId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GetEvents:
		soap_serialize_PointerTo_ns2__GetEvents(soap, (_ns2__GetEvents *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GetResultsSinceId:
		soap_serialize_PointerTo_ns2__GetResultsSinceId(soap, (_ns2__GetResultsSinceId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GetLastResultId:
		soap_serialize_PointerTo_ns2__GetLastResultId(soap, (_ns2__GetLastResultId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GetLastResult:
		soap_serialize_PointerTo_ns2__GetLastResult(soap, (_ns2__GetLastResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GetResults:
		soap_serialize_PointerTo_ns2__GetResults(soap, (_ns2__GetResults *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__SetSystemConfigurations:
		soap_serialize_PointerTo_ns2__SetSystemConfigurations(soap, (_ns2__SetSystemConfigurations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GetSystemConfigurations:
		soap_serialize_PointerTo_ns2__GetSystemConfigurations(soap, (_ns2__GetSystemConfigurations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__SetIgnoreClearing:
		soap_serialize_PointerTo_ns2__SetIgnoreClearing(soap, (_ns2__SetIgnoreClearing *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GetProcessingInfo:
		soap_serialize_PointerTo_ns2__GetProcessingInfo(soap, (_ns2__GetProcessingInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__AbortAnalyzing:
		soap_serialize_PointerTo_ns2__AbortAnalyzing(soap, (_ns2__AbortAnalyzing *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__StopAnalyzing:
		soap_serialize_PointerTo_ns2__StopAnalyzing(soap, (_ns2__StopAnalyzing *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__StartOperation:
		soap_serialize_PointerTo_ns2__StartOperation(soap, (_ns2__StartOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__StartAutoPlan:
		soap_serialize_PointerTo_ns2__StartAutoPlan(soap, (_ns2__StartAutoPlan *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__EEventTypes:
		soap_serialize_PointerTons10__EEventTypes(soap, (enum ns10__EEventTypes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__EEvent:
		soap_serialize_PointerTons10__EEvent(soap, (ns10__EEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__EResultValueStatus:
		soap_serialize_PointerTons10__EResultValueStatus(soap, (enum ns10__EResultValueStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__EResultStatus:
		soap_serialize_PointerTons10__EResultStatus(soap, (enum ns10__EResultStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__EResult:
		soap_serialize_PointerTons10__EResult(soap, (ns10__EResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__ArrayOfEResult:
		soap_serialize_PointerTons10__ArrayOfEResult(soap, (ns10__ArrayOfEResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__AuxDeviceState:
		soap_serialize_PointerTons7__AuxDeviceState(soap, (ns7__AuxDeviceState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__ArrayOfAuxDeviceState:
		soap_serialize_PointerTons7__ArrayOfAuxDeviceState(soap, (ns7__ArrayOfAuxDeviceState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__AuxDevice:
		soap_serialize_PointerTons7__AuxDevice(soap, (ns7__AuxDevice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__ArrayOfAuxDevice:
		soap_serialize_PointerTons7__ArrayOfAuxDevice(soap, (ns7__ArrayOfAuxDevice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfOperation:
		soap_serialize_PointerTons4__ArrayOfOperation(soap, (ns4__ArrayOfOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfMeasuringComponent:
		soap_serialize_PointerTons4__ArrayOfMeasuringComponent(soap, (ns4__ArrayOfMeasuringComponent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfControlledParametr:
		soap_serialize_PointerTons4__ArrayOfControlledParametr(soap, (ns4__ArrayOfControlledParametr *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons8__Logger_x002eLogLevel:
		soap_serialize_PointerTons8__Logger_x002eLogLevel(soap, (enum ns8__Logger_x002eLogLevel *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__AuxControllerConfiguration:
		soap_serialize_PointerTons7__AuxControllerConfiguration(soap, (ns7__AuxControllerConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__Aux2Config:
		soap_serialize_PointerTons6__Aux2Config(soap, (ns6__Aux2Config *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfAutoPlanItem:
		soap_serialize_PointerTons4__ArrayOfAutoPlanItem(soap, (ns4__ArrayOfAutoPlanItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__OperationStep_x002eUsingControlledParametr:
		soap_serialize_PointerTons4__OperationStep_x002eUsingControlledParametr(soap, (ns4__OperationStep_x002eUsingControlledParametr *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons9__ChromatographMode:
		soap_serialize_PointerTons9__ChromatographMode(soap, (enum ns9__ChromatographMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr:
		soap_serialize_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, (ns4__ArrayOfOperationStep_x002eUsingControlledParametr *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__OperationStep:
		soap_serialize_PointerTons4__OperationStep(soap, (ns4__OperationStep *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__OperationTypes:
		soap_serialize_PointerTons4__OperationTypes(soap, (enum ns4__OperationTypes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfOperationStep:
		soap_serialize_PointerTons4__ArrayOfOperationStep(soap, (ns4__ArrayOfOperationStep *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Operation:
		soap_serialize_PointerTons4__Operation(soap, (ns4__Operation *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__decimal:
		soap_serialize_PointerToxsd__decimal(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__MeasuringComponent:
		soap_serialize_PointerTons4__MeasuringComponent(soap, (ns4__MeasuringComponent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__unsignedByte:
		soap_serialize_PointerToxsd__unsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ControlledParametr_x002eControlActionType:
		soap_serialize_PointerTons4__ControlledParametr_x002eControlActionType(soap, (enum ns4__ControlledParametr_x002eControlActionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ControlledParametr:
		soap_serialize_PointerTons4__ControlledParametr(soap, (ns4__ControlledParametr *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Periodicity_x002eTime:
		soap_serialize_PointerTons4__Periodicity_x002eTime(soap, (ns4__Periodicity_x002eTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfPeriodicity_x002eTime:
		soap_serialize_PointerTons4__ArrayOfPeriodicity_x002eTime(soap, (ns4__ArrayOfPeriodicity_x002eTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerToarr__ArrayOfboolean:
		soap_serialize_PointerToarr__ArrayOfboolean(soap, (arr__ArrayOfboolean *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Periodicity:
		soap_serialize_PointerTons4__Periodicity(soap, (ns4__Periodicity *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__AutoPlanItem:
		soap_serialize_PointerTons4__AutoPlanItem(soap, (ns4__AutoPlanItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__OperationStepTypes:
		soap_serialize_PointerTons4__OperationStepTypes(soap, (enum ns4__OperationStepTypes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates:
		soap_serialize_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates(soap, (enum ns3__OperationProcInfo_x002eOperationStepInfoStates *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__OperationProcInfo_x002eOperationStepInfo:
		soap_serialize_PointerTons3__OperationProcInfo_x002eOperationStepInfo(soap, (ns3__OperationProcInfo_x002eOperationStepInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__OperationProcInfo_x002eControlParamInfo:
		soap_serialize_PointerTons3__OperationProcInfo_x002eControlParamInfo(soap, (ns3__OperationProcInfo_x002eControlParamInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToarr__ArrayOfstring:
		soap_serialize_PointerToarr__ArrayOfstring(soap, (arr__ArrayOfstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo:
		soap_serialize_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, (ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo:
		soap_serialize_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, (ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ProcessingModes:
		soap_serialize_PointerTons3__ProcessingModes(soap, (enum ns3__ProcessingModes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__OperationProcInfo:
		soap_serialize_PointerTons3__OperationProcInfo(soap, (ns3__OperationProcInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__ArrayOfEEvent:
		soap_serialize_PointerTons10__ArrayOfEEvent(soap, (ns10__ArrayOfEEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__ESample:
		soap_serialize_PointerTons10__ESample(soap, (ns10__ESample *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__ArrayOfESample:
		soap_serialize_PointerTons10__ArrayOfESample(soap, (ns10__ArrayOfESample *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__ESampleTypes:
		soap_serialize_PointerTons10__ESampleTypes(soap, (enum ns10__ESampleTypes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodateTime:
		soap_serialize_PointerTodateTime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__SystemConfigurations:
		soap_serialize_PointerTons5__SystemConfigurations(soap, (ns5__SystemConfigurations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ProcessingInfo:
		soap_serialize_PointerTons3__ProcessingInfo(soap, (ns3__ProcessingInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE___ser__anyType:
		return (void*)soap_instantiate___ser__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__StartAutoPlan:
		return (void*)soap_instantiate__ns2__StartAutoPlan(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__StartAutoPlanResponse:
		return (void*)soap_instantiate__ns2__StartAutoPlanResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__StartOperation:
		return (void*)soap_instantiate__ns2__StartOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__StartOperationResponse:
		return (void*)soap_instantiate__ns2__StartOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__StopAnalyzing:
		return (void*)soap_instantiate__ns2__StopAnalyzing(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__StopAnalyzingResponse:
		return (void*)soap_instantiate__ns2__StopAnalyzingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__AbortAnalyzing:
		return (void*)soap_instantiate__ns2__AbortAnalyzing(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__AbortAnalyzingResponse:
		return (void*)soap_instantiate__ns2__AbortAnalyzingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetProcessingInfo:
		return (void*)soap_instantiate__ns2__GetProcessingInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetProcessingInfoResponse:
		return (void*)soap_instantiate__ns2__GetProcessingInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__SetIgnoreClearing:
		return (void*)soap_instantiate__ns2__SetIgnoreClearing(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__SetIgnoreClearingResponse:
		return (void*)soap_instantiate__ns2__SetIgnoreClearingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetSystemConfigurations:
		return (void*)soap_instantiate__ns2__GetSystemConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetSystemConfigurationsResponse:
		return (void*)soap_instantiate__ns2__GetSystemConfigurationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__SetSystemConfigurations:
		return (void*)soap_instantiate__ns2__SetSystemConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__SetSystemConfigurationsResponse:
		return (void*)soap_instantiate__ns2__SetSystemConfigurationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetResults:
		return (void*)soap_instantiate__ns2__GetResults(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetResultsResponse:
		return (void*)soap_instantiate__ns2__GetResultsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetLastResult:
		return (void*)soap_instantiate__ns2__GetLastResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetLastResultResponse:
		return (void*)soap_instantiate__ns2__GetLastResultResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetLastResultId:
		return (void*)soap_instantiate__ns2__GetLastResultId(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetLastResultIdResponse:
		return (void*)soap_instantiate__ns2__GetLastResultIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetResultsSinceId:
		return (void*)soap_instantiate__ns2__GetResultsSinceId(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetResultsSinceIdResponse:
		return (void*)soap_instantiate__ns2__GetResultsSinceIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetEvents:
		return (void*)soap_instantiate__ns2__GetEvents(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetEventsResponse:
		return (void*)soap_instantiate__ns2__GetEventsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetLastEventId:
		return (void*)soap_instantiate__ns2__GetLastEventId(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetLastEventIdResponse:
		return (void*)soap_instantiate__ns2__GetLastEventIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetEventsSinceId:
		return (void*)soap_instantiate__ns2__GetEventsSinceId(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetEventsSinceIdResponse:
		return (void*)soap_instantiate__ns2__GetEventsSinceIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ProcessingInfo:
		return (void*)soap_instantiate_ns3__ProcessingInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__OperationProcInfo:
		return (void*)soap_instantiate_ns3__OperationProcInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo:
		return (void*)soap_instantiate_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo:
		return (void*)soap_instantiate_ns3__OperationProcInfo_x002eControlParamInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo:
		return (void*)soap_instantiate_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo:
		return (void*)soap_instantiate_ns3__OperationProcInfo_x002eOperationStepInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfAutoPlanItem:
		return (void*)soap_instantiate_ns4__ArrayOfAutoPlanItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__AutoPlanItem:
		return (void*)soap_instantiate_ns4__AutoPlanItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Periodicity:
		return (void*)soap_instantiate_ns4__Periodicity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime:
		return (void*)soap_instantiate_ns4__ArrayOfPeriodicity_x002eTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Periodicity_x002eTime:
		return (void*)soap_instantiate_ns4__Periodicity_x002eTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfControlledParametr:
		return (void*)soap_instantiate_ns4__ArrayOfControlledParametr(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ControlledParametr:
		return (void*)soap_instantiate_ns4__ControlledParametr(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfMeasuringComponent:
		return (void*)soap_instantiate_ns4__ArrayOfMeasuringComponent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__MeasuringComponent:
		return (void*)soap_instantiate_ns4__MeasuringComponent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfOperation:
		return (void*)soap_instantiate_ns4__ArrayOfOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Operation:
		return (void*)soap_instantiate_ns4__Operation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfOperationStep:
		return (void*)soap_instantiate_ns4__ArrayOfOperationStep(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__OperationStep:
		return (void*)soap_instantiate_ns4__OperationStep(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr:
		return (void*)soap_instantiate_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr:
		return (void*)soap_instantiate_ns4__OperationStep_x002eUsingControlledParametr(soap, -1, type, arrayType, n);
	case SOAP_TYPE_arr__ArrayOfstring:
		return (void*)soap_instantiate_arr__ArrayOfstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_arr__ArrayOfboolean:
		return (void*)soap_instantiate_arr__ArrayOfboolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SystemConfigurations:
		return (void*)soap_instantiate_ns5__SystemConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Aux2Config:
		return (void*)soap_instantiate_ns6__Aux2Config(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__AuxControllerConfiguration:
		return (void*)soap_instantiate_ns7__AuxControllerConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ArrayOfAuxDevice:
		return (void*)soap_instantiate_ns7__ArrayOfAuxDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__AuxDevice:
		return (void*)soap_instantiate_ns7__AuxDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ArrayOfAuxDeviceState:
		return (void*)soap_instantiate_ns7__ArrayOfAuxDeviceState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__AuxDeviceState:
		return (void*)soap_instantiate_ns7__AuxDeviceState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns10__ArrayOfESample:
		return (void*)soap_instantiate_ns10__ArrayOfESample(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns10__ESample:
		return (void*)soap_instantiate_ns10__ESample(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns10__ArrayOfEResult:
		return (void*)soap_instantiate_ns10__ArrayOfEResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns10__EResult:
		return (void*)soap_instantiate_ns10__EResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns10__ArrayOfEEvent:
		return (void*)soap_instantiate_ns10__ArrayOfEEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns10__EEvent:
		return (void*)soap_instantiate_ns10__EEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__StartAutoPlan:
		return (void*)soap_instantiate___tempuri__StartAutoPlan(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__StartOperation:
		return (void*)soap_instantiate___tempuri__StartOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__StopAnalyzing:
		return (void*)soap_instantiate___tempuri__StopAnalyzing(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AbortAnalyzing:
		return (void*)soap_instantiate___tempuri__AbortAnalyzing(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetProcessingInfo:
		return (void*)soap_instantiate___tempuri__GetProcessingInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__SetIgnoreClearing:
		return (void*)soap_instantiate___tempuri__SetIgnoreClearing(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetSystemConfigurations:
		return (void*)soap_instantiate___tempuri__GetSystemConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__SetSystemConfigurations:
		return (void*)soap_instantiate___tempuri__SetSystemConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetResults:
		return (void*)soap_instantiate___tempuri__GetResults(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetLastResult:
		return (void*)soap_instantiate___tempuri__GetLastResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetLastResultId:
		return (void*)soap_instantiate___tempuri__GetLastResultId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetResultsSinceId:
		return (void*)soap_instantiate___tempuri__GetResultsSinceId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetEvents:
		return (void*)soap_instantiate___tempuri__GetEvents(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetLastEventId:
		return (void*)soap_instantiate___tempuri__GetLastEventId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__GetEventsSinceId:
		return (void*)soap_instantiate___tempuri__GetEventsSinceId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return (void*)soap_instantiate_wsa5__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return (void*)soap_instantiate_wsa5__ReferenceParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__MetadataType:
		return (void*)soap_instantiate_wsa5__MetadataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ProblemActionType:
		return (void*)soap_instantiate_wsa5__ProblemActionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__RelatesToType:
		return (void*)soap_instantiate_wsa5__RelatesToType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_chan__ChannelInstanceType:
		return (void*)soap_instantiate_chan__ChannelInstanceType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__EndpointReference:
		return (void*)soap_instantiate__wsa5__EndpointReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return (void*)soap_instantiate__wsa5__ReferenceParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__Metadata:
		return (void*)soap_instantiate__wsa5__Metadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__RelatesTo:
		return (void*)soap_instantiate__wsa5__RelatesTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReplyTo:
		return (void*)soap_instantiate__wsa5__ReplyTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__From:
		return (void*)soap_instantiate__wsa5__From(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__FaultTo:
		return (void*)soap_instantiate__wsa5__FaultTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ProblemAction:
		return (void*)soap_instantiate__wsa5__ProblemAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons10__EEvent:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons10__EEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons10__EResult:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons10__EResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons10__ESample:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons10__ESample(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__AuxDeviceState:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__AuxDeviceState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__AuxDevice:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__AuxDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfbool:
		return (void*)soap_instantiate_std__vectorTemplateOfbool(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__OperationStep:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__OperationStep(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Operation:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__Operation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__MeasuringComponent:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__MeasuringComponent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__ControlledParametr:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__ControlledParametr(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__AutoPlanItem:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__AutoPlanItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE___ser__anyType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ser__anyType*>(p->ptr), struct __ser__anyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ser__anyType*>(p->ptr), struct __ser__anyType);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE__ns2__StartAutoPlan:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__StartAutoPlan*>(p->ptr), _ns2__StartAutoPlan);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__StartAutoPlan*>(p->ptr), _ns2__StartAutoPlan);
		break;
	case SOAP_TYPE__ns2__StartAutoPlanResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__StartAutoPlanResponse*>(p->ptr), _ns2__StartAutoPlanResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__StartAutoPlanResponse*>(p->ptr), _ns2__StartAutoPlanResponse);
		break;
	case SOAP_TYPE__ns2__StartOperation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__StartOperation*>(p->ptr), _ns2__StartOperation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__StartOperation*>(p->ptr), _ns2__StartOperation);
		break;
	case SOAP_TYPE__ns2__StartOperationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__StartOperationResponse*>(p->ptr), _ns2__StartOperationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__StartOperationResponse*>(p->ptr), _ns2__StartOperationResponse);
		break;
	case SOAP_TYPE__ns2__StopAnalyzing:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__StopAnalyzing*>(p->ptr), _ns2__StopAnalyzing);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__StopAnalyzing*>(p->ptr), _ns2__StopAnalyzing);
		break;
	case SOAP_TYPE__ns2__StopAnalyzingResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__StopAnalyzingResponse*>(p->ptr), _ns2__StopAnalyzingResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__StopAnalyzingResponse*>(p->ptr), _ns2__StopAnalyzingResponse);
		break;
	case SOAP_TYPE__ns2__AbortAnalyzing:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__AbortAnalyzing*>(p->ptr), _ns2__AbortAnalyzing);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__AbortAnalyzing*>(p->ptr), _ns2__AbortAnalyzing);
		break;
	case SOAP_TYPE__ns2__AbortAnalyzingResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__AbortAnalyzingResponse*>(p->ptr), _ns2__AbortAnalyzingResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__AbortAnalyzingResponse*>(p->ptr), _ns2__AbortAnalyzingResponse);
		break;
	case SOAP_TYPE__ns2__GetProcessingInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetProcessingInfo*>(p->ptr), _ns2__GetProcessingInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetProcessingInfo*>(p->ptr), _ns2__GetProcessingInfo);
		break;
	case SOAP_TYPE__ns2__GetProcessingInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetProcessingInfoResponse*>(p->ptr), _ns2__GetProcessingInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetProcessingInfoResponse*>(p->ptr), _ns2__GetProcessingInfoResponse);
		break;
	case SOAP_TYPE__ns2__SetIgnoreClearing:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__SetIgnoreClearing*>(p->ptr), _ns2__SetIgnoreClearing);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__SetIgnoreClearing*>(p->ptr), _ns2__SetIgnoreClearing);
		break;
	case SOAP_TYPE__ns2__SetIgnoreClearingResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__SetIgnoreClearingResponse*>(p->ptr), _ns2__SetIgnoreClearingResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__SetIgnoreClearingResponse*>(p->ptr), _ns2__SetIgnoreClearingResponse);
		break;
	case SOAP_TYPE__ns2__GetSystemConfigurations:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetSystemConfigurations*>(p->ptr), _ns2__GetSystemConfigurations);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetSystemConfigurations*>(p->ptr), _ns2__GetSystemConfigurations);
		break;
	case SOAP_TYPE__ns2__GetSystemConfigurationsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetSystemConfigurationsResponse*>(p->ptr), _ns2__GetSystemConfigurationsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetSystemConfigurationsResponse*>(p->ptr), _ns2__GetSystemConfigurationsResponse);
		break;
	case SOAP_TYPE__ns2__SetSystemConfigurations:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__SetSystemConfigurations*>(p->ptr), _ns2__SetSystemConfigurations);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__SetSystemConfigurations*>(p->ptr), _ns2__SetSystemConfigurations);
		break;
	case SOAP_TYPE__ns2__SetSystemConfigurationsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__SetSystemConfigurationsResponse*>(p->ptr), _ns2__SetSystemConfigurationsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__SetSystemConfigurationsResponse*>(p->ptr), _ns2__SetSystemConfigurationsResponse);
		break;
	case SOAP_TYPE__ns2__GetResults:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetResults*>(p->ptr), _ns2__GetResults);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetResults*>(p->ptr), _ns2__GetResults);
		break;
	case SOAP_TYPE__ns2__GetResultsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetResultsResponse*>(p->ptr), _ns2__GetResultsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetResultsResponse*>(p->ptr), _ns2__GetResultsResponse);
		break;
	case SOAP_TYPE__ns2__GetLastResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetLastResult*>(p->ptr), _ns2__GetLastResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetLastResult*>(p->ptr), _ns2__GetLastResult);
		break;
	case SOAP_TYPE__ns2__GetLastResultResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetLastResultResponse*>(p->ptr), _ns2__GetLastResultResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetLastResultResponse*>(p->ptr), _ns2__GetLastResultResponse);
		break;
	case SOAP_TYPE__ns2__GetLastResultId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetLastResultId*>(p->ptr), _ns2__GetLastResultId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetLastResultId*>(p->ptr), _ns2__GetLastResultId);
		break;
	case SOAP_TYPE__ns2__GetLastResultIdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetLastResultIdResponse*>(p->ptr), _ns2__GetLastResultIdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetLastResultIdResponse*>(p->ptr), _ns2__GetLastResultIdResponse);
		break;
	case SOAP_TYPE__ns2__GetResultsSinceId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetResultsSinceId*>(p->ptr), _ns2__GetResultsSinceId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetResultsSinceId*>(p->ptr), _ns2__GetResultsSinceId);
		break;
	case SOAP_TYPE__ns2__GetResultsSinceIdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetResultsSinceIdResponse*>(p->ptr), _ns2__GetResultsSinceIdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetResultsSinceIdResponse*>(p->ptr), _ns2__GetResultsSinceIdResponse);
		break;
	case SOAP_TYPE__ns2__GetEvents:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetEvents*>(p->ptr), _ns2__GetEvents);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetEvents*>(p->ptr), _ns2__GetEvents);
		break;
	case SOAP_TYPE__ns2__GetEventsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetEventsResponse*>(p->ptr), _ns2__GetEventsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetEventsResponse*>(p->ptr), _ns2__GetEventsResponse);
		break;
	case SOAP_TYPE__ns2__GetLastEventId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetLastEventId*>(p->ptr), _ns2__GetLastEventId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetLastEventId*>(p->ptr), _ns2__GetLastEventId);
		break;
	case SOAP_TYPE__ns2__GetLastEventIdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetLastEventIdResponse*>(p->ptr), _ns2__GetLastEventIdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetLastEventIdResponse*>(p->ptr), _ns2__GetLastEventIdResponse);
		break;
	case SOAP_TYPE__ns2__GetEventsSinceId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetEventsSinceId*>(p->ptr), _ns2__GetEventsSinceId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetEventsSinceId*>(p->ptr), _ns2__GetEventsSinceId);
		break;
	case SOAP_TYPE__ns2__GetEventsSinceIdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns2__GetEventsSinceIdResponse*>(p->ptr), _ns2__GetEventsSinceIdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns2__GetEventsSinceIdResponse*>(p->ptr), _ns2__GetEventsSinceIdResponse);
		break;
	case SOAP_TYPE_ns3__ProcessingInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ProcessingInfo*>(p->ptr), ns3__ProcessingInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ProcessingInfo*>(p->ptr), ns3__ProcessingInfo);
		break;
	case SOAP_TYPE_ns3__OperationProcInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__OperationProcInfo*>(p->ptr), ns3__OperationProcInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__OperationProcInfo*>(p->ptr), ns3__OperationProcInfo);
		break;
	case SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfOperationProcInfo_x002eControlParamInfo*>(p->ptr), ns3__ArrayOfOperationProcInfo_x002eControlParamInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfOperationProcInfo_x002eControlParamInfo*>(p->ptr), ns3__ArrayOfOperationProcInfo_x002eControlParamInfo);
		break;
	case SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__OperationProcInfo_x002eControlParamInfo*>(p->ptr), ns3__OperationProcInfo_x002eControlParamInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__OperationProcInfo_x002eControlParamInfo*>(p->ptr), ns3__OperationProcInfo_x002eControlParamInfo);
		break;
	case SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo*>(p->ptr), ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo*>(p->ptr), ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo);
		break;
	case SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__OperationProcInfo_x002eOperationStepInfo*>(p->ptr), ns3__OperationProcInfo_x002eOperationStepInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__OperationProcInfo_x002eOperationStepInfo*>(p->ptr), ns3__OperationProcInfo_x002eOperationStepInfo);
		break;
	case SOAP_TYPE_ns4__ArrayOfAutoPlanItem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__ArrayOfAutoPlanItem*>(p->ptr), ns4__ArrayOfAutoPlanItem);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__ArrayOfAutoPlanItem*>(p->ptr), ns4__ArrayOfAutoPlanItem);
		break;
	case SOAP_TYPE_ns4__AutoPlanItem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__AutoPlanItem*>(p->ptr), ns4__AutoPlanItem);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__AutoPlanItem*>(p->ptr), ns4__AutoPlanItem);
		break;
	case SOAP_TYPE_ns4__Periodicity:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__Periodicity*>(p->ptr), ns4__Periodicity);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__Periodicity*>(p->ptr), ns4__Periodicity);
		break;
	case SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__ArrayOfPeriodicity_x002eTime*>(p->ptr), ns4__ArrayOfPeriodicity_x002eTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__ArrayOfPeriodicity_x002eTime*>(p->ptr), ns4__ArrayOfPeriodicity_x002eTime);
		break;
	case SOAP_TYPE_ns4__Periodicity_x002eTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__Periodicity_x002eTime*>(p->ptr), ns4__Periodicity_x002eTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__Periodicity_x002eTime*>(p->ptr), ns4__Periodicity_x002eTime);
		break;
	case SOAP_TYPE_ns4__ArrayOfControlledParametr:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__ArrayOfControlledParametr*>(p->ptr), ns4__ArrayOfControlledParametr);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__ArrayOfControlledParametr*>(p->ptr), ns4__ArrayOfControlledParametr);
		break;
	case SOAP_TYPE_ns4__ControlledParametr:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__ControlledParametr*>(p->ptr), ns4__ControlledParametr);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__ControlledParametr*>(p->ptr), ns4__ControlledParametr);
		break;
	case SOAP_TYPE_ns4__ArrayOfMeasuringComponent:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__ArrayOfMeasuringComponent*>(p->ptr), ns4__ArrayOfMeasuringComponent);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__ArrayOfMeasuringComponent*>(p->ptr), ns4__ArrayOfMeasuringComponent);
		break;
	case SOAP_TYPE_ns4__MeasuringComponent:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__MeasuringComponent*>(p->ptr), ns4__MeasuringComponent);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__MeasuringComponent*>(p->ptr), ns4__MeasuringComponent);
		break;
	case SOAP_TYPE_ns4__ArrayOfOperation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__ArrayOfOperation*>(p->ptr), ns4__ArrayOfOperation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__ArrayOfOperation*>(p->ptr), ns4__ArrayOfOperation);
		break;
	case SOAP_TYPE_ns4__Operation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__Operation*>(p->ptr), ns4__Operation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__Operation*>(p->ptr), ns4__Operation);
		break;
	case SOAP_TYPE_ns4__ArrayOfOperationStep:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__ArrayOfOperationStep*>(p->ptr), ns4__ArrayOfOperationStep);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__ArrayOfOperationStep*>(p->ptr), ns4__ArrayOfOperationStep);
		break;
	case SOAP_TYPE_ns4__OperationStep:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__OperationStep*>(p->ptr), ns4__OperationStep);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__OperationStep*>(p->ptr), ns4__OperationStep);
		break;
	case SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__ArrayOfOperationStep_x002eUsingControlledParametr*>(p->ptr), ns4__ArrayOfOperationStep_x002eUsingControlledParametr);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__ArrayOfOperationStep_x002eUsingControlledParametr*>(p->ptr), ns4__ArrayOfOperationStep_x002eUsingControlledParametr);
		break;
	case SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns4__OperationStep_x002eUsingControlledParametr*>(p->ptr), ns4__OperationStep_x002eUsingControlledParametr);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns4__OperationStep_x002eUsingControlledParametr*>(p->ptr), ns4__OperationStep_x002eUsingControlledParametr);
		break;
	case SOAP_TYPE_arr__ArrayOfstring:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<arr__ArrayOfstring*>(p->ptr), arr__ArrayOfstring);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<arr__ArrayOfstring*>(p->ptr), arr__ArrayOfstring);
		break;
	case SOAP_TYPE_arr__ArrayOfboolean:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<arr__ArrayOfboolean*>(p->ptr), arr__ArrayOfboolean);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<arr__ArrayOfboolean*>(p->ptr), arr__ArrayOfboolean);
		break;
	case SOAP_TYPE_ns5__SystemConfigurations:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns5__SystemConfigurations*>(p->ptr), ns5__SystemConfigurations);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns5__SystemConfigurations*>(p->ptr), ns5__SystemConfigurations);
		break;
	case SOAP_TYPE_ns6__Aux2Config:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns6__Aux2Config*>(p->ptr), ns6__Aux2Config);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns6__Aux2Config*>(p->ptr), ns6__Aux2Config);
		break;
	case SOAP_TYPE_ns7__AuxControllerConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns7__AuxControllerConfiguration*>(p->ptr), ns7__AuxControllerConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns7__AuxControllerConfiguration*>(p->ptr), ns7__AuxControllerConfiguration);
		break;
	case SOAP_TYPE_ns7__ArrayOfAuxDevice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns7__ArrayOfAuxDevice*>(p->ptr), ns7__ArrayOfAuxDevice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns7__ArrayOfAuxDevice*>(p->ptr), ns7__ArrayOfAuxDevice);
		break;
	case SOAP_TYPE_ns7__AuxDevice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns7__AuxDevice*>(p->ptr), ns7__AuxDevice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns7__AuxDevice*>(p->ptr), ns7__AuxDevice);
		break;
	case SOAP_TYPE_ns7__ArrayOfAuxDeviceState:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns7__ArrayOfAuxDeviceState*>(p->ptr), ns7__ArrayOfAuxDeviceState);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns7__ArrayOfAuxDeviceState*>(p->ptr), ns7__ArrayOfAuxDeviceState);
		break;
	case SOAP_TYPE_ns7__AuxDeviceState:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns7__AuxDeviceState*>(p->ptr), ns7__AuxDeviceState);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns7__AuxDeviceState*>(p->ptr), ns7__AuxDeviceState);
		break;
	case SOAP_TYPE_ns10__ArrayOfESample:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns10__ArrayOfESample*>(p->ptr), ns10__ArrayOfESample);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns10__ArrayOfESample*>(p->ptr), ns10__ArrayOfESample);
		break;
	case SOAP_TYPE_ns10__ESample:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns10__ESample*>(p->ptr), ns10__ESample);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns10__ESample*>(p->ptr), ns10__ESample);
		break;
	case SOAP_TYPE_ns10__ArrayOfEResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns10__ArrayOfEResult*>(p->ptr), ns10__ArrayOfEResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns10__ArrayOfEResult*>(p->ptr), ns10__ArrayOfEResult);
		break;
	case SOAP_TYPE_ns10__EResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns10__EResult*>(p->ptr), ns10__EResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns10__EResult*>(p->ptr), ns10__EResult);
		break;
	case SOAP_TYPE_ns10__ArrayOfEEvent:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns10__ArrayOfEEvent*>(p->ptr), ns10__ArrayOfEEvent);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns10__ArrayOfEEvent*>(p->ptr), ns10__ArrayOfEEvent);
		break;
	case SOAP_TYPE_ns10__EEvent:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns10__EEvent*>(p->ptr), ns10__EEvent);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns10__EEvent*>(p->ptr), ns10__EEvent);
		break;
	case SOAP_TYPE___tempuri__StartAutoPlan:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__StartAutoPlan*>(p->ptr), struct __tempuri__StartAutoPlan);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__StartAutoPlan*>(p->ptr), struct __tempuri__StartAutoPlan);
		break;
	case SOAP_TYPE___tempuri__StartOperation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__StartOperation*>(p->ptr), struct __tempuri__StartOperation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__StartOperation*>(p->ptr), struct __tempuri__StartOperation);
		break;
	case SOAP_TYPE___tempuri__StopAnalyzing:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__StopAnalyzing*>(p->ptr), struct __tempuri__StopAnalyzing);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__StopAnalyzing*>(p->ptr), struct __tempuri__StopAnalyzing);
		break;
	case SOAP_TYPE___tempuri__AbortAnalyzing:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__AbortAnalyzing*>(p->ptr), struct __tempuri__AbortAnalyzing);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__AbortAnalyzing*>(p->ptr), struct __tempuri__AbortAnalyzing);
		break;
	case SOAP_TYPE___tempuri__GetProcessingInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetProcessingInfo*>(p->ptr), struct __tempuri__GetProcessingInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetProcessingInfo*>(p->ptr), struct __tempuri__GetProcessingInfo);
		break;
	case SOAP_TYPE___tempuri__SetIgnoreClearing:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__SetIgnoreClearing*>(p->ptr), struct __tempuri__SetIgnoreClearing);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__SetIgnoreClearing*>(p->ptr), struct __tempuri__SetIgnoreClearing);
		break;
	case SOAP_TYPE___tempuri__GetSystemConfigurations:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetSystemConfigurations*>(p->ptr), struct __tempuri__GetSystemConfigurations);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetSystemConfigurations*>(p->ptr), struct __tempuri__GetSystemConfigurations);
		break;
	case SOAP_TYPE___tempuri__SetSystemConfigurations:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__SetSystemConfigurations*>(p->ptr), struct __tempuri__SetSystemConfigurations);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__SetSystemConfigurations*>(p->ptr), struct __tempuri__SetSystemConfigurations);
		break;
	case SOAP_TYPE___tempuri__GetResults:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetResults*>(p->ptr), struct __tempuri__GetResults);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetResults*>(p->ptr), struct __tempuri__GetResults);
		break;
	case SOAP_TYPE___tempuri__GetLastResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetLastResult*>(p->ptr), struct __tempuri__GetLastResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetLastResult*>(p->ptr), struct __tempuri__GetLastResult);
		break;
	case SOAP_TYPE___tempuri__GetLastResultId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetLastResultId*>(p->ptr), struct __tempuri__GetLastResultId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetLastResultId*>(p->ptr), struct __tempuri__GetLastResultId);
		break;
	case SOAP_TYPE___tempuri__GetResultsSinceId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetResultsSinceId*>(p->ptr), struct __tempuri__GetResultsSinceId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetResultsSinceId*>(p->ptr), struct __tempuri__GetResultsSinceId);
		break;
	case SOAP_TYPE___tempuri__GetEvents:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetEvents*>(p->ptr), struct __tempuri__GetEvents);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetEvents*>(p->ptr), struct __tempuri__GetEvents);
		break;
	case SOAP_TYPE___tempuri__GetLastEventId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetLastEventId*>(p->ptr), struct __tempuri__GetLastEventId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetLastEventId*>(p->ptr), struct __tempuri__GetLastEventId);
		break;
	case SOAP_TYPE___tempuri__GetEventsSinceId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tempuri__GetEventsSinceId*>(p->ptr), struct __tempuri__GetEventsSinceId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tempuri__GetEventsSinceId*>(p->ptr), struct __tempuri__GetEventsSinceId);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct chan__ChannelInstanceType*>(p->ptr), struct chan__ChannelInstanceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct chan__ChannelInstanceType*>(p->ptr), struct chan__ChannelInstanceType);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__From:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons10__EEvent:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns10__EEvent *> *>(p->ptr), std::vector<ns10__EEvent *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns10__EEvent *> *>(p->ptr), std::vector<ns10__EEvent *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons10__EResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns10__EResult *> *>(p->ptr), std::vector<ns10__EResult *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns10__EResult *> *>(p->ptr), std::vector<ns10__EResult *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons10__ESample:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns10__ESample *> *>(p->ptr), std::vector<ns10__ESample *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns10__ESample *> *>(p->ptr), std::vector<ns10__ESample *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__AuxDeviceState:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns7__AuxDeviceState *> *>(p->ptr), std::vector<ns7__AuxDeviceState *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns7__AuxDeviceState *> *>(p->ptr), std::vector<ns7__AuxDeviceState *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__AuxDevice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns7__AuxDevice *> *>(p->ptr), std::vector<ns7__AuxDevice *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns7__AuxDevice *> *>(p->ptr), std::vector<ns7__AuxDevice *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfbool:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<bool> *>(p->ptr), std::vector<bool> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<bool> *>(p->ptr), std::vector<bool> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns4__OperationStep_x002eUsingControlledParametr *> *>(p->ptr), std::vector<ns4__OperationStep_x002eUsingControlledParametr *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns4__OperationStep_x002eUsingControlledParametr *> *>(p->ptr), std::vector<ns4__OperationStep_x002eUsingControlledParametr *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__OperationStep:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns4__OperationStep *> *>(p->ptr), std::vector<ns4__OperationStep *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns4__OperationStep *> *>(p->ptr), std::vector<ns4__OperationStep *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Operation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns4__Operation *> *>(p->ptr), std::vector<ns4__Operation *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns4__Operation *> *>(p->ptr), std::vector<ns4__Operation *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__MeasuringComponent:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns4__MeasuringComponent *> *>(p->ptr), std::vector<ns4__MeasuringComponent *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns4__MeasuringComponent *> *>(p->ptr), std::vector<ns4__MeasuringComponent *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__ControlledParametr:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns4__ControlledParametr *> *>(p->ptr), std::vector<ns4__ControlledParametr *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns4__ControlledParametr *> *>(p->ptr), std::vector<ns4__ControlledParametr *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns4__Periodicity_x002eTime *> *>(p->ptr), std::vector<ns4__Periodicity_x002eTime *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns4__Periodicity_x002eTime *> *>(p->ptr), std::vector<ns4__Periodicity_x002eTime *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__AutoPlanItem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns4__AutoPlanItem *> *>(p->ptr), std::vector<ns4__AutoPlanItem *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns4__AutoPlanItem *> *>(p->ptr), std::vector<ns4__AutoPlanItem *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> *>(p->ptr), std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> *>(p->ptr), std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> *>(p->ptr), std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> *>(p->ptr), std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons10__EEvent:
		if (t == SOAP_TYPE_ns10__EEvent || soap_fbase(t, SOAP_TYPE_ns10__EEvent))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns10__EEvent *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns10__EEvent *> *)p)[index] = *(ns10__EEvent **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons10__EResult:
		if (t == SOAP_TYPE_ns10__EResult || soap_fbase(t, SOAP_TYPE_ns10__EResult))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns10__EResult *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns10__EResult *> *)p)[index] = *(ns10__EResult **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons10__ESample:
		if (t == SOAP_TYPE_ns10__ESample || soap_fbase(t, SOAP_TYPE_ns10__ESample))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns10__ESample *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns10__ESample *> *)p)[index] = *(ns10__ESample **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__AuxDeviceState:
		if (t == SOAP_TYPE_ns7__AuxDeviceState || soap_fbase(t, SOAP_TYPE_ns7__AuxDeviceState))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns7__AuxDeviceState *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns7__AuxDeviceState *> *)p)[index] = *(ns7__AuxDeviceState **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__AuxDevice:
		if (t == SOAP_TYPE_ns7__AuxDevice || soap_fbase(t, SOAP_TYPE_ns7__AuxDevice))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns7__AuxDevice *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns7__AuxDevice *> *)p)[index] = *(ns7__AuxDevice **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfbool:
		if (t == SOAP_TYPE_bool)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<bool>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<bool> *)p)[index] = *(bool *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (t == SOAP_TYPE_std__string)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr:
		if (t == SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr || soap_fbase(t, SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns4__OperationStep_x002eUsingControlledParametr *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns4__OperationStep_x002eUsingControlledParametr *> *)p)[index] = *(ns4__OperationStep_x002eUsingControlledParametr **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__OperationStep:
		if (t == SOAP_TYPE_ns4__OperationStep || soap_fbase(t, SOAP_TYPE_ns4__OperationStep))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns4__OperationStep *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns4__OperationStep *> *)p)[index] = *(ns4__OperationStep **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Operation:
		if (t == SOAP_TYPE_ns4__Operation || soap_fbase(t, SOAP_TYPE_ns4__Operation))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns4__Operation *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns4__Operation *> *)p)[index] = *(ns4__Operation **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__MeasuringComponent:
		if (t == SOAP_TYPE_ns4__MeasuringComponent || soap_fbase(t, SOAP_TYPE_ns4__MeasuringComponent))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns4__MeasuringComponent *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns4__MeasuringComponent *> *)p)[index] = *(ns4__MeasuringComponent **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__ControlledParametr:
		if (t == SOAP_TYPE_ns4__ControlledParametr || soap_fbase(t, SOAP_TYPE_ns4__ControlledParametr))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns4__ControlledParametr *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns4__ControlledParametr *> *)p)[index] = *(ns4__ControlledParametr **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime:
		if (t == SOAP_TYPE_ns4__Periodicity_x002eTime || soap_fbase(t, SOAP_TYPE_ns4__Periodicity_x002eTime))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns4__Periodicity_x002eTime *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns4__Periodicity_x002eTime *> *)p)[index] = *(ns4__Periodicity_x002eTime **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__AutoPlanItem:
		if (t == SOAP_TYPE_ns4__AutoPlanItem || soap_fbase(t, SOAP_TYPE_ns4__AutoPlanItem))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns4__AutoPlanItem *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns4__AutoPlanItem *> *)p)[index] = *(ns4__AutoPlanItem **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo:
		if (t == SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo || soap_fbase(t, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> *)p)[index] = *(ns3__OperationProcInfo_x002eOperationStepInfo **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo:
		if (t == SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo || soap_fbase(t, SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__OperationProcInfo_x002eControlParamInfo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> *)p)[index] = *(ns3__OperationProcInfo_x002eControlParamInfo **)q;
		}
		break;
	case SOAP_TYPE___ser__anyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ser__anyType type=%d location=%p object=%p\n", t, p, q));
		*(struct __ser__anyType*)p = *(struct __ser__anyType*)q;
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__ns2__StartAutoPlan:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__StartAutoPlan type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__StartAutoPlan*)p = *(_ns2__StartAutoPlan*)q;
		break;
	case SOAP_TYPE__ns2__StartAutoPlanResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__StartAutoPlanResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__StartAutoPlanResponse*)p = *(_ns2__StartAutoPlanResponse*)q;
		break;
	case SOAP_TYPE__ns2__StartOperation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__StartOperation type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__StartOperation*)p = *(_ns2__StartOperation*)q;
		break;
	case SOAP_TYPE__ns2__StartOperationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__StartOperationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__StartOperationResponse*)p = *(_ns2__StartOperationResponse*)q;
		break;
	case SOAP_TYPE__ns2__StopAnalyzing:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__StopAnalyzing type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__StopAnalyzing*)p = *(_ns2__StopAnalyzing*)q;
		break;
	case SOAP_TYPE__ns2__StopAnalyzingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__StopAnalyzingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__StopAnalyzingResponse*)p = *(_ns2__StopAnalyzingResponse*)q;
		break;
	case SOAP_TYPE__ns2__AbortAnalyzing:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__AbortAnalyzing type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__AbortAnalyzing*)p = *(_ns2__AbortAnalyzing*)q;
		break;
	case SOAP_TYPE__ns2__AbortAnalyzingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__AbortAnalyzingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__AbortAnalyzingResponse*)p = *(_ns2__AbortAnalyzingResponse*)q;
		break;
	case SOAP_TYPE__ns2__GetProcessingInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetProcessingInfo type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetProcessingInfo*)p = *(_ns2__GetProcessingInfo*)q;
		break;
	case SOAP_TYPE__ns2__GetProcessingInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetProcessingInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetProcessingInfoResponse*)p = *(_ns2__GetProcessingInfoResponse*)q;
		break;
	case SOAP_TYPE__ns2__SetIgnoreClearing:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__SetIgnoreClearing type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__SetIgnoreClearing*)p = *(_ns2__SetIgnoreClearing*)q;
		break;
	case SOAP_TYPE__ns2__SetIgnoreClearingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__SetIgnoreClearingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__SetIgnoreClearingResponse*)p = *(_ns2__SetIgnoreClearingResponse*)q;
		break;
	case SOAP_TYPE__ns2__GetSystemConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetSystemConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetSystemConfigurations*)p = *(_ns2__GetSystemConfigurations*)q;
		break;
	case SOAP_TYPE__ns2__GetSystemConfigurationsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetSystemConfigurationsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetSystemConfigurationsResponse*)p = *(_ns2__GetSystemConfigurationsResponse*)q;
		break;
	case SOAP_TYPE__ns2__SetSystemConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__SetSystemConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__SetSystemConfigurations*)p = *(_ns2__SetSystemConfigurations*)q;
		break;
	case SOAP_TYPE__ns2__SetSystemConfigurationsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__SetSystemConfigurationsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__SetSystemConfigurationsResponse*)p = *(_ns2__SetSystemConfigurationsResponse*)q;
		break;
	case SOAP_TYPE__ns2__GetResults:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetResults type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetResults*)p = *(_ns2__GetResults*)q;
		break;
	case SOAP_TYPE__ns2__GetResultsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetResultsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetResultsResponse*)p = *(_ns2__GetResultsResponse*)q;
		break;
	case SOAP_TYPE__ns2__GetLastResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetLastResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetLastResult*)p = *(_ns2__GetLastResult*)q;
		break;
	case SOAP_TYPE__ns2__GetLastResultResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetLastResultResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetLastResultResponse*)p = *(_ns2__GetLastResultResponse*)q;
		break;
	case SOAP_TYPE__ns2__GetLastResultId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetLastResultId type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetLastResultId*)p = *(_ns2__GetLastResultId*)q;
		break;
	case SOAP_TYPE__ns2__GetLastResultIdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetLastResultIdResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetLastResultIdResponse*)p = *(_ns2__GetLastResultIdResponse*)q;
		break;
	case SOAP_TYPE__ns2__GetResultsSinceId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetResultsSinceId type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetResultsSinceId*)p = *(_ns2__GetResultsSinceId*)q;
		break;
	case SOAP_TYPE__ns2__GetResultsSinceIdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetResultsSinceIdResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetResultsSinceIdResponse*)p = *(_ns2__GetResultsSinceIdResponse*)q;
		break;
	case SOAP_TYPE__ns2__GetEvents:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetEvents type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetEvents*)p = *(_ns2__GetEvents*)q;
		break;
	case SOAP_TYPE__ns2__GetEventsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetEventsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetEventsResponse*)p = *(_ns2__GetEventsResponse*)q;
		break;
	case SOAP_TYPE__ns2__GetLastEventId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetLastEventId type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetLastEventId*)p = *(_ns2__GetLastEventId*)q;
		break;
	case SOAP_TYPE__ns2__GetLastEventIdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetLastEventIdResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetLastEventIdResponse*)p = *(_ns2__GetLastEventIdResponse*)q;
		break;
	case SOAP_TYPE__ns2__GetEventsSinceId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetEventsSinceId type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetEventsSinceId*)p = *(_ns2__GetEventsSinceId*)q;
		break;
	case SOAP_TYPE__ns2__GetEventsSinceIdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__GetEventsSinceIdResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__GetEventsSinceIdResponse*)p = *(_ns2__GetEventsSinceIdResponse*)q;
		break;
	case SOAP_TYPE_ns3__ProcessingInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ProcessingInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ProcessingInfo*)p = *(ns3__ProcessingInfo*)q;
		break;
	case SOAP_TYPE_ns3__OperationProcInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__OperationProcInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__OperationProcInfo*)p = *(ns3__OperationProcInfo*)q;
		break;
	case SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfOperationProcInfo_x002eControlParamInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfOperationProcInfo_x002eControlParamInfo*)p = *(ns3__ArrayOfOperationProcInfo_x002eControlParamInfo*)q;
		break;
	case SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__OperationProcInfo_x002eControlParamInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__OperationProcInfo_x002eControlParamInfo*)p = *(ns3__OperationProcInfo_x002eControlParamInfo*)q;
		break;
	case SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo*)p = *(ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo*)q;
		break;
	case SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__OperationProcInfo_x002eOperationStepInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__OperationProcInfo_x002eOperationStepInfo*)p = *(ns3__OperationProcInfo_x002eOperationStepInfo*)q;
		break;
	case SOAP_TYPE_ns4__ArrayOfAutoPlanItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__ArrayOfAutoPlanItem type=%d location=%p object=%p\n", t, p, q));
		*(ns4__ArrayOfAutoPlanItem*)p = *(ns4__ArrayOfAutoPlanItem*)q;
		break;
	case SOAP_TYPE_ns4__AutoPlanItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__AutoPlanItem type=%d location=%p object=%p\n", t, p, q));
		*(ns4__AutoPlanItem*)p = *(ns4__AutoPlanItem*)q;
		break;
	case SOAP_TYPE_ns4__Periodicity:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__Periodicity type=%d location=%p object=%p\n", t, p, q));
		*(ns4__Periodicity*)p = *(ns4__Periodicity*)q;
		break;
	case SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__ArrayOfPeriodicity_x002eTime type=%d location=%p object=%p\n", t, p, q));
		*(ns4__ArrayOfPeriodicity_x002eTime*)p = *(ns4__ArrayOfPeriodicity_x002eTime*)q;
		break;
	case SOAP_TYPE_ns4__Periodicity_x002eTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__Periodicity_x002eTime type=%d location=%p object=%p\n", t, p, q));
		*(ns4__Periodicity_x002eTime*)p = *(ns4__Periodicity_x002eTime*)q;
		break;
	case SOAP_TYPE_ns4__ArrayOfControlledParametr:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__ArrayOfControlledParametr type=%d location=%p object=%p\n", t, p, q));
		*(ns4__ArrayOfControlledParametr*)p = *(ns4__ArrayOfControlledParametr*)q;
		break;
	case SOAP_TYPE_ns4__ControlledParametr:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__ControlledParametr type=%d location=%p object=%p\n", t, p, q));
		*(ns4__ControlledParametr*)p = *(ns4__ControlledParametr*)q;
		break;
	case SOAP_TYPE_ns4__ArrayOfMeasuringComponent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__ArrayOfMeasuringComponent type=%d location=%p object=%p\n", t, p, q));
		*(ns4__ArrayOfMeasuringComponent*)p = *(ns4__ArrayOfMeasuringComponent*)q;
		break;
	case SOAP_TYPE_ns4__MeasuringComponent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__MeasuringComponent type=%d location=%p object=%p\n", t, p, q));
		*(ns4__MeasuringComponent*)p = *(ns4__MeasuringComponent*)q;
		break;
	case SOAP_TYPE_ns4__ArrayOfOperation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__ArrayOfOperation type=%d location=%p object=%p\n", t, p, q));
		*(ns4__ArrayOfOperation*)p = *(ns4__ArrayOfOperation*)q;
		break;
	case SOAP_TYPE_ns4__Operation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__Operation type=%d location=%p object=%p\n", t, p, q));
		*(ns4__Operation*)p = *(ns4__Operation*)q;
		break;
	case SOAP_TYPE_ns4__ArrayOfOperationStep:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__ArrayOfOperationStep type=%d location=%p object=%p\n", t, p, q));
		*(ns4__ArrayOfOperationStep*)p = *(ns4__ArrayOfOperationStep*)q;
		break;
	case SOAP_TYPE_ns4__OperationStep:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__OperationStep type=%d location=%p object=%p\n", t, p, q));
		*(ns4__OperationStep*)p = *(ns4__OperationStep*)q;
		break;
	case SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__ArrayOfOperationStep_x002eUsingControlledParametr type=%d location=%p object=%p\n", t, p, q));
		*(ns4__ArrayOfOperationStep_x002eUsingControlledParametr*)p = *(ns4__ArrayOfOperationStep_x002eUsingControlledParametr*)q;
		break;
	case SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__OperationStep_x002eUsingControlledParametr type=%d location=%p object=%p\n", t, p, q));
		*(ns4__OperationStep_x002eUsingControlledParametr*)p = *(ns4__OperationStep_x002eUsingControlledParametr*)q;
		break;
	case SOAP_TYPE_arr__ArrayOfstring:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy arr__ArrayOfstring type=%d location=%p object=%p\n", t, p, q));
		*(arr__ArrayOfstring*)p = *(arr__ArrayOfstring*)q;
		break;
	case SOAP_TYPE_arr__ArrayOfboolean:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy arr__ArrayOfboolean type=%d location=%p object=%p\n", t, p, q));
		*(arr__ArrayOfboolean*)p = *(arr__ArrayOfboolean*)q;
		break;
	case SOAP_TYPE_ns5__SystemConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SystemConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SystemConfigurations*)p = *(ns5__SystemConfigurations*)q;
		break;
	case SOAP_TYPE_ns6__Aux2Config:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__Aux2Config type=%d location=%p object=%p\n", t, p, q));
		*(ns6__Aux2Config*)p = *(ns6__Aux2Config*)q;
		break;
	case SOAP_TYPE_ns7__AuxControllerConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__AuxControllerConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(ns7__AuxControllerConfiguration*)p = *(ns7__AuxControllerConfiguration*)q;
		break;
	case SOAP_TYPE_ns7__ArrayOfAuxDevice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__ArrayOfAuxDevice type=%d location=%p object=%p\n", t, p, q));
		*(ns7__ArrayOfAuxDevice*)p = *(ns7__ArrayOfAuxDevice*)q;
		break;
	case SOAP_TYPE_ns7__AuxDevice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__AuxDevice type=%d location=%p object=%p\n", t, p, q));
		*(ns7__AuxDevice*)p = *(ns7__AuxDevice*)q;
		break;
	case SOAP_TYPE_ns7__ArrayOfAuxDeviceState:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__ArrayOfAuxDeviceState type=%d location=%p object=%p\n", t, p, q));
		*(ns7__ArrayOfAuxDeviceState*)p = *(ns7__ArrayOfAuxDeviceState*)q;
		break;
	case SOAP_TYPE_ns7__AuxDeviceState:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__AuxDeviceState type=%d location=%p object=%p\n", t, p, q));
		*(ns7__AuxDeviceState*)p = *(ns7__AuxDeviceState*)q;
		break;
	case SOAP_TYPE_ns10__ArrayOfESample:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns10__ArrayOfESample type=%d location=%p object=%p\n", t, p, q));
		*(ns10__ArrayOfESample*)p = *(ns10__ArrayOfESample*)q;
		break;
	case SOAP_TYPE_ns10__ESample:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns10__ESample type=%d location=%p object=%p\n", t, p, q));
		*(ns10__ESample*)p = *(ns10__ESample*)q;
		break;
	case SOAP_TYPE_ns10__ArrayOfEResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns10__ArrayOfEResult type=%d location=%p object=%p\n", t, p, q));
		*(ns10__ArrayOfEResult*)p = *(ns10__ArrayOfEResult*)q;
		break;
	case SOAP_TYPE_ns10__EResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns10__EResult type=%d location=%p object=%p\n", t, p, q));
		*(ns10__EResult*)p = *(ns10__EResult*)q;
		break;
	case SOAP_TYPE_ns10__ArrayOfEEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns10__ArrayOfEEvent type=%d location=%p object=%p\n", t, p, q));
		*(ns10__ArrayOfEEvent*)p = *(ns10__ArrayOfEEvent*)q;
		break;
	case SOAP_TYPE_ns10__EEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns10__EEvent type=%d location=%p object=%p\n", t, p, q));
		*(ns10__EEvent*)p = *(ns10__EEvent*)q;
		break;
	case SOAP_TYPE___tempuri__StartAutoPlan:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__StartAutoPlan type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__StartAutoPlan*)p = *(struct __tempuri__StartAutoPlan*)q;
		break;
	case SOAP_TYPE___tempuri__StartOperation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__StartOperation type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__StartOperation*)p = *(struct __tempuri__StartOperation*)q;
		break;
	case SOAP_TYPE___tempuri__StopAnalyzing:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__StopAnalyzing type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__StopAnalyzing*)p = *(struct __tempuri__StopAnalyzing*)q;
		break;
	case SOAP_TYPE___tempuri__AbortAnalyzing:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AbortAnalyzing type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AbortAnalyzing*)p = *(struct __tempuri__AbortAnalyzing*)q;
		break;
	case SOAP_TYPE___tempuri__GetProcessingInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetProcessingInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetProcessingInfo*)p = *(struct __tempuri__GetProcessingInfo*)q;
		break;
	case SOAP_TYPE___tempuri__SetIgnoreClearing:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__SetIgnoreClearing type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__SetIgnoreClearing*)p = *(struct __tempuri__SetIgnoreClearing*)q;
		break;
	case SOAP_TYPE___tempuri__GetSystemConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetSystemConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetSystemConfigurations*)p = *(struct __tempuri__GetSystemConfigurations*)q;
		break;
	case SOAP_TYPE___tempuri__SetSystemConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__SetSystemConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__SetSystemConfigurations*)p = *(struct __tempuri__SetSystemConfigurations*)q;
		break;
	case SOAP_TYPE___tempuri__GetResults:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetResults type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetResults*)p = *(struct __tempuri__GetResults*)q;
		break;
	case SOAP_TYPE___tempuri__GetLastResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetLastResult type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetLastResult*)p = *(struct __tempuri__GetLastResult*)q;
		break;
	case SOAP_TYPE___tempuri__GetLastResultId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetLastResultId type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetLastResultId*)p = *(struct __tempuri__GetLastResultId*)q;
		break;
	case SOAP_TYPE___tempuri__GetResultsSinceId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetResultsSinceId type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetResultsSinceId*)p = *(struct __tempuri__GetResultsSinceId*)q;
		break;
	case SOAP_TYPE___tempuri__GetEvents:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetEvents type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetEvents*)p = *(struct __tempuri__GetEvents*)q;
		break;
	case SOAP_TYPE___tempuri__GetLastEventId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetLastEventId type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetLastEventId*)p = *(struct __tempuri__GetLastEventId*)q;
		break;
	case SOAP_TYPE___tempuri__GetEventsSinceId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__GetEventsSinceId type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__GetEventsSinceId*)p = *(struct __tempuri__GetEventsSinceId*)q;
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ReferenceParametersType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__MetadataType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ProblemActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__RelatesToType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct chan__ChannelInstanceType type=%d location=%p object=%p\n", t, p, q));
		*(struct chan__ChannelInstanceType*)p = *(struct chan__ChannelInstanceType*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__decimal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ReferenceParametersType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
		break;
	case SOAP_TYPE__wsa5__Metadata:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__MetadataType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__RelatesToType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__From:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ProblemActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return a;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_new_LONG64(struct soap *soap, int n)
{
	LONG64 *a = static_cast<LONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(LONG64)));
	for (LONG64 *p = a; p && n--; ++p)
		soap_default_LONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_LONG64(soap, tag ? tag : "long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return a;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_new_double(struct soap *soap, int n)
{
	double *a = static_cast<double *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(double)));
	for (double *p = a; p && n--; ++p)
		soap_default_double(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_xsd__unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_xsd__unsignedByte);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_xsd__unsignedByte(soap, tag ? tag : "xsd:unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_xsd__unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return a;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_new_unsignedByte(struct soap *soap, int n)
{
	unsigned char *a = static_cast<unsigned char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned char)));
	for (unsigned char *p = a; p && n--; ++p)
		soap_default_unsignedByte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_unsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *a = static_cast<unsigned int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned int)));
	for (unsigned int *p = a; p && n--; ++p)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RetryAfter(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RetryAfter(soap, tag ? tag : "wsa5:RetryAfter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ULONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_ULONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_ULONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	a = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_ULONG64);
	return a;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_new_ULONG64(struct soap *soap, int n)
{
	ULONG64 *a = static_cast<ULONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(ULONG64)));
	for (ULONG64 *p = a; p && n--; ++p)
		soap_default_ULONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ULONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out_ULONG64(soap, tag ? tag : "unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_ULONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] =
{	{ (LONG64)_wsa5__IsReferenceParameter__false, "false" },
	{ (LONG64)_wsa5__IsReferenceParameter__true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n)
{
	const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__wsa5__IsReferenceParameter, s);
	if (map)
		*a = (enum _wsa5__IsReferenceParameter)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _wsa5__IsReferenceParameter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _wsa5__IsReferenceParameter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_new__wsa5__IsReferenceParameter(struct soap *soap, int n)
{
	enum _wsa5__IsReferenceParameter *a = static_cast<enum _wsa5__IsReferenceParameter *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum _wsa5__IsReferenceParameter)));
	for (enum _wsa5__IsReferenceParameter *p = a; p && n--; ++p)
		soap_default__wsa5__IsReferenceParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__IsReferenceParameter(soap, tag ? tag : "wsa5:IsReferenceParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__FaultCodesType[] =
{	{ (LONG64)wsa5__InvalidAddressingHeader, "wsa5:InvalidAddressingHeader" },
	{ (LONG64)wsa5__InvalidAddress, "wsa5:InvalidAddress" },
	{ (LONG64)wsa5__InvalidEPR, "wsa5:InvalidEPR" },
	{ (LONG64)wsa5__InvalidCardinality, "wsa5:InvalidCardinality" },
	{ (LONG64)wsa5__MissingAddressInEPR, "wsa5:MissingAddressInEPR" },
	{ (LONG64)wsa5__DuplicateMessageID, "wsa5:DuplicateMessageID" },
	{ (LONG64)wsa5__ActionMismatch, "wsa5:ActionMismatch" },
	{ (LONG64)wsa5__MessageAddressingHeaderRequired, "wsa5:MessageAddressingHeaderRequired" },
	{ (LONG64)wsa5__DestinationUnreachable, "wsa5:DestinationUnreachable" },
	{ (LONG64)wsa5__ActionNotSupported, "wsa5:ActionNotSupported" },
	{ (LONG64)wsa5__EndpointUnavailable, "wsa5:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap *soap, enum wsa5__FaultCodesType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__FaultCodesType), type) || soap_send(soap, soap_wsa5__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap *soap, const char *s, enum wsa5__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa5__FaultCodesType, t);
	if (map)
		*a = (enum wsa5__FaultCodesType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 10)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap *soap, const char *tag, enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__FaultCodesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__FaultCodesType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_new_wsa5__FaultCodesType(struct soap *soap, int n)
{
	enum wsa5__FaultCodesType *a = static_cast<enum wsa5__FaultCodesType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__FaultCodesType)));
	for (enum wsa5__FaultCodesType *p = a; p && n--; ++p)
		soap_default_wsa5__FaultCodesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap *soap, const enum wsa5__FaultCodesType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesType(soap, tag ? tag : "wsa5:FaultCodesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__RelationshipType[] =
{	{ (LONG64)http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap *soap, enum wsa5__RelationshipType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__RelationshipType), type) || soap_send(soap, soap_wsa5__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap *soap, const char *s, enum wsa5__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsa5__RelationshipType, s);
	if (map)
		*a = (enum wsa5__RelationshipType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap *soap, const char *tag, enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__RelationshipType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__RelationshipType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_new_wsa5__RelationshipType(struct soap *soap, int n)
{
	enum wsa5__RelationshipType *a = static_cast<enum wsa5__RelationshipType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__RelationshipType)));
	for (enum wsa5__RelationshipType *p = a; p && n--; ++p)
		soap_default_wsa5__RelationshipType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap *soap, const enum wsa5__RelationshipType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipType(soap, tag ? tag : "wsa5:RelationshipType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns10__EEventTypes[] =
{	{ (LONG64)ns10__EEventTypes__None, "None" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns10__EEventTypes2s(struct soap *soap, enum ns10__EEventTypes n)
{
	const char *s = soap_code_str(soap_codes_ns10__EEventTypes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__EEventTypes(struct soap *soap, const char *tag, int id, const enum ns10__EEventTypes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__EEventTypes), type) || soap_send(soap, soap_ns10__EEventTypes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns10__EEventTypes(struct soap *soap, const char *s, enum ns10__EEventTypes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns10__EEventTypes, s);
	if (map)
		*a = (enum ns10__EEventTypes)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum ns10__EEventTypes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns10__EEventTypes * SOAP_FMAC4 soap_in_ns10__EEventTypes(struct soap *soap, const char *tag, enum ns10__EEventTypes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns10__EEventTypes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__EEventTypes, sizeof(enum ns10__EEventTypes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns10__EEventTypes(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns10__EEventTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__EEventTypes, SOAP_TYPE_ns10__EEventTypes, sizeof(enum ns10__EEventTypes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns10__EEventTypes * SOAP_FMAC4 soap_new_ns10__EEventTypes(struct soap *soap, int n)
{
	enum ns10__EEventTypes *a = static_cast<enum ns10__EEventTypes *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns10__EEventTypes)));
	for (enum ns10__EEventTypes *p = a; p && n--; ++p)
		soap_default_ns10__EEventTypes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns10__EEventTypes(struct soap *soap, const enum ns10__EEventTypes *a, const char *tag, const char *type)
{
	if (soap_out_ns10__EEventTypes(soap, tag ? tag : "ns10:EEventTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns10__EEventTypes * SOAP_FMAC4 soap_get_ns10__EEventTypes(struct soap *soap, enum ns10__EEventTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__EEventTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns10__EResultValueStatus[] =
{	{ (LONG64)ns10__EResultValueStatus__InInterval, "InInterval" },
	{ (LONG64)ns10__EResultValueStatus__LowerInterval, "LowerInterval" },
	{ (LONG64)ns10__EResultValueStatus__UpperInterval, "UpperInterval" },
	{ (LONG64)ns10__EResultValueStatus__LowerOrEqualsInterval, "LowerOrEqualsInterval" },
	{ (LONG64)ns10__EResultValueStatus__UpperOrEqualsInterval, "UpperOrEqualsInterval" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns10__EResultValueStatus2s(struct soap *soap, enum ns10__EResultValueStatus n)
{
	const char *s = soap_code_str(soap_codes_ns10__EResultValueStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__EResultValueStatus(struct soap *soap, const char *tag, int id, const enum ns10__EResultValueStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__EResultValueStatus), type) || soap_send(soap, soap_ns10__EResultValueStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns10__EResultValueStatus(struct soap *soap, const char *s, enum ns10__EResultValueStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns10__EResultValueStatus, s);
	if (map)
		*a = (enum ns10__EResultValueStatus)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum ns10__EResultValueStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns10__EResultValueStatus * SOAP_FMAC4 soap_in_ns10__EResultValueStatus(struct soap *soap, const char *tag, enum ns10__EResultValueStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns10__EResultValueStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__EResultValueStatus, sizeof(enum ns10__EResultValueStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns10__EResultValueStatus(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns10__EResultValueStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__EResultValueStatus, SOAP_TYPE_ns10__EResultValueStatus, sizeof(enum ns10__EResultValueStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns10__EResultValueStatus * SOAP_FMAC4 soap_new_ns10__EResultValueStatus(struct soap *soap, int n)
{
	enum ns10__EResultValueStatus *a = static_cast<enum ns10__EResultValueStatus *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns10__EResultValueStatus)));
	for (enum ns10__EResultValueStatus *p = a; p && n--; ++p)
		soap_default_ns10__EResultValueStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns10__EResultValueStatus(struct soap *soap, const enum ns10__EResultValueStatus *a, const char *tag, const char *type)
{
	if (soap_out_ns10__EResultValueStatus(soap, tag ? tag : "ns10:EResultValueStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns10__EResultValueStatus * SOAP_FMAC4 soap_get_ns10__EResultValueStatus(struct soap *soap, enum ns10__EResultValueStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__EResultValueStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns10__EResultStatus[] =
{	{ (LONG64)ns10__EResultStatus__None, "None" },
	{ (LONG64)ns10__EResultStatus__OK, "OK" },
	{ (LONG64)ns10__EResultStatus__Error, "Error" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns10__EResultStatus2s(struct soap *soap, enum ns10__EResultStatus n)
{
	const char *s = soap_code_str(soap_codes_ns10__EResultStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__EResultStatus(struct soap *soap, const char *tag, int id, const enum ns10__EResultStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__EResultStatus), type) || soap_send(soap, soap_ns10__EResultStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns10__EResultStatus(struct soap *soap, const char *s, enum ns10__EResultStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns10__EResultStatus, s);
	if (map)
		*a = (enum ns10__EResultStatus)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns10__EResultStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns10__EResultStatus * SOAP_FMAC4 soap_in_ns10__EResultStatus(struct soap *soap, const char *tag, enum ns10__EResultStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns10__EResultStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__EResultStatus, sizeof(enum ns10__EResultStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns10__EResultStatus(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns10__EResultStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__EResultStatus, SOAP_TYPE_ns10__EResultStatus, sizeof(enum ns10__EResultStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns10__EResultStatus * SOAP_FMAC4 soap_new_ns10__EResultStatus(struct soap *soap, int n)
{
	enum ns10__EResultStatus *a = static_cast<enum ns10__EResultStatus *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns10__EResultStatus)));
	for (enum ns10__EResultStatus *p = a; p && n--; ++p)
		soap_default_ns10__EResultStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns10__EResultStatus(struct soap *soap, const enum ns10__EResultStatus *a, const char *tag, const char *type)
{
	if (soap_out_ns10__EResultStatus(soap, tag ? tag : "ns10:EResultStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns10__EResultStatus * SOAP_FMAC4 soap_get_ns10__EResultStatus(struct soap *soap, enum ns10__EResultStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__EResultStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns10__ESampleTypes[] =
{	{ (LONG64)ns10__ESampleTypes__None, "None" },
	{ (LONG64)ns10__ESampleTypes__Regular, "Regular" },
	{ (LONG64)ns10__ESampleTypes__Control, "Control" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns10__ESampleTypes2s(struct soap *soap, enum ns10__ESampleTypes n)
{
	const char *s = soap_code_str(soap_codes_ns10__ESampleTypes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__ESampleTypes(struct soap *soap, const char *tag, int id, const enum ns10__ESampleTypes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__ESampleTypes), type) || soap_send(soap, soap_ns10__ESampleTypes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns10__ESampleTypes(struct soap *soap, const char *s, enum ns10__ESampleTypes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns10__ESampleTypes, s);
	if (map)
		*a = (enum ns10__ESampleTypes)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns10__ESampleTypes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns10__ESampleTypes * SOAP_FMAC4 soap_in_ns10__ESampleTypes(struct soap *soap, const char *tag, enum ns10__ESampleTypes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns10__ESampleTypes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__ESampleTypes, sizeof(enum ns10__ESampleTypes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns10__ESampleTypes(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns10__ESampleTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__ESampleTypes, SOAP_TYPE_ns10__ESampleTypes, sizeof(enum ns10__ESampleTypes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns10__ESampleTypes * SOAP_FMAC4 soap_new_ns10__ESampleTypes(struct soap *soap, int n)
{
	enum ns10__ESampleTypes *a = static_cast<enum ns10__ESampleTypes *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns10__ESampleTypes)));
	for (enum ns10__ESampleTypes *p = a; p && n--; ++p)
		soap_default_ns10__ESampleTypes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns10__ESampleTypes(struct soap *soap, const enum ns10__ESampleTypes *a, const char *tag, const char *type)
{
	if (soap_out_ns10__ESampleTypes(soap, tag ? tag : "ns10:ESampleTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns10__ESampleTypes * SOAP_FMAC4 soap_get_ns10__ESampleTypes(struct soap *soap, enum ns10__ESampleTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__ESampleTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns9__ChromatographMode[] =
{	{ (LONG64)ns9__ChromatographMode__Null, "Null" },
	{ (LONG64)ns9__ChromatographMode__Preparation, "Preparation" },
	{ (LONG64)ns9__ChromatographMode__Awaiting, "Awaiting" },
	{ (LONG64)ns9__ChromatographMode__Firing, "Firing" },
	{ (LONG64)ns9__ChromatographMode__Readiness, "Readiness" },
	{ (LONG64)ns9__ChromatographMode__BlowingPreparation, "BlowingPreparation" },
	{ (LONG64)ns9__ChromatographMode__Blowing, "Blowing" },
	{ (LONG64)ns9__ChromatographMode__Economy, "Economy" },
	{ (LONG64)ns9__ChromatographMode__Cooling, "Cooling" },
	{ (LONG64)ns9__ChromatographMode__Analysis, "Analysis" },
	{ (LONG64)ns9__ChromatographMode__FatalError, "FatalError" },
	{ (LONG64)ns9__ChromatographMode__MethodStaring, "MethodStaring" },
	{ (LONG64)ns9__ChromatographMode__StartAnalysis, "StartAnalysis" },
	{ (LONG64)ns9__ChromatographMode__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns9__ChromatographMode2s(struct soap *soap, enum ns9__ChromatographMode n)
{
	const char *s = soap_code_str(soap_codes_ns9__ChromatographMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns9__ChromatographMode(struct soap *soap, const char *tag, int id, const enum ns9__ChromatographMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns9__ChromatographMode), type) || soap_send(soap, soap_ns9__ChromatographMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns9__ChromatographMode(struct soap *soap, const char *s, enum ns9__ChromatographMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns9__ChromatographMode, s);
	if (map)
		*a = (enum ns9__ChromatographMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 13)
			return soap->error = SOAP_TYPE;
		*a = (enum ns9__ChromatographMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns9__ChromatographMode * SOAP_FMAC4 soap_in_ns9__ChromatographMode(struct soap *soap, const char *tag, enum ns9__ChromatographMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns9__ChromatographMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns9__ChromatographMode, sizeof(enum ns9__ChromatographMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns9__ChromatographMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns9__ChromatographMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns9__ChromatographMode, SOAP_TYPE_ns9__ChromatographMode, sizeof(enum ns9__ChromatographMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns9__ChromatographMode * SOAP_FMAC4 soap_new_ns9__ChromatographMode(struct soap *soap, int n)
{
	enum ns9__ChromatographMode *a = static_cast<enum ns9__ChromatographMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns9__ChromatographMode)));
	for (enum ns9__ChromatographMode *p = a; p && n--; ++p)
		soap_default_ns9__ChromatographMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns9__ChromatographMode(struct soap *soap, const enum ns9__ChromatographMode *a, const char *tag, const char *type)
{
	if (soap_out_ns9__ChromatographMode(soap, tag ? tag : "ns9:ChromatographMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns9__ChromatographMode * SOAP_FMAC4 soap_get_ns9__ChromatographMode(struct soap *soap, enum ns9__ChromatographMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns9__ChromatographMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns8__Logger_x002eLogLevel[] =
{	{ (LONG64)ns8__Logger_x002eLogLevel__Debug, "Debug" },
	{ (LONG64)ns8__Logger_x002eLogLevel__Info, "Info" },
	{ (LONG64)ns8__Logger_x002eLogLevel__Warning, "Warning" },
	{ (LONG64)ns8__Logger_x002eLogLevel__Error, "Error" },
	{ (LONG64)ns8__Logger_x002eLogLevel__Fatal, "Fatal" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns8__Logger_x002eLogLevel2s(struct soap *soap, enum ns8__Logger_x002eLogLevel n)
{
	const char *s = soap_code_str(soap_codes_ns8__Logger_x002eLogLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__Logger_x002eLogLevel(struct soap *soap, const char *tag, int id, const enum ns8__Logger_x002eLogLevel *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__Logger_x002eLogLevel), type) || soap_send(soap, soap_ns8__Logger_x002eLogLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns8__Logger_x002eLogLevel(struct soap *soap, const char *s, enum ns8__Logger_x002eLogLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns8__Logger_x002eLogLevel, s);
	if (map)
		*a = (enum ns8__Logger_x002eLogLevel)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum ns8__Logger_x002eLogLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns8__Logger_x002eLogLevel * SOAP_FMAC4 soap_in_ns8__Logger_x002eLogLevel(struct soap *soap, const char *tag, enum ns8__Logger_x002eLogLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns8__Logger_x002eLogLevel*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__Logger_x002eLogLevel, sizeof(enum ns8__Logger_x002eLogLevel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns8__Logger_x002eLogLevel(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns8__Logger_x002eLogLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__Logger_x002eLogLevel, SOAP_TYPE_ns8__Logger_x002eLogLevel, sizeof(enum ns8__Logger_x002eLogLevel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns8__Logger_x002eLogLevel * SOAP_FMAC4 soap_new_ns8__Logger_x002eLogLevel(struct soap *soap, int n)
{
	enum ns8__Logger_x002eLogLevel *a = static_cast<enum ns8__Logger_x002eLogLevel *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns8__Logger_x002eLogLevel)));
	for (enum ns8__Logger_x002eLogLevel *p = a; p && n--; ++p)
		soap_default_ns8__Logger_x002eLogLevel(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__Logger_x002eLogLevel(struct soap *soap, const enum ns8__Logger_x002eLogLevel *a, const char *tag, const char *type)
{
	if (soap_out_ns8__Logger_x002eLogLevel(soap, tag ? tag : "ns8:Logger.LogLevel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns8__Logger_x002eLogLevel * SOAP_FMAC4 soap_get_ns8__Logger_x002eLogLevel(struct soap *soap, enum ns8__Logger_x002eLogLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns8__Logger_x002eLogLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns4__OperationTypes[] =
{	{ (LONG64)ns4__OperationTypes__None, "None" },
	{ (LONG64)ns4__OperationTypes__RegularSampling, "RegularSampling" },
	{ (LONG64)ns4__OperationTypes__ControlSampling, "ControlSampling" },
	{ (LONG64)ns4__OperationTypes__Clearing, "Clearing" },
	{ (LONG64)ns4__OperationTypes__Cooling, "Cooling" },
	{ (LONG64)ns4__OperationTypes__PreparingAtStart, "PreparingAtStart" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__OperationTypes2s(struct soap *soap, enum ns4__OperationTypes n)
{
	const char *s = soap_code_str(soap_codes_ns4__OperationTypes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__OperationTypes(struct soap *soap, const char *tag, int id, const enum ns4__OperationTypes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__OperationTypes), type) || soap_send(soap, soap_ns4__OperationTypes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__OperationTypes(struct soap *soap, const char *s, enum ns4__OperationTypes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__OperationTypes, s);
	if (map)
		*a = (enum ns4__OperationTypes)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 5)
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__OperationTypes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__OperationTypes * SOAP_FMAC4 soap_in_ns4__OperationTypes(struct soap *soap, const char *tag, enum ns4__OperationTypes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__OperationTypes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__OperationTypes, sizeof(enum ns4__OperationTypes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns4__OperationTypes(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns4__OperationTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__OperationTypes, SOAP_TYPE_ns4__OperationTypes, sizeof(enum ns4__OperationTypes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns4__OperationTypes * SOAP_FMAC4 soap_new_ns4__OperationTypes(struct soap *soap, int n)
{
	enum ns4__OperationTypes *a = static_cast<enum ns4__OperationTypes *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns4__OperationTypes)));
	for (enum ns4__OperationTypes *p = a; p && n--; ++p)
		soap_default_ns4__OperationTypes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__OperationTypes(struct soap *soap, const enum ns4__OperationTypes *a, const char *tag, const char *type)
{
	if (soap_out_ns4__OperationTypes(soap, tag ? tag : "ns4:OperationTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__OperationTypes * SOAP_FMAC4 soap_get_ns4__OperationTypes(struct soap *soap, enum ns4__OperationTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__OperationTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns4__ControlledParametr_x002eControlActionType[] =
{	{ (LONG64)ns4__ControlledParametr_x002eControlActionType__None, "None" },
	{ (LONG64)ns4__ControlledParametr_x002eControlActionType__Warning, "Warning" },
	{ (LONG64)ns4__ControlledParametr_x002eControlActionType__Error, "Error" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__ControlledParametr_x002eControlActionType2s(struct soap *soap, enum ns4__ControlledParametr_x002eControlActionType n)
{
	const char *s = soap_code_str(soap_codes_ns4__ControlledParametr_x002eControlActionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ControlledParametr_x002eControlActionType(struct soap *soap, const char *tag, int id, const enum ns4__ControlledParametr_x002eControlActionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ControlledParametr_x002eControlActionType), type) || soap_send(soap, soap_ns4__ControlledParametr_x002eControlActionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__ControlledParametr_x002eControlActionType(struct soap *soap, const char *s, enum ns4__ControlledParametr_x002eControlActionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__ControlledParametr_x002eControlActionType, s);
	if (map)
		*a = (enum ns4__ControlledParametr_x002eControlActionType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__ControlledParametr_x002eControlActionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__ControlledParametr_x002eControlActionType * SOAP_FMAC4 soap_in_ns4__ControlledParametr_x002eControlActionType(struct soap *soap, const char *tag, enum ns4__ControlledParametr_x002eControlActionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__ControlledParametr_x002eControlActionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ControlledParametr_x002eControlActionType, sizeof(enum ns4__ControlledParametr_x002eControlActionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns4__ControlledParametr_x002eControlActionType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns4__ControlledParametr_x002eControlActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ControlledParametr_x002eControlActionType, SOAP_TYPE_ns4__ControlledParametr_x002eControlActionType, sizeof(enum ns4__ControlledParametr_x002eControlActionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns4__ControlledParametr_x002eControlActionType * SOAP_FMAC4 soap_new_ns4__ControlledParametr_x002eControlActionType(struct soap *soap, int n)
{
	enum ns4__ControlledParametr_x002eControlActionType *a = static_cast<enum ns4__ControlledParametr_x002eControlActionType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns4__ControlledParametr_x002eControlActionType)));
	for (enum ns4__ControlledParametr_x002eControlActionType *p = a; p && n--; ++p)
		soap_default_ns4__ControlledParametr_x002eControlActionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ControlledParametr_x002eControlActionType(struct soap *soap, const enum ns4__ControlledParametr_x002eControlActionType *a, const char *tag, const char *type)
{
	if (soap_out_ns4__ControlledParametr_x002eControlActionType(soap, tag ? tag : "ns4:ControlledParametr.ControlActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__ControlledParametr_x002eControlActionType * SOAP_FMAC4 soap_get_ns4__ControlledParametr_x002eControlActionType(struct soap *soap, enum ns4__ControlledParametr_x002eControlActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ControlledParametr_x002eControlActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns4__OperationStepTypes[] =
{	{ (LONG64)ns4__OperationStepTypes__None, "None" },
	{ (LONG64)ns4__OperationStepTypes__WaitTime, "WaitTime" },
	{ (LONG64)ns4__OperationStepTypes__WaitMode, "WaitMode" },
	{ (LONG64)ns4__OperationStepTypes__WaitWhileMode, "WaitWhileMode" },
	{ (LONG64)ns4__OperationStepTypes__WaitConditions, "WaitConditions" },
	{ (LONG64)ns4__OperationStepTypes__ProgStart, "ProgStart" },
	{ (LONG64)ns4__OperationStepTypes__ProgStop, "ProgStop" },
	{ (LONG64)ns4__OperationStepTypes__ProgLoadMode, "ProgLoadMode" },
	{ (LONG64)ns4__OperationStepTypes__ProgLoadModeConf, "ProgLoadModeConf" },
	{ (LONG64)ns4__OperationStepTypes__ProgButtonStart, "ProgButtonStart" },
	{ (LONG64)ns4__OperationStepTypes__ProgButtonStop, "ProgButtonStop" },
	{ (LONG64)ns4__OperationStepTypes__ProgButtonCooling, "ProgButtonCooling" },
	{ (LONG64)ns4__OperationStepTypes__SamplingStart, "SamplingStart" },
	{ (LONG64)ns4__OperationStepTypes__SamplingStop, "SamplingStop" },
	{ (LONG64)ns4__OperationStepTypes__CriticalStart, "CriticalStart" },
	{ (LONG64)ns4__OperationStepTypes__CriticalStop, "CriticalStop" },
	{ (LONG64)ns4__OperationStepTypes__Calc_USCOREReceiveResult, "Calc_ReceiveResult" },
	{ (LONG64)ns4__OperationStepTypes__Calc_USCORERememberLastResult, "Calc_RememberLastResult" },
	{ (LONG64)ns4__OperationStepTypes__Device_USCORESendCommand, "Device_SendCommand" },
	{ (LONG64)ns4__OperationStepTypes__Device_USCORESendCommand2, "Device_SendCommand2" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__OperationStepTypes2s(struct soap *soap, enum ns4__OperationStepTypes n)
{
	const char *s = soap_code_str(soap_codes_ns4__OperationStepTypes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__OperationStepTypes(struct soap *soap, const char *tag, int id, const enum ns4__OperationStepTypes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__OperationStepTypes), type) || soap_send(soap, soap_ns4__OperationStepTypes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__OperationStepTypes(struct soap *soap, const char *s, enum ns4__OperationStepTypes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__OperationStepTypes, s);
	if (map)
		*a = (enum ns4__OperationStepTypes)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 19)
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__OperationStepTypes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__OperationStepTypes * SOAP_FMAC4 soap_in_ns4__OperationStepTypes(struct soap *soap, const char *tag, enum ns4__OperationStepTypes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__OperationStepTypes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__OperationStepTypes, sizeof(enum ns4__OperationStepTypes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns4__OperationStepTypes(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns4__OperationStepTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__OperationStepTypes, SOAP_TYPE_ns4__OperationStepTypes, sizeof(enum ns4__OperationStepTypes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns4__OperationStepTypes * SOAP_FMAC4 soap_new_ns4__OperationStepTypes(struct soap *soap, int n)
{
	enum ns4__OperationStepTypes *a = static_cast<enum ns4__OperationStepTypes *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns4__OperationStepTypes)));
	for (enum ns4__OperationStepTypes *p = a; p && n--; ++p)
		soap_default_ns4__OperationStepTypes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__OperationStepTypes(struct soap *soap, const enum ns4__OperationStepTypes *a, const char *tag, const char *type)
{
	if (soap_out_ns4__OperationStepTypes(soap, tag ? tag : "ns4:OperationStepTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__OperationStepTypes * SOAP_FMAC4 soap_get_ns4__OperationStepTypes(struct soap *soap, enum ns4__OperationStepTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__OperationStepTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns3__ProcessingModes[] =
{	{ (LONG64)ns3__ProcessingModes__None, "None" },
	{ (LONG64)ns3__ProcessingModes__OperationRunning, "OperationRunning" },
	{ (LONG64)ns3__ProcessingModes__AutoPlanRunning, "AutoPlanRunning" },
	{ (LONG64)ns3__ProcessingModes__Stopping, "Stopping" },
	{ (LONG64)ns3__ProcessingModes__Aborting, "Aborting" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__ProcessingModes2s(struct soap *soap, enum ns3__ProcessingModes n)
{
	const char *s = soap_code_str(soap_codes_ns3__ProcessingModes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ProcessingModes(struct soap *soap, const char *tag, int id, const enum ns3__ProcessingModes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ProcessingModes), type) || soap_send(soap, soap_ns3__ProcessingModes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__ProcessingModes(struct soap *soap, const char *s, enum ns3__ProcessingModes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__ProcessingModes, s);
	if (map)
		*a = (enum ns3__ProcessingModes)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__ProcessingModes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__ProcessingModes * SOAP_FMAC4 soap_in_ns3__ProcessingModes(struct soap *soap, const char *tag, enum ns3__ProcessingModes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__ProcessingModes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ProcessingModes, sizeof(enum ns3__ProcessingModes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns3__ProcessingModes(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns3__ProcessingModes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ProcessingModes, SOAP_TYPE_ns3__ProcessingModes, sizeof(enum ns3__ProcessingModes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns3__ProcessingModes * SOAP_FMAC4 soap_new_ns3__ProcessingModes(struct soap *soap, int n)
{
	enum ns3__ProcessingModes *a = static_cast<enum ns3__ProcessingModes *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns3__ProcessingModes)));
	for (enum ns3__ProcessingModes *p = a; p && n--; ++p)
		soap_default_ns3__ProcessingModes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__ProcessingModes(struct soap *soap, const enum ns3__ProcessingModes *a, const char *tag, const char *type)
{
	if (soap_out_ns3__ProcessingModes(soap, tag ? tag : "ns3:ProcessingModes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__ProcessingModes * SOAP_FMAC4 soap_get_ns3__ProcessingModes(struct soap *soap, enum ns3__ProcessingModes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ProcessingModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns3__OperationProcInfo_x002eOperationStepInfoStates[] =
{	{ (LONG64)ns3__OperationProcInfo_x002eOperationStepInfoStates__None, "None" },
	{ (LONG64)ns3__OperationProcInfo_x002eOperationStepInfoStates__NotStarted, "NotStarted" },
	{ (LONG64)ns3__OperationProcInfo_x002eOperationStepInfoStates__Running, "Running" },
	{ (LONG64)ns3__OperationProcInfo_x002eOperationStepInfoStates__Finished, "Finished" },
	{ (LONG64)ns3__OperationProcInfo_x002eOperationStepInfoStates__Error, "Error" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__OperationProcInfo_x002eOperationStepInfoStates2s(struct soap *soap, enum ns3__OperationProcInfo_x002eOperationStepInfoStates n)
{
	const char *s = soap_code_str(soap_codes_ns3__OperationProcInfo_x002eOperationStepInfoStates, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__OperationProcInfo_x002eOperationStepInfoStates(struct soap *soap, const char *tag, int id, const enum ns3__OperationProcInfo_x002eOperationStepInfoStates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfoStates), type) || soap_send(soap, soap_ns3__OperationProcInfo_x002eOperationStepInfoStates2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__OperationProcInfo_x002eOperationStepInfoStates(struct soap *soap, const char *s, enum ns3__OperationProcInfo_x002eOperationStepInfoStates *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__OperationProcInfo_x002eOperationStepInfoStates, s);
	if (map)
		*a = (enum ns3__OperationProcInfo_x002eOperationStepInfoStates)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__OperationProcInfo_x002eOperationStepInfoStates)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__OperationProcInfo_x002eOperationStepInfoStates * SOAP_FMAC4 soap_in_ns3__OperationProcInfo_x002eOperationStepInfoStates(struct soap *soap, const char *tag, enum ns3__OperationProcInfo_x002eOperationStepInfoStates *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__OperationProcInfo_x002eOperationStepInfoStates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfoStates, sizeof(enum ns3__OperationProcInfo_x002eOperationStepInfoStates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns3__OperationProcInfo_x002eOperationStepInfoStates(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns3__OperationProcInfo_x002eOperationStepInfoStates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfoStates, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfoStates, sizeof(enum ns3__OperationProcInfo_x002eOperationStepInfoStates), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns3__OperationProcInfo_x002eOperationStepInfoStates * SOAP_FMAC4 soap_new_ns3__OperationProcInfo_x002eOperationStepInfoStates(struct soap *soap, int n)
{
	enum ns3__OperationProcInfo_x002eOperationStepInfoStates *a = static_cast<enum ns3__OperationProcInfo_x002eOperationStepInfoStates *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns3__OperationProcInfo_x002eOperationStepInfoStates)));
	for (enum ns3__OperationProcInfo_x002eOperationStepInfoStates *p = a; p && n--; ++p)
		soap_default_ns3__OperationProcInfo_x002eOperationStepInfoStates(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__OperationProcInfo_x002eOperationStepInfoStates(struct soap *soap, const enum ns3__OperationProcInfo_x002eOperationStepInfoStates *a, const char *tag, const char *type)
{
	if (soap_out_ns3__OperationProcInfo_x002eOperationStepInfoStates(soap, tag ? tag : "ns3:OperationProcInfo.OperationStepInfoStates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__OperationProcInfo_x002eOperationStepInfoStates * SOAP_FMAC4 soap_get_ns3__OperationProcInfo_x002eOperationStepInfoStates(struct soap *soap, enum ns3__OperationProcInfo_x002eOperationStepInfoStates *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__OperationProcInfo_x002eOperationStepInfoStates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns10__EEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns10__EEvent::Confirmed = NULL;
	this->ns10__EEvent::Description = NULL;
	this->ns10__EEvent::EventDateTime = NULL;
	this->ns10__EEvent::EventType = NULL;
	this->ns10__EEvent::Id = NULL;
	this->ns10__EEvent::Title = NULL;
}

void ns10__EEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->ns10__EEvent::Confirmed);
	soap_serialize_PointerTostd__string(soap, &this->ns10__EEvent::Description);
	soap_serialize_PointerTodateTime(soap, &this->ns10__EEvent::EventDateTime);
	soap_serialize_PointerTons10__EEventTypes(soap, &this->ns10__EEvent::EventType);
	soap_serialize_PointerToint(soap, &this->ns10__EEvent::Id);
	soap_serialize_PointerTostd__string(soap, &this->ns10__EEvent::Title);
#endif
}

int ns10__EEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns10__EEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__EEvent(struct soap *soap, const char *tag, int id, const ns10__EEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__EEvent), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns10:Confirmed", -1, &a->ns10__EEvent::Confirmed, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns10:Description", -1, &a->ns10__EEvent::Description, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns10:EventDateTime", -1, &a->ns10__EEvent::EventDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons10__EEventTypes(soap, "ns10:EventType", -1, &a->ns10__EEvent::EventType, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns10:Id", -1, &a->ns10__EEvent::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns10:Title", -1, &a->ns10__EEvent::Title, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns10__EEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns10__EEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns10__EEvent * SOAP_FMAC4 soap_in_ns10__EEvent(struct soap *soap, const char *tag, ns10__EEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns10__EEvent*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__EEvent, sizeof(ns10__EEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns10__EEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns10__EEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Confirmed1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_EventDateTime1 = 1;
	size_t soap_flag_EventType1 = 1;
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Title1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Confirmed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns10:Confirmed", &a->ns10__EEvent::Confirmed, "xsd:boolean"))
				{	soap_flag_Confirmed1--;
					continue;
				}
			}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns10:Description", &a->ns10__EEvent::Description, "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			}
			if (soap_flag_EventDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns10:EventDateTime", &a->ns10__EEvent::EventDateTime, "xsd:dateTime"))
				{	soap_flag_EventDateTime1--;
					continue;
				}
			}
			if (soap_flag_EventType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons10__EEventTypes(soap, "ns10:EventType", &a->ns10__EEvent::EventType, "ns10:EEventTypes"))
				{	soap_flag_EventType1--;
					continue;
				}
			}
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns10:Id", &a->ns10__EEvent::Id, "xsd:int"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns10:Title", &a->ns10__EEvent::Title, "xsd:string"))
				{	soap_flag_Title1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns10__EEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__EEvent, SOAP_TYPE_ns10__EEvent, sizeof(ns10__EEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns10__EEvent * SOAP_FMAC2 soap_instantiate_ns10__EEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns10__EEvent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns10__EEvent *p;
	size_t k = sizeof(ns10__EEvent);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns10__EEvent, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns10__EEvent);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns10__EEvent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns10__EEvent location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns10__EEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns10__EEvent(soap, tag ? tag : "ns10:EEvent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns10__EEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns10__EEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns10__EEvent * SOAP_FMAC4 soap_get_ns10__EEvent(struct soap *soap, ns10__EEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__EEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns10__ArrayOfEEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons10__EEvent(soap, &this->ns10__ArrayOfEEvent::EEvent);
}

void ns10__ArrayOfEEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons10__EEvent(soap, &this->ns10__ArrayOfEEvent::EEvent);
#endif
}

int ns10__ArrayOfEEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns10__ArrayOfEEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__ArrayOfEEvent(struct soap *soap, const char *tag, int id, const ns10__ArrayOfEEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__ArrayOfEEvent), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons10__EEvent(soap, "ns10:EEvent", -1, &a->ns10__ArrayOfEEvent::EEvent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns10__ArrayOfEEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns10__ArrayOfEEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns10__ArrayOfEEvent * SOAP_FMAC4 soap_in_ns10__ArrayOfEEvent(struct soap *soap, const char *tag, ns10__ArrayOfEEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns10__ArrayOfEEvent*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__ArrayOfEEvent, sizeof(ns10__ArrayOfEEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns10__ArrayOfEEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns10__ArrayOfEEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons10__EEvent(soap, "ns10:EEvent", &a->ns10__ArrayOfEEvent::EEvent, "ns10:EEvent"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns10__ArrayOfEEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__ArrayOfEEvent, SOAP_TYPE_ns10__ArrayOfEEvent, sizeof(ns10__ArrayOfEEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns10__ArrayOfEEvent * SOAP_FMAC2 soap_instantiate_ns10__ArrayOfEEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns10__ArrayOfEEvent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns10__ArrayOfEEvent *p;
	size_t k = sizeof(ns10__ArrayOfEEvent);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns10__ArrayOfEEvent, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns10__ArrayOfEEvent);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns10__ArrayOfEEvent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns10__ArrayOfEEvent location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns10__ArrayOfEEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns10__ArrayOfEEvent(soap, tag ? tag : "ns10:ArrayOfEEvent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns10__ArrayOfEEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns10__ArrayOfEEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns10__ArrayOfEEvent * SOAP_FMAC4 soap_get_ns10__ArrayOfEEvent(struct soap *soap, ns10__ArrayOfEEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__ArrayOfEEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns10__EResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns10__EResult::AccuracyStatus = NULL;
	this->ns10__EResult::AccuracyStatusInfo = NULL;
	this->ns10__EResult::ComponentCode = NULL;
	this->ns10__EResult::ComponentName = NULL;
	this->ns10__EResult::Id = NULL;
	this->ns10__EResult::IntervalValueBorder = NULL;
	this->ns10__EResult::PeriodicityStatus = NULL;
	this->ns10__EResult::PeriodicityStatusInfo = NULL;
	this->ns10__EResult::ResultDetails = NULL;
	this->ns10__EResult::Sample = NULL;
	this->ns10__EResult::UnitsName = NULL;
	this->ns10__EResult::Value = NULL;
	this->ns10__EResult::ValueDigAfterPoint = NULL;
	this->ns10__EResult::ValueStatus = NULL;
}

void ns10__EResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons10__EResultStatus(soap, &this->ns10__EResult::AccuracyStatus);
	soap_serialize_PointerTostd__string(soap, &this->ns10__EResult::AccuracyStatusInfo);
	soap_serialize_PointerToint(soap, &this->ns10__EResult::ComponentCode);
	soap_serialize_PointerTostd__string(soap, &this->ns10__EResult::ComponentName);
	soap_serialize_PointerToint(soap, &this->ns10__EResult::Id);
	soap_serialize_PointerToxsd__decimal(soap, &this->ns10__EResult::IntervalValueBorder);
	soap_serialize_PointerTons10__EResultStatus(soap, &this->ns10__EResult::PeriodicityStatus);
	soap_serialize_PointerTostd__string(soap, &this->ns10__EResult::PeriodicityStatusInfo);
	soap_serialize_PointerTostd__string(soap, &this->ns10__EResult::ResultDetails);
	soap_serialize_PointerTons10__ESample(soap, &this->ns10__EResult::Sample);
	soap_serialize_PointerTostd__string(soap, &this->ns10__EResult::UnitsName);
	soap_serialize_PointerToxsd__decimal(soap, &this->ns10__EResult::Value);
	soap_serialize_PointerToint(soap, &this->ns10__EResult::ValueDigAfterPoint);
	soap_serialize_PointerTons10__EResultValueStatus(soap, &this->ns10__EResult::ValueStatus);
#endif
}

int ns10__EResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns10__EResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__EResult(struct soap *soap, const char *tag, int id, const ns10__EResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__EResult), type))
		return soap->error;
	if (soap_out_PointerTons10__EResultStatus(soap, "ns10:AccuracyStatus", -1, &a->ns10__EResult::AccuracyStatus, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns10:AccuracyStatusInfo", -1, &a->ns10__EResult::AccuracyStatusInfo, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns10:ComponentCode", -1, &a->ns10__EResult::ComponentCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns10:ComponentName", -1, &a->ns10__EResult::ComponentName, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns10:Id", -1, &a->ns10__EResult::Id, ""))
		return soap->error;
	if (soap_out_PointerToxsd__decimal(soap, "ns10:IntervalValueBorder", -1, &a->ns10__EResult::IntervalValueBorder, ""))
		return soap->error;
	if (soap_out_PointerTons10__EResultStatus(soap, "ns10:PeriodicityStatus", -1, &a->ns10__EResult::PeriodicityStatus, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns10:PeriodicityStatusInfo", -1, &a->ns10__EResult::PeriodicityStatusInfo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns10:ResultDetails", -1, &a->ns10__EResult::ResultDetails, ""))
		return soap->error;
	if (soap_out_PointerTons10__ESample(soap, "ns10:Sample", -1, &a->ns10__EResult::Sample, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns10:UnitsName", -1, &a->ns10__EResult::UnitsName, ""))
		return soap->error;
	if (soap_out_PointerToxsd__decimal(soap, "ns10:Value", -1, &a->ns10__EResult::Value, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns10:ValueDigAfterPoint", -1, &a->ns10__EResult::ValueDigAfterPoint, ""))
		return soap->error;
	if (soap_out_PointerTons10__EResultValueStatus(soap, "ns10:ValueStatus", -1, &a->ns10__EResult::ValueStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns10__EResult::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns10__EResult(soap, tag, this, type);
}

SOAP_FMAC3 ns10__EResult * SOAP_FMAC4 soap_in_ns10__EResult(struct soap *soap, const char *tag, ns10__EResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns10__EResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__EResult, sizeof(ns10__EResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns10__EResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns10__EResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AccuracyStatus1 = 1;
	size_t soap_flag_AccuracyStatusInfo1 = 1;
	size_t soap_flag_ComponentCode1 = 1;
	size_t soap_flag_ComponentName1 = 1;
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_IntervalValueBorder1 = 1;
	size_t soap_flag_PeriodicityStatus1 = 1;
	size_t soap_flag_PeriodicityStatusInfo1 = 1;
	size_t soap_flag_ResultDetails1 = 1;
	size_t soap_flag_Sample1 = 1;
	size_t soap_flag_UnitsName1 = 1;
	size_t soap_flag_Value1 = 1;
	size_t soap_flag_ValueDigAfterPoint1 = 1;
	size_t soap_flag_ValueStatus1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AccuracyStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons10__EResultStatus(soap, "ns10:AccuracyStatus", &a->ns10__EResult::AccuracyStatus, "ns10:EResultStatus"))
				{	soap_flag_AccuracyStatus1--;
					continue;
				}
			}
			if (soap_flag_AccuracyStatusInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns10:AccuracyStatusInfo", &a->ns10__EResult::AccuracyStatusInfo, "xsd:string"))
				{	soap_flag_AccuracyStatusInfo1--;
					continue;
				}
			}
			if (soap_flag_ComponentCode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns10:ComponentCode", &a->ns10__EResult::ComponentCode, "xsd:int"))
				{	soap_flag_ComponentCode1--;
					continue;
				}
			}
			if (soap_flag_ComponentName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns10:ComponentName", &a->ns10__EResult::ComponentName, "xsd:string"))
				{	soap_flag_ComponentName1--;
					continue;
				}
			}
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns10:Id", &a->ns10__EResult::Id, "xsd:int"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_IntervalValueBorder1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__decimal(soap, "ns10:IntervalValueBorder", &a->ns10__EResult::IntervalValueBorder, "xsd:decimal"))
				{	soap_flag_IntervalValueBorder1--;
					continue;
				}
			}
			if (soap_flag_PeriodicityStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons10__EResultStatus(soap, "ns10:PeriodicityStatus", &a->ns10__EResult::PeriodicityStatus, "ns10:EResultStatus"))
				{	soap_flag_PeriodicityStatus1--;
					continue;
				}
			}
			if (soap_flag_PeriodicityStatusInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns10:PeriodicityStatusInfo", &a->ns10__EResult::PeriodicityStatusInfo, "xsd:string"))
				{	soap_flag_PeriodicityStatusInfo1--;
					continue;
				}
			}
			if (soap_flag_ResultDetails1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns10:ResultDetails", &a->ns10__EResult::ResultDetails, "xsd:string"))
				{	soap_flag_ResultDetails1--;
					continue;
				}
			}
			if (soap_flag_Sample1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons10__ESample(soap, "ns10:Sample", &a->ns10__EResult::Sample, "ns10:ESample"))
				{	soap_flag_Sample1--;
					continue;
				}
			}
			if (soap_flag_UnitsName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns10:UnitsName", &a->ns10__EResult::UnitsName, "xsd:string"))
				{	soap_flag_UnitsName1--;
					continue;
				}
			}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__decimal(soap, "ns10:Value", &a->ns10__EResult::Value, "xsd:decimal"))
				{	soap_flag_Value1--;
					continue;
				}
			}
			if (soap_flag_ValueDigAfterPoint1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns10:ValueDigAfterPoint", &a->ns10__EResult::ValueDigAfterPoint, "xsd:int"))
				{	soap_flag_ValueDigAfterPoint1--;
					continue;
				}
			}
			if (soap_flag_ValueStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons10__EResultValueStatus(soap, "ns10:ValueStatus", &a->ns10__EResult::ValueStatus, "ns10:EResultValueStatus"))
				{	soap_flag_ValueStatus1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns10__EResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__EResult, SOAP_TYPE_ns10__EResult, sizeof(ns10__EResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns10__EResult * SOAP_FMAC2 soap_instantiate_ns10__EResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns10__EResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns10__EResult *p;
	size_t k = sizeof(ns10__EResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns10__EResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns10__EResult);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns10__EResult, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns10__EResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns10__EResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns10__EResult(soap, tag ? tag : "ns10:EResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns10__EResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns10__EResult(soap, this, tag, type);
}

SOAP_FMAC3 ns10__EResult * SOAP_FMAC4 soap_get_ns10__EResult(struct soap *soap, ns10__EResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__EResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns10__ArrayOfEResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons10__EResult(soap, &this->ns10__ArrayOfEResult::EResult);
}

void ns10__ArrayOfEResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons10__EResult(soap, &this->ns10__ArrayOfEResult::EResult);
#endif
}

int ns10__ArrayOfEResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns10__ArrayOfEResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__ArrayOfEResult(struct soap *soap, const char *tag, int id, const ns10__ArrayOfEResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__ArrayOfEResult), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons10__EResult(soap, "ns10:EResult", -1, &a->ns10__ArrayOfEResult::EResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns10__ArrayOfEResult::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns10__ArrayOfEResult(soap, tag, this, type);
}

SOAP_FMAC3 ns10__ArrayOfEResult * SOAP_FMAC4 soap_in_ns10__ArrayOfEResult(struct soap *soap, const char *tag, ns10__ArrayOfEResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns10__ArrayOfEResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__ArrayOfEResult, sizeof(ns10__ArrayOfEResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns10__ArrayOfEResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns10__ArrayOfEResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons10__EResult(soap, "ns10:EResult", &a->ns10__ArrayOfEResult::EResult, "ns10:EResult"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns10__ArrayOfEResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__ArrayOfEResult, SOAP_TYPE_ns10__ArrayOfEResult, sizeof(ns10__ArrayOfEResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns10__ArrayOfEResult * SOAP_FMAC2 soap_instantiate_ns10__ArrayOfEResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns10__ArrayOfEResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns10__ArrayOfEResult *p;
	size_t k = sizeof(ns10__ArrayOfEResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns10__ArrayOfEResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns10__ArrayOfEResult);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns10__ArrayOfEResult, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns10__ArrayOfEResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns10__ArrayOfEResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns10__ArrayOfEResult(soap, tag ? tag : "ns10:ArrayOfEResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns10__ArrayOfEResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns10__ArrayOfEResult(soap, this, tag, type);
}

SOAP_FMAC3 ns10__ArrayOfEResult * SOAP_FMAC4 soap_get_ns10__ArrayOfEResult(struct soap *soap, ns10__ArrayOfEResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__ArrayOfEResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns10__ESample::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns10__ESample::BeginAnalyzingDateTime = NULL;
	this->ns10__ESample::BeginSamplingDateTime = NULL;
	this->ns10__ESample::ChromNumber = NULL;
	this->ns10__ESample::EndAnalyzingDateTime = NULL;
	this->ns10__ESample::EndSamplingDateTime = NULL;
	this->ns10__ESample::Id = NULL;
	this->ns10__ESample::Results = NULL;
	this->ns10__ESample::SampleType = NULL;
}

void ns10__ESample::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTodateTime(soap, &this->ns10__ESample::BeginAnalyzingDateTime);
	soap_serialize_PointerTodateTime(soap, &this->ns10__ESample::BeginSamplingDateTime);
	soap_serialize_PointerTostd__string(soap, &this->ns10__ESample::ChromNumber);
	soap_serialize_PointerTodateTime(soap, &this->ns10__ESample::EndAnalyzingDateTime);
	soap_serialize_PointerTodateTime(soap, &this->ns10__ESample::EndSamplingDateTime);
	soap_serialize_PointerToint(soap, &this->ns10__ESample::Id);
	soap_serialize_PointerTons10__ArrayOfEResult(soap, &this->ns10__ESample::Results);
	soap_serialize_PointerTons10__ESampleTypes(soap, &this->ns10__ESample::SampleType);
#endif
}

int ns10__ESample::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns10__ESample(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__ESample(struct soap *soap, const char *tag, int id, const ns10__ESample *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__ESample), type))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns10:BeginAnalyzingDateTime", -1, &a->ns10__ESample::BeginAnalyzingDateTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns10:BeginSamplingDateTime", -1, &a->ns10__ESample::BeginSamplingDateTime, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns10:ChromNumber", -1, &a->ns10__ESample::ChromNumber, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns10:EndAnalyzingDateTime", -1, &a->ns10__ESample::EndAnalyzingDateTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns10:EndSamplingDateTime", -1, &a->ns10__ESample::EndSamplingDateTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns10:Id", -1, &a->ns10__ESample::Id, ""))
		return soap->error;
	if (soap_out_PointerTons10__ArrayOfEResult(soap, "ns10:Results", -1, &a->ns10__ESample::Results, ""))
		return soap->error;
	if (soap_out_PointerTons10__ESampleTypes(soap, "ns10:SampleType", -1, &a->ns10__ESample::SampleType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns10__ESample::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns10__ESample(soap, tag, this, type);
}

SOAP_FMAC3 ns10__ESample * SOAP_FMAC4 soap_in_ns10__ESample(struct soap *soap, const char *tag, ns10__ESample *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns10__ESample*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__ESample, sizeof(ns10__ESample), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns10__ESample)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns10__ESample *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BeginAnalyzingDateTime1 = 1;
	size_t soap_flag_BeginSamplingDateTime1 = 1;
	size_t soap_flag_ChromNumber1 = 1;
	size_t soap_flag_EndAnalyzingDateTime1 = 1;
	size_t soap_flag_EndSamplingDateTime1 = 1;
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Results1 = 1;
	size_t soap_flag_SampleType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BeginAnalyzingDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns10:BeginAnalyzingDateTime", &a->ns10__ESample::BeginAnalyzingDateTime, "xsd:dateTime"))
				{	soap_flag_BeginAnalyzingDateTime1--;
					continue;
				}
			}
			if (soap_flag_BeginSamplingDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns10:BeginSamplingDateTime", &a->ns10__ESample::BeginSamplingDateTime, "xsd:dateTime"))
				{	soap_flag_BeginSamplingDateTime1--;
					continue;
				}
			}
			if (soap_flag_ChromNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns10:ChromNumber", &a->ns10__ESample::ChromNumber, "xsd:string"))
				{	soap_flag_ChromNumber1--;
					continue;
				}
			}
			if (soap_flag_EndAnalyzingDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns10:EndAnalyzingDateTime", &a->ns10__ESample::EndAnalyzingDateTime, "xsd:dateTime"))
				{	soap_flag_EndAnalyzingDateTime1--;
					continue;
				}
			}
			if (soap_flag_EndSamplingDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns10:EndSamplingDateTime", &a->ns10__ESample::EndSamplingDateTime, "xsd:dateTime"))
				{	soap_flag_EndSamplingDateTime1--;
					continue;
				}
			}
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns10:Id", &a->ns10__ESample::Id, "xsd:int"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Results1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons10__ArrayOfEResult(soap, "ns10:Results", &a->ns10__ESample::Results, "ns10:ArrayOfEResult"))
				{	soap_flag_Results1--;
					continue;
				}
			}
			if (soap_flag_SampleType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons10__ESampleTypes(soap, "ns10:SampleType", &a->ns10__ESample::SampleType, "ns10:ESampleTypes"))
				{	soap_flag_SampleType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns10__ESample *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__ESample, SOAP_TYPE_ns10__ESample, sizeof(ns10__ESample), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns10__ESample * SOAP_FMAC2 soap_instantiate_ns10__ESample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns10__ESample(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns10__ESample *p;
	size_t k = sizeof(ns10__ESample);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns10__ESample, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns10__ESample);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns10__ESample, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns10__ESample location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns10__ESample::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns10__ESample(soap, tag ? tag : "ns10:ESample", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns10__ESample::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns10__ESample(soap, this, tag, type);
}

SOAP_FMAC3 ns10__ESample * SOAP_FMAC4 soap_get_ns10__ESample(struct soap *soap, ns10__ESample *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__ESample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns10__ArrayOfESample::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons10__ESample(soap, &this->ns10__ArrayOfESample::ESample);
}

void ns10__ArrayOfESample::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons10__ESample(soap, &this->ns10__ArrayOfESample::ESample);
#endif
}

int ns10__ArrayOfESample::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns10__ArrayOfESample(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__ArrayOfESample(struct soap *soap, const char *tag, int id, const ns10__ArrayOfESample *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__ArrayOfESample), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons10__ESample(soap, "ns10:ESample", -1, &a->ns10__ArrayOfESample::ESample, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns10__ArrayOfESample::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns10__ArrayOfESample(soap, tag, this, type);
}

SOAP_FMAC3 ns10__ArrayOfESample * SOAP_FMAC4 soap_in_ns10__ArrayOfESample(struct soap *soap, const char *tag, ns10__ArrayOfESample *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns10__ArrayOfESample*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__ArrayOfESample, sizeof(ns10__ArrayOfESample), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns10__ArrayOfESample)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns10__ArrayOfESample *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons10__ESample(soap, "ns10:ESample", &a->ns10__ArrayOfESample::ESample, "ns10:ESample"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns10__ArrayOfESample *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__ArrayOfESample, SOAP_TYPE_ns10__ArrayOfESample, sizeof(ns10__ArrayOfESample), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns10__ArrayOfESample * SOAP_FMAC2 soap_instantiate_ns10__ArrayOfESample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns10__ArrayOfESample(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns10__ArrayOfESample *p;
	size_t k = sizeof(ns10__ArrayOfESample);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns10__ArrayOfESample, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns10__ArrayOfESample);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns10__ArrayOfESample, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns10__ArrayOfESample location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns10__ArrayOfESample::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns10__ArrayOfESample(soap, tag ? tag : "ns10:ArrayOfESample", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns10__ArrayOfESample::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns10__ArrayOfESample(soap, this, tag, type);
}

SOAP_FMAC3 ns10__ArrayOfESample * SOAP_FMAC4 soap_get_ns10__ArrayOfESample(struct soap *soap, ns10__ArrayOfESample *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__ArrayOfESample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__AuxDeviceState::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__AuxDeviceState::BitCommand = NULL;
	this->ns7__AuxDeviceState::BitMask = NULL;
	this->ns7__AuxDeviceState::BitStatus = NULL;
	this->ns7__AuxDeviceState::Caption = NULL;
	this->ns7__AuxDeviceState::Id = NULL;
	this->ns7__AuxDeviceState::IsDefault = NULL;
	this->ns7__AuxDeviceState::StateChangeDelay = NULL;
}

void ns7__AuxDeviceState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns7__AuxDeviceState::BitCommand);
	soap_serialize_PointerTostd__string(soap, &this->ns7__AuxDeviceState::BitMask);
	soap_serialize_PointerTostd__string(soap, &this->ns7__AuxDeviceState::BitStatus);
	soap_serialize_PointerTostd__string(soap, &this->ns7__AuxDeviceState::Caption);
	soap_serialize_PointerToxsd__unsignedByte(soap, &this->ns7__AuxDeviceState::Id);
	soap_serialize_PointerTobool(soap, &this->ns7__AuxDeviceState::IsDefault);
	soap_serialize_PointerToint(soap, &this->ns7__AuxDeviceState::StateChangeDelay);
#endif
}

int ns7__AuxDeviceState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__AuxDeviceState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__AuxDeviceState(struct soap *soap, const char *tag, int id, const ns7__AuxDeviceState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__AuxDeviceState), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns7:BitCommand", -1, &a->ns7__AuxDeviceState::BitCommand, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns7:BitMask", -1, &a->ns7__AuxDeviceState::BitMask, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns7:BitStatus", -1, &a->ns7__AuxDeviceState::BitStatus, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns7:Caption", -1, &a->ns7__AuxDeviceState::Caption, ""))
		return soap->error;
	if (soap_out_PointerToxsd__unsignedByte(soap, "ns7:Id", -1, &a->ns7__AuxDeviceState::Id, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns7:IsDefault", -1, &a->ns7__AuxDeviceState::IsDefault, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns7:StateChangeDelay", -1, &a->ns7__AuxDeviceState::StateChangeDelay, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__AuxDeviceState::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__AuxDeviceState(soap, tag, this, type);
}

SOAP_FMAC3 ns7__AuxDeviceState * SOAP_FMAC4 soap_in_ns7__AuxDeviceState(struct soap *soap, const char *tag, ns7__AuxDeviceState *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__AuxDeviceState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__AuxDeviceState, sizeof(ns7__AuxDeviceState), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__AuxDeviceState)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__AuxDeviceState *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BitCommand1 = 1;
	size_t soap_flag_BitMask1 = 1;
	size_t soap_flag_BitStatus1 = 1;
	size_t soap_flag_Caption1 = 1;
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_IsDefault1 = 1;
	size_t soap_flag_StateChangeDelay1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BitCommand1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns7:BitCommand", &a->ns7__AuxDeviceState::BitCommand, "xsd:string"))
				{	soap_flag_BitCommand1--;
					continue;
				}
			}
			if (soap_flag_BitMask1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns7:BitMask", &a->ns7__AuxDeviceState::BitMask, "xsd:string"))
				{	soap_flag_BitMask1--;
					continue;
				}
			}
			if (soap_flag_BitStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns7:BitStatus", &a->ns7__AuxDeviceState::BitStatus, "xsd:string"))
				{	soap_flag_BitStatus1--;
					continue;
				}
			}
			if (soap_flag_Caption1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns7:Caption", &a->ns7__AuxDeviceState::Caption, "xsd:string"))
				{	soap_flag_Caption1--;
					continue;
				}
			}
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__unsignedByte(soap, "ns7:Id", &a->ns7__AuxDeviceState::Id, "xsd:unsignedByte"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_IsDefault1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns7:IsDefault", &a->ns7__AuxDeviceState::IsDefault, "xsd:boolean"))
				{	soap_flag_IsDefault1--;
					continue;
				}
			}
			if (soap_flag_StateChangeDelay1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns7:StateChangeDelay", &a->ns7__AuxDeviceState::StateChangeDelay, "xsd:int"))
				{	soap_flag_StateChangeDelay1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__AuxDeviceState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__AuxDeviceState, SOAP_TYPE_ns7__AuxDeviceState, sizeof(ns7__AuxDeviceState), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__AuxDeviceState * SOAP_FMAC2 soap_instantiate_ns7__AuxDeviceState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__AuxDeviceState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__AuxDeviceState *p;
	size_t k = sizeof(ns7__AuxDeviceState);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns7__AuxDeviceState, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns7__AuxDeviceState);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns7__AuxDeviceState, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__AuxDeviceState location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns7__AuxDeviceState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__AuxDeviceState(soap, tag ? tag : "ns7:AuxDeviceState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__AuxDeviceState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__AuxDeviceState(soap, this, tag, type);
}

SOAP_FMAC3 ns7__AuxDeviceState * SOAP_FMAC4 soap_get_ns7__AuxDeviceState(struct soap *soap, ns7__AuxDeviceState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__AuxDeviceState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__ArrayOfAuxDeviceState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__AuxDeviceState(soap, &this->ns7__ArrayOfAuxDeviceState::AuxDeviceState);
}

void ns7__ArrayOfAuxDeviceState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__AuxDeviceState(soap, &this->ns7__ArrayOfAuxDeviceState::AuxDeviceState);
#endif
}

int ns7__ArrayOfAuxDeviceState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ArrayOfAuxDeviceState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__ArrayOfAuxDeviceState(struct soap *soap, const char *tag, int id, const ns7__ArrayOfAuxDeviceState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ArrayOfAuxDeviceState), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__AuxDeviceState(soap, "ns7:AuxDeviceState", -1, &a->ns7__ArrayOfAuxDeviceState::AuxDeviceState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__ArrayOfAuxDeviceState::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__ArrayOfAuxDeviceState(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ArrayOfAuxDeviceState * SOAP_FMAC4 soap_in_ns7__ArrayOfAuxDeviceState(struct soap *soap, const char *tag, ns7__ArrayOfAuxDeviceState *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ArrayOfAuxDeviceState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ArrayOfAuxDeviceState, sizeof(ns7__ArrayOfAuxDeviceState), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__ArrayOfAuxDeviceState)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__ArrayOfAuxDeviceState *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__AuxDeviceState(soap, "ns7:AuxDeviceState", &a->ns7__ArrayOfAuxDeviceState::AuxDeviceState, "ns7:AuxDeviceState"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__ArrayOfAuxDeviceState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ArrayOfAuxDeviceState, SOAP_TYPE_ns7__ArrayOfAuxDeviceState, sizeof(ns7__ArrayOfAuxDeviceState), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__ArrayOfAuxDeviceState * SOAP_FMAC2 soap_instantiate_ns7__ArrayOfAuxDeviceState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ArrayOfAuxDeviceState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__ArrayOfAuxDeviceState *p;
	size_t k = sizeof(ns7__ArrayOfAuxDeviceState);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns7__ArrayOfAuxDeviceState, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns7__ArrayOfAuxDeviceState);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns7__ArrayOfAuxDeviceState, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__ArrayOfAuxDeviceState location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns7__ArrayOfAuxDeviceState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__ArrayOfAuxDeviceState(soap, tag ? tag : "ns7:ArrayOfAuxDeviceState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__ArrayOfAuxDeviceState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ArrayOfAuxDeviceState(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ArrayOfAuxDeviceState * SOAP_FMAC4 soap_get_ns7__ArrayOfAuxDeviceState(struct soap *soap, ns7__ArrayOfAuxDeviceState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__ArrayOfAuxDeviceState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__AuxDevice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__AuxDevice::Caption = NULL;
	this->ns7__AuxDevice::Id = NULL;
	this->ns7__AuxDevice::States = NULL;
}

void ns7__AuxDevice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns7__AuxDevice::Caption);
	soap_serialize_PointerToxsd__unsignedByte(soap, &this->ns7__AuxDevice::Id);
	soap_serialize_PointerTons7__ArrayOfAuxDeviceState(soap, &this->ns7__AuxDevice::States);
#endif
}

int ns7__AuxDevice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__AuxDevice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__AuxDevice(struct soap *soap, const char *tag, int id, const ns7__AuxDevice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__AuxDevice), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns7:Caption", -1, &a->ns7__AuxDevice::Caption, ""))
		return soap->error;
	if (soap_out_PointerToxsd__unsignedByte(soap, "ns7:Id", -1, &a->ns7__AuxDevice::Id, ""))
		return soap->error;
	if (soap_out_PointerTons7__ArrayOfAuxDeviceState(soap, "ns7:States", -1, &a->ns7__AuxDevice::States, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__AuxDevice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__AuxDevice(soap, tag, this, type);
}

SOAP_FMAC3 ns7__AuxDevice * SOAP_FMAC4 soap_in_ns7__AuxDevice(struct soap *soap, const char *tag, ns7__AuxDevice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__AuxDevice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__AuxDevice, sizeof(ns7__AuxDevice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__AuxDevice)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__AuxDevice *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Caption1 = 1;
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_States1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Caption1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns7:Caption", &a->ns7__AuxDevice::Caption, "xsd:string"))
				{	soap_flag_Caption1--;
					continue;
				}
			}
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__unsignedByte(soap, "ns7:Id", &a->ns7__AuxDevice::Id, "xsd:unsignedByte"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_States1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__ArrayOfAuxDeviceState(soap, "ns7:States", &a->ns7__AuxDevice::States, "ns7:ArrayOfAuxDeviceState"))
				{	soap_flag_States1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__AuxDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__AuxDevice, SOAP_TYPE_ns7__AuxDevice, sizeof(ns7__AuxDevice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__AuxDevice * SOAP_FMAC2 soap_instantiate_ns7__AuxDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__AuxDevice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__AuxDevice *p;
	size_t k = sizeof(ns7__AuxDevice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns7__AuxDevice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns7__AuxDevice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns7__AuxDevice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__AuxDevice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns7__AuxDevice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__AuxDevice(soap, tag ? tag : "ns7:AuxDevice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__AuxDevice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__AuxDevice(soap, this, tag, type);
}

SOAP_FMAC3 ns7__AuxDevice * SOAP_FMAC4 soap_get_ns7__AuxDevice(struct soap *soap, ns7__AuxDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__AuxDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__ArrayOfAuxDevice::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__AuxDevice(soap, &this->ns7__ArrayOfAuxDevice::AuxDevice);
}

void ns7__ArrayOfAuxDevice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__AuxDevice(soap, &this->ns7__ArrayOfAuxDevice::AuxDevice);
#endif
}

int ns7__ArrayOfAuxDevice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ArrayOfAuxDevice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__ArrayOfAuxDevice(struct soap *soap, const char *tag, int id, const ns7__ArrayOfAuxDevice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ArrayOfAuxDevice), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__AuxDevice(soap, "ns7:AuxDevice", -1, &a->ns7__ArrayOfAuxDevice::AuxDevice, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__ArrayOfAuxDevice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__ArrayOfAuxDevice(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ArrayOfAuxDevice * SOAP_FMAC4 soap_in_ns7__ArrayOfAuxDevice(struct soap *soap, const char *tag, ns7__ArrayOfAuxDevice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ArrayOfAuxDevice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ArrayOfAuxDevice, sizeof(ns7__ArrayOfAuxDevice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__ArrayOfAuxDevice)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__ArrayOfAuxDevice *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__AuxDevice(soap, "ns7:AuxDevice", &a->ns7__ArrayOfAuxDevice::AuxDevice, "ns7:AuxDevice"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__ArrayOfAuxDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ArrayOfAuxDevice, SOAP_TYPE_ns7__ArrayOfAuxDevice, sizeof(ns7__ArrayOfAuxDevice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__ArrayOfAuxDevice * SOAP_FMAC2 soap_instantiate_ns7__ArrayOfAuxDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ArrayOfAuxDevice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__ArrayOfAuxDevice *p;
	size_t k = sizeof(ns7__ArrayOfAuxDevice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns7__ArrayOfAuxDevice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns7__ArrayOfAuxDevice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns7__ArrayOfAuxDevice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__ArrayOfAuxDevice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns7__ArrayOfAuxDevice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__ArrayOfAuxDevice(soap, tag ? tag : "ns7:ArrayOfAuxDevice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__ArrayOfAuxDevice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ArrayOfAuxDevice(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ArrayOfAuxDevice * SOAP_FMAC4 soap_get_ns7__ArrayOfAuxDevice(struct soap *soap, ns7__ArrayOfAuxDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__ArrayOfAuxDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__AuxControllerConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__AuxControllerConfiguration::CommandExecuteRetries = NULL;
	this->ns7__AuxControllerConfiguration::CommandExecuteRetriesDelay = NULL;
	this->ns7__AuxControllerConfiguration::Devices = NULL;
	this->ns7__AuxControllerConfiguration::PortNumber = NULL;
}

void ns7__AuxControllerConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->ns7__AuxControllerConfiguration::CommandExecuteRetries);
	soap_serialize_PointerToint(soap, &this->ns7__AuxControllerConfiguration::CommandExecuteRetriesDelay);
	soap_serialize_PointerTons7__ArrayOfAuxDevice(soap, &this->ns7__AuxControllerConfiguration::Devices);
	soap_serialize_PointerTostd__string(soap, &this->ns7__AuxControllerConfiguration::PortNumber);
#endif
}

int ns7__AuxControllerConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__AuxControllerConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__AuxControllerConfiguration(struct soap *soap, const char *tag, int id, const ns7__AuxControllerConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__AuxControllerConfiguration), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns7:CommandExecuteRetries", -1, &a->ns7__AuxControllerConfiguration::CommandExecuteRetries, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns7:CommandExecuteRetriesDelay", -1, &a->ns7__AuxControllerConfiguration::CommandExecuteRetriesDelay, ""))
		return soap->error;
	if (soap_out_PointerTons7__ArrayOfAuxDevice(soap, "ns7:Devices", -1, &a->ns7__AuxControllerConfiguration::Devices, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns7:PortNumber", -1, &a->ns7__AuxControllerConfiguration::PortNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__AuxControllerConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__AuxControllerConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 ns7__AuxControllerConfiguration * SOAP_FMAC4 soap_in_ns7__AuxControllerConfiguration(struct soap *soap, const char *tag, ns7__AuxControllerConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__AuxControllerConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__AuxControllerConfiguration, sizeof(ns7__AuxControllerConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__AuxControllerConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__AuxControllerConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CommandExecuteRetries1 = 1;
	size_t soap_flag_CommandExecuteRetriesDelay1 = 1;
	size_t soap_flag_Devices1 = 1;
	size_t soap_flag_PortNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CommandExecuteRetries1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns7:CommandExecuteRetries", &a->ns7__AuxControllerConfiguration::CommandExecuteRetries, "xsd:int"))
				{	soap_flag_CommandExecuteRetries1--;
					continue;
				}
			}
			if (soap_flag_CommandExecuteRetriesDelay1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns7:CommandExecuteRetriesDelay", &a->ns7__AuxControllerConfiguration::CommandExecuteRetriesDelay, "xsd:int"))
				{	soap_flag_CommandExecuteRetriesDelay1--;
					continue;
				}
			}
			if (soap_flag_Devices1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__ArrayOfAuxDevice(soap, "ns7:Devices", &a->ns7__AuxControllerConfiguration::Devices, "ns7:ArrayOfAuxDevice"))
				{	soap_flag_Devices1--;
					continue;
				}
			}
			if (soap_flag_PortNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns7:PortNumber", &a->ns7__AuxControllerConfiguration::PortNumber, "xsd:string"))
				{	soap_flag_PortNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__AuxControllerConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__AuxControllerConfiguration, SOAP_TYPE_ns7__AuxControllerConfiguration, sizeof(ns7__AuxControllerConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__AuxControllerConfiguration * SOAP_FMAC2 soap_instantiate_ns7__AuxControllerConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__AuxControllerConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__AuxControllerConfiguration *p;
	size_t k = sizeof(ns7__AuxControllerConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns7__AuxControllerConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns7__AuxControllerConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns7__AuxControllerConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__AuxControllerConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns7__AuxControllerConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__AuxControllerConfiguration(soap, tag ? tag : "ns7:AuxControllerConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__AuxControllerConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__AuxControllerConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 ns7__AuxControllerConfiguration * SOAP_FMAC4 soap_get_ns7__AuxControllerConfiguration(struct soap *soap, ns7__AuxControllerConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__AuxControllerConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__Aux2Config::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__Aux2Config::PortNumber = NULL;
}

void ns6__Aux2Config::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns6__Aux2Config::PortNumber);
#endif
}

int ns6__Aux2Config::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Aux2Config(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__Aux2Config(struct soap *soap, const char *tag, int id, const ns6__Aux2Config *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Aux2Config), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns6:PortNumber", -1, &a->ns6__Aux2Config::PortNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__Aux2Config::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Aux2Config(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Aux2Config * SOAP_FMAC4 soap_in_ns6__Aux2Config(struct soap *soap, const char *tag, ns6__Aux2Config *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Aux2Config*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Aux2Config, sizeof(ns6__Aux2Config), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__Aux2Config)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__Aux2Config *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PortNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PortNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns6:PortNumber", &a->ns6__Aux2Config::PortNumber, "xsd:string"))
				{	soap_flag_PortNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__Aux2Config *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Aux2Config, SOAP_TYPE_ns6__Aux2Config, sizeof(ns6__Aux2Config), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__Aux2Config * SOAP_FMAC2 soap_instantiate_ns6__Aux2Config(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Aux2Config(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__Aux2Config *p;
	size_t k = sizeof(ns6__Aux2Config);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns6__Aux2Config, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns6__Aux2Config);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns6__Aux2Config, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__Aux2Config location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns6__Aux2Config::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__Aux2Config(soap, tag ? tag : "ns6:Aux2Config", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__Aux2Config::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Aux2Config(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Aux2Config * SOAP_FMAC4 soap_get_ns6__Aux2Config(struct soap *soap, ns6__Aux2Config *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__Aux2Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SystemConfigurations::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__SystemConfigurations::AutoPlanItems = NULL;
	this->ns5__SystemConfigurations::Aux2Device_USCOREActive = NULL;
	this->ns5__SystemConfigurations::Aux2Device_USCOREConfiguration = NULL;
	this->ns5__SystemConfigurations::AuxDevice_USCOREActive = NULL;
	this->ns5__SystemConfigurations::AuxDevice_USCOREConfiguration = NULL;
	this->ns5__SystemConfigurations::ChromatecDirectAnalyticSlaveAddress = NULL;
	this->ns5__SystemConfigurations::ChromatecDirectPanelSlaveAddress = NULL;
	this->ns5__SystemConfigurations::ChromatecMODBUSServiceAddress = NULL;
	this->ns5__SystemConfigurations::Clearing_USCOREUseCriticalZone = NULL;
	this->ns5__SystemConfigurations::Clearing_USCOREUseWaitTime = NULL;
	this->ns5__SystemConfigurations::Clearing_USCOREWaitTimeSeconds = NULL;
	this->ns5__SystemConfigurations::Common_USCOREConfiguratorPasswordHash = NULL;
	this->ns5__SystemConfigurations::Common_USCOREConfiguratorPasswordSalt = NULL;
	this->ns5__SystemConfigurations::Common_USCORELogLevel = NULL;
	this->ns5__SystemConfigurations::Common_USCOREServiceName = NULL;
	this->ns5__SystemConfigurations::Common_USCOREWCFServicePrefix = NULL;
	this->ns5__SystemConfigurations::Common_USCOREWindowTitle = NULL;
	this->ns5__SystemConfigurations::ControlledParametrs = NULL;
	this->ns5__SystemConfigurations::MeasuringComponents = NULL;
	this->ns5__SystemConfigurations::Operations = NULL;
	this->ns5__SystemConfigurations::StopAutoPlanOnOperationError = NULL;
}

void ns5__SystemConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__ArrayOfAutoPlanItem(soap, &this->ns5__SystemConfigurations::AutoPlanItems);
	soap_serialize_PointerTobool(soap, &this->ns5__SystemConfigurations::Aux2Device_USCOREActive);
	soap_serialize_PointerTons6__Aux2Config(soap, &this->ns5__SystemConfigurations::Aux2Device_USCOREConfiguration);
	soap_serialize_PointerTobool(soap, &this->ns5__SystemConfigurations::AuxDevice_USCOREActive);
	soap_serialize_PointerTons7__AuxControllerConfiguration(soap, &this->ns5__SystemConfigurations::AuxDevice_USCOREConfiguration);
	soap_serialize_PointerToxsd__unsignedByte(soap, &this->ns5__SystemConfigurations::ChromatecDirectAnalyticSlaveAddress);
	soap_serialize_PointerToxsd__unsignedByte(soap, &this->ns5__SystemConfigurations::ChromatecDirectPanelSlaveAddress);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SystemConfigurations::ChromatecMODBUSServiceAddress);
	soap_serialize_PointerTobool(soap, &this->ns5__SystemConfigurations::Clearing_USCOREUseCriticalZone);
	soap_serialize_PointerTobool(soap, &this->ns5__SystemConfigurations::Clearing_USCOREUseWaitTime);
	soap_serialize_PointerToint(soap, &this->ns5__SystemConfigurations::Clearing_USCOREWaitTimeSeconds);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SystemConfigurations::Common_USCOREConfiguratorPasswordHash);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SystemConfigurations::Common_USCOREConfiguratorPasswordSalt);
	soap_serialize_PointerTons8__Logger_x002eLogLevel(soap, &this->ns5__SystemConfigurations::Common_USCORELogLevel);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SystemConfigurations::Common_USCOREServiceName);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SystemConfigurations::Common_USCOREWCFServicePrefix);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SystemConfigurations::Common_USCOREWindowTitle);
	soap_serialize_PointerTons4__ArrayOfControlledParametr(soap, &this->ns5__SystemConfigurations::ControlledParametrs);
	soap_serialize_PointerTons4__ArrayOfMeasuringComponent(soap, &this->ns5__SystemConfigurations::MeasuringComponents);
	soap_serialize_PointerTons4__ArrayOfOperation(soap, &this->ns5__SystemConfigurations::Operations);
	soap_serialize_PointerTobool(soap, &this->ns5__SystemConfigurations::StopAutoPlanOnOperationError);
#endif
}

int ns5__SystemConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SystemConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SystemConfigurations(struct soap *soap, const char *tag, int id, const ns5__SystemConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SystemConfigurations), type))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfAutoPlanItem(soap, "ns5:AutoPlanItems", -1, &a->ns5__SystemConfigurations::AutoPlanItems, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns5:Aux2Device_Active", -1, &a->ns5__SystemConfigurations::Aux2Device_USCOREActive, ""))
		return soap->error;
	if (soap_out_PointerTons6__Aux2Config(soap, "ns5:Aux2Device_Configuration", -1, &a->ns5__SystemConfigurations::Aux2Device_USCOREConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns5:AuxDevice_Active", -1, &a->ns5__SystemConfigurations::AuxDevice_USCOREActive, ""))
		return soap->error;
	if (soap_out_PointerTons7__AuxControllerConfiguration(soap, "ns5:AuxDevice_Configuration", -1, &a->ns5__SystemConfigurations::AuxDevice_USCOREConfiguration, ""))
		return soap->error;
	if (soap_out_PointerToxsd__unsignedByte(soap, "ns5:ChromatecDirectAnalyticSlaveAddress", -1, &a->ns5__SystemConfigurations::ChromatecDirectAnalyticSlaveAddress, ""))
		return soap->error;
	if (soap_out_PointerToxsd__unsignedByte(soap, "ns5:ChromatecDirectPanelSlaveAddress", -1, &a->ns5__SystemConfigurations::ChromatecDirectPanelSlaveAddress, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:ChromatecMODBUSServiceAddress", -1, &a->ns5__SystemConfigurations::ChromatecMODBUSServiceAddress, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns5:Clearing_UseCriticalZone", -1, &a->ns5__SystemConfigurations::Clearing_USCOREUseCriticalZone, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns5:Clearing_UseWaitTime", -1, &a->ns5__SystemConfigurations::Clearing_USCOREUseWaitTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns5:Clearing_WaitTimeSeconds", -1, &a->ns5__SystemConfigurations::Clearing_USCOREWaitTimeSeconds, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:Common_ConfiguratorPasswordHash", -1, &a->ns5__SystemConfigurations::Common_USCOREConfiguratorPasswordHash, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:Common_ConfiguratorPasswordSalt", -1, &a->ns5__SystemConfigurations::Common_USCOREConfiguratorPasswordSalt, ""))
		return soap->error;
	if (soap_out_PointerTons8__Logger_x002eLogLevel(soap, "ns5:Common_LogLevel", -1, &a->ns5__SystemConfigurations::Common_USCORELogLevel, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:Common_ServiceName", -1, &a->ns5__SystemConfigurations::Common_USCOREServiceName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:Common_WCFServicePrefix", -1, &a->ns5__SystemConfigurations::Common_USCOREWCFServicePrefix, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:Common_WindowTitle", -1, &a->ns5__SystemConfigurations::Common_USCOREWindowTitle, ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfControlledParametr(soap, "ns5:ControlledParametrs", -1, &a->ns5__SystemConfigurations::ControlledParametrs, ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfMeasuringComponent(soap, "ns5:MeasuringComponents", -1, &a->ns5__SystemConfigurations::MeasuringComponents, ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfOperation(soap, "ns5:Operations", -1, &a->ns5__SystemConfigurations::Operations, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns5:StopAutoPlanOnOperationError", -1, &a->ns5__SystemConfigurations::StopAutoPlanOnOperationError, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SystemConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__SystemConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SystemConfigurations * SOAP_FMAC4 soap_in_ns5__SystemConfigurations(struct soap *soap, const char *tag, ns5__SystemConfigurations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SystemConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SystemConfigurations, sizeof(ns5__SystemConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SystemConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SystemConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AutoPlanItems1 = 1;
	size_t soap_flag_Aux2Device_USCOREActive1 = 1;
	size_t soap_flag_Aux2Device_USCOREConfiguration1 = 1;
	size_t soap_flag_AuxDevice_USCOREActive1 = 1;
	size_t soap_flag_AuxDevice_USCOREConfiguration1 = 1;
	size_t soap_flag_ChromatecDirectAnalyticSlaveAddress1 = 1;
	size_t soap_flag_ChromatecDirectPanelSlaveAddress1 = 1;
	size_t soap_flag_ChromatecMODBUSServiceAddress1 = 1;
	size_t soap_flag_Clearing_USCOREUseCriticalZone1 = 1;
	size_t soap_flag_Clearing_USCOREUseWaitTime1 = 1;
	size_t soap_flag_Clearing_USCOREWaitTimeSeconds1 = 1;
	size_t soap_flag_Common_USCOREConfiguratorPasswordHash1 = 1;
	size_t soap_flag_Common_USCOREConfiguratorPasswordSalt1 = 1;
	size_t soap_flag_Common_USCORELogLevel1 = 1;
	size_t soap_flag_Common_USCOREServiceName1 = 1;
	size_t soap_flag_Common_USCOREWCFServicePrefix1 = 1;
	size_t soap_flag_Common_USCOREWindowTitle1 = 1;
	size_t soap_flag_ControlledParametrs1 = 1;
	size_t soap_flag_MeasuringComponents1 = 1;
	size_t soap_flag_Operations1 = 1;
	size_t soap_flag_StopAutoPlanOnOperationError1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoPlanItems1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons4__ArrayOfAutoPlanItem(soap, "ns5:AutoPlanItems", &a->ns5__SystemConfigurations::AutoPlanItems, "ns4:ArrayOfAutoPlanItem"))
				{	soap_flag_AutoPlanItems1--;
					continue;
				}
			}
			if (soap_flag_Aux2Device_USCOREActive1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns5:Aux2Device_Active", &a->ns5__SystemConfigurations::Aux2Device_USCOREActive, "xsd:boolean"))
				{	soap_flag_Aux2Device_USCOREActive1--;
					continue;
				}
			}
			if (soap_flag_Aux2Device_USCOREConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__Aux2Config(soap, "ns5:Aux2Device_Configuration", &a->ns5__SystemConfigurations::Aux2Device_USCOREConfiguration, "ns6:Aux2Config"))
				{	soap_flag_Aux2Device_USCOREConfiguration1--;
					continue;
				}
			}
			if (soap_flag_AuxDevice_USCOREActive1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns5:AuxDevice_Active", &a->ns5__SystemConfigurations::AuxDevice_USCOREActive, "xsd:boolean"))
				{	soap_flag_AuxDevice_USCOREActive1--;
					continue;
				}
			}
			if (soap_flag_AuxDevice_USCOREConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__AuxControllerConfiguration(soap, "ns5:AuxDevice_Configuration", &a->ns5__SystemConfigurations::AuxDevice_USCOREConfiguration, "ns7:AuxControllerConfiguration"))
				{	soap_flag_AuxDevice_USCOREConfiguration1--;
					continue;
				}
			}
			if (soap_flag_ChromatecDirectAnalyticSlaveAddress1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__unsignedByte(soap, "ns5:ChromatecDirectAnalyticSlaveAddress", &a->ns5__SystemConfigurations::ChromatecDirectAnalyticSlaveAddress, "xsd:unsignedByte"))
				{	soap_flag_ChromatecDirectAnalyticSlaveAddress1--;
					continue;
				}
			}
			if (soap_flag_ChromatecDirectPanelSlaveAddress1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__unsignedByte(soap, "ns5:ChromatecDirectPanelSlaveAddress", &a->ns5__SystemConfigurations::ChromatecDirectPanelSlaveAddress, "xsd:unsignedByte"))
				{	soap_flag_ChromatecDirectPanelSlaveAddress1--;
					continue;
				}
			}
			if (soap_flag_ChromatecMODBUSServiceAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:ChromatecMODBUSServiceAddress", &a->ns5__SystemConfigurations::ChromatecMODBUSServiceAddress, "xsd:string"))
				{	soap_flag_ChromatecMODBUSServiceAddress1--;
					continue;
				}
			}
			if (soap_flag_Clearing_USCOREUseCriticalZone1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns5:Clearing_UseCriticalZone", &a->ns5__SystemConfigurations::Clearing_USCOREUseCriticalZone, "xsd:boolean"))
				{	soap_flag_Clearing_USCOREUseCriticalZone1--;
					continue;
				}
			}
			if (soap_flag_Clearing_USCOREUseWaitTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns5:Clearing_UseWaitTime", &a->ns5__SystemConfigurations::Clearing_USCOREUseWaitTime, "xsd:boolean"))
				{	soap_flag_Clearing_USCOREUseWaitTime1--;
					continue;
				}
			}
			if (soap_flag_Clearing_USCOREWaitTimeSeconds1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns5:Clearing_WaitTimeSeconds", &a->ns5__SystemConfigurations::Clearing_USCOREWaitTimeSeconds, "xsd:int"))
				{	soap_flag_Clearing_USCOREWaitTimeSeconds1--;
					continue;
				}
			}
			if (soap_flag_Common_USCOREConfiguratorPasswordHash1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Common_ConfiguratorPasswordHash", &a->ns5__SystemConfigurations::Common_USCOREConfiguratorPasswordHash, "xsd:string"))
				{	soap_flag_Common_USCOREConfiguratorPasswordHash1--;
					continue;
				}
			}
			if (soap_flag_Common_USCOREConfiguratorPasswordSalt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Common_ConfiguratorPasswordSalt", &a->ns5__SystemConfigurations::Common_USCOREConfiguratorPasswordSalt, "xsd:string"))
				{	soap_flag_Common_USCOREConfiguratorPasswordSalt1--;
					continue;
				}
			}
			if (soap_flag_Common_USCORELogLevel1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons8__Logger_x002eLogLevel(soap, "ns5:Common_LogLevel", &a->ns5__SystemConfigurations::Common_USCORELogLevel, "ns8:Logger.LogLevel"))
				{	soap_flag_Common_USCORELogLevel1--;
					continue;
				}
			}
			if (soap_flag_Common_USCOREServiceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Common_ServiceName", &a->ns5__SystemConfigurations::Common_USCOREServiceName, "xsd:string"))
				{	soap_flag_Common_USCOREServiceName1--;
					continue;
				}
			}
			if (soap_flag_Common_USCOREWCFServicePrefix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Common_WCFServicePrefix", &a->ns5__SystemConfigurations::Common_USCOREWCFServicePrefix, "xsd:string"))
				{	soap_flag_Common_USCOREWCFServicePrefix1--;
					continue;
				}
			}
			if (soap_flag_Common_USCOREWindowTitle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Common_WindowTitle", &a->ns5__SystemConfigurations::Common_USCOREWindowTitle, "xsd:string"))
				{	soap_flag_Common_USCOREWindowTitle1--;
					continue;
				}
			}
			if (soap_flag_ControlledParametrs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons4__ArrayOfControlledParametr(soap, "ns5:ControlledParametrs", &a->ns5__SystemConfigurations::ControlledParametrs, "ns4:ArrayOfControlledParametr"))
				{	soap_flag_ControlledParametrs1--;
					continue;
				}
			}
			if (soap_flag_MeasuringComponents1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons4__ArrayOfMeasuringComponent(soap, "ns5:MeasuringComponents", &a->ns5__SystemConfigurations::MeasuringComponents, "ns4:ArrayOfMeasuringComponent"))
				{	soap_flag_MeasuringComponents1--;
					continue;
				}
			}
			if (soap_flag_Operations1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons4__ArrayOfOperation(soap, "ns5:Operations", &a->ns5__SystemConfigurations::Operations, "ns4:ArrayOfOperation"))
				{	soap_flag_Operations1--;
					continue;
				}
			}
			if (soap_flag_StopAutoPlanOnOperationError1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns5:StopAutoPlanOnOperationError", &a->ns5__SystemConfigurations::StopAutoPlanOnOperationError, "xsd:boolean"))
				{	soap_flag_StopAutoPlanOnOperationError1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__SystemConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SystemConfigurations, SOAP_TYPE_ns5__SystemConfigurations, sizeof(ns5__SystemConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SystemConfigurations * SOAP_FMAC2 soap_instantiate_ns5__SystemConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SystemConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SystemConfigurations *p;
	size_t k = sizeof(ns5__SystemConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns5__SystemConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns5__SystemConfigurations);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns5__SystemConfigurations, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SystemConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns5__SystemConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SystemConfigurations(soap, tag ? tag : "ns5:SystemConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SystemConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SystemConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SystemConfigurations * SOAP_FMAC4 soap_get_ns5__SystemConfigurations(struct soap *soap, ns5__SystemConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SystemConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void arr__ArrayOfboolean::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfbool(soap, &this->arr__ArrayOfboolean::boolean);
}

void arr__ArrayOfboolean::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfbool(soap, &this->arr__ArrayOfboolean::boolean);
#endif
}

int arr__ArrayOfboolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_arr__ArrayOfboolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_arr__ArrayOfboolean(struct soap *soap, const char *tag, int id, const arr__ArrayOfboolean *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_arr__ArrayOfboolean), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfbool(soap, "arr:boolean", -1, &a->arr__ArrayOfboolean::boolean, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *arr__ArrayOfboolean::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_arr__ArrayOfboolean(soap, tag, this, type);
}

SOAP_FMAC3 arr__ArrayOfboolean * SOAP_FMAC4 soap_in_arr__ArrayOfboolean(struct soap *soap, const char *tag, arr__ArrayOfboolean *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (arr__ArrayOfboolean*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_arr__ArrayOfboolean, sizeof(arr__ArrayOfboolean), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_arr__ArrayOfboolean)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (arr__ArrayOfboolean *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfbool(soap, "arr:boolean", &a->arr__ArrayOfboolean::boolean, "xsd:boolean"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (arr__ArrayOfboolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_arr__ArrayOfboolean, SOAP_TYPE_arr__ArrayOfboolean, sizeof(arr__ArrayOfboolean), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 arr__ArrayOfboolean * SOAP_FMAC2 soap_instantiate_arr__ArrayOfboolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_arr__ArrayOfboolean(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	arr__ArrayOfboolean *p;
	size_t k = sizeof(arr__ArrayOfboolean);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_arr__ArrayOfboolean, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, arr__ArrayOfboolean);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, arr__ArrayOfboolean, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated arr__ArrayOfboolean location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int arr__ArrayOfboolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_arr__ArrayOfboolean(soap, tag ? tag : "arr:ArrayOfboolean", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *arr__ArrayOfboolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_arr__ArrayOfboolean(soap, this, tag, type);
}

SOAP_FMAC3 arr__ArrayOfboolean * SOAP_FMAC4 soap_get_arr__ArrayOfboolean(struct soap *soap, arr__ArrayOfboolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_arr__ArrayOfboolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void arr__ArrayOfstring::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->arr__ArrayOfstring::string);
}

void arr__ArrayOfstring::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->arr__ArrayOfstring::string);
#endif
}

int arr__ArrayOfstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_arr__ArrayOfstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_arr__ArrayOfstring(struct soap *soap, const char *tag, int id, const arr__ArrayOfstring *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_arr__ArrayOfstring), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "arr:string", -1, &a->arr__ArrayOfstring::string, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *arr__ArrayOfstring::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_arr__ArrayOfstring(soap, tag, this, type);
}

SOAP_FMAC3 arr__ArrayOfstring * SOAP_FMAC4 soap_in_arr__ArrayOfstring(struct soap *soap, const char *tag, arr__ArrayOfstring *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (arr__ArrayOfstring*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_arr__ArrayOfstring, sizeof(arr__ArrayOfstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_arr__ArrayOfstring)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (arr__ArrayOfstring *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "arr:string", &a->arr__ArrayOfstring::string, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (arr__ArrayOfstring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_arr__ArrayOfstring, SOAP_TYPE_arr__ArrayOfstring, sizeof(arr__ArrayOfstring), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 arr__ArrayOfstring * SOAP_FMAC2 soap_instantiate_arr__ArrayOfstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_arr__ArrayOfstring(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	arr__ArrayOfstring *p;
	size_t k = sizeof(arr__ArrayOfstring);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_arr__ArrayOfstring, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, arr__ArrayOfstring);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, arr__ArrayOfstring, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated arr__ArrayOfstring location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int arr__ArrayOfstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_arr__ArrayOfstring(soap, tag ? tag : "arr:ArrayOfstring", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *arr__ArrayOfstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_arr__ArrayOfstring(soap, this, tag, type);
}

SOAP_FMAC3 arr__ArrayOfstring * SOAP_FMAC4 soap_get_arr__ArrayOfstring(struct soap *soap, arr__ArrayOfstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_arr__ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__OperationStep_x002eUsingControlledParametr::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__OperationStep_x002eUsingControlledParametr::Active = NULL;
	this->ns4__OperationStep_x002eUsingControlledParametr::ParamName = NULL;
}

void ns4__OperationStep_x002eUsingControlledParametr::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->ns4__OperationStep_x002eUsingControlledParametr::Active);
	soap_serialize_PointerTostd__string(soap, &this->ns4__OperationStep_x002eUsingControlledParametr::ParamName);
#endif
}

int ns4__OperationStep_x002eUsingControlledParametr::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__OperationStep_x002eUsingControlledParametr(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__OperationStep_x002eUsingControlledParametr(struct soap *soap, const char *tag, int id, const ns4__OperationStep_x002eUsingControlledParametr *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns4:Active", -1, &a->ns4__OperationStep_x002eUsingControlledParametr::Active, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:ParamName", -1, &a->ns4__OperationStep_x002eUsingControlledParametr::ParamName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__OperationStep_x002eUsingControlledParametr::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__OperationStep_x002eUsingControlledParametr(soap, tag, this, type);
}

SOAP_FMAC3 ns4__OperationStep_x002eUsingControlledParametr * SOAP_FMAC4 soap_in_ns4__OperationStep_x002eUsingControlledParametr(struct soap *soap, const char *tag, ns4__OperationStep_x002eUsingControlledParametr *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__OperationStep_x002eUsingControlledParametr*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr, sizeof(ns4__OperationStep_x002eUsingControlledParametr), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__OperationStep_x002eUsingControlledParametr *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Active1 = 1;
	size_t soap_flag_ParamName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Active1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns4:Active", &a->ns4__OperationStep_x002eUsingControlledParametr::Active, "xsd:boolean"))
				{	soap_flag_Active1--;
					continue;
				}
			}
			if (soap_flag_ParamName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:ParamName", &a->ns4__OperationStep_x002eUsingControlledParametr::ParamName, "xsd:string"))
				{	soap_flag_ParamName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__OperationStep_x002eUsingControlledParametr *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr, SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr, sizeof(ns4__OperationStep_x002eUsingControlledParametr), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__OperationStep_x002eUsingControlledParametr * SOAP_FMAC2 soap_instantiate_ns4__OperationStep_x002eUsingControlledParametr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__OperationStep_x002eUsingControlledParametr(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__OperationStep_x002eUsingControlledParametr *p;
	size_t k = sizeof(ns4__OperationStep_x002eUsingControlledParametr);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__OperationStep_x002eUsingControlledParametr);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__OperationStep_x002eUsingControlledParametr, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__OperationStep_x002eUsingControlledParametr location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__OperationStep_x002eUsingControlledParametr::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__OperationStep_x002eUsingControlledParametr(soap, tag ? tag : "ns4:OperationStep.UsingControlledParametr", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__OperationStep_x002eUsingControlledParametr::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__OperationStep_x002eUsingControlledParametr(soap, this, tag, type);
}

SOAP_FMAC3 ns4__OperationStep_x002eUsingControlledParametr * SOAP_FMAC4 soap_get_ns4__OperationStep_x002eUsingControlledParametr(struct soap *soap, ns4__OperationStep_x002eUsingControlledParametr *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__OperationStep_x002eUsingControlledParametr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__ArrayOfOperationStep_x002eUsingControlledParametr::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr(soap, &this->ns4__ArrayOfOperationStep_x002eUsingControlledParametr::OperationStep_x002eUsingControlledParametr);
}

void ns4__ArrayOfOperationStep_x002eUsingControlledParametr::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr(soap, &this->ns4__ArrayOfOperationStep_x002eUsingControlledParametr::OperationStep_x002eUsingControlledParametr);
#endif
}

int ns4__ArrayOfOperationStep_x002eUsingControlledParametr::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(struct soap *soap, const char *tag, int id, const ns4__ArrayOfOperationStep_x002eUsingControlledParametr *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr(soap, "ns4:OperationStep.UsingControlledParametr", -1, &a->ns4__ArrayOfOperationStep_x002eUsingControlledParametr::OperationStep_x002eUsingControlledParametr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__ArrayOfOperationStep_x002eUsingControlledParametr::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfOperationStep_x002eUsingControlledParametr * SOAP_FMAC4 soap_in_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(struct soap *soap, const char *tag, ns4__ArrayOfOperationStep_x002eUsingControlledParametr *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfOperationStep_x002eUsingControlledParametr*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr, sizeof(ns4__ArrayOfOperationStep_x002eUsingControlledParametr), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__ArrayOfOperationStep_x002eUsingControlledParametr *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr(soap, "ns4:OperationStep.UsingControlledParametr", &a->ns4__ArrayOfOperationStep_x002eUsingControlledParametr::OperationStep_x002eUsingControlledParametr, "ns4:OperationStep.UsingControlledParametr"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfOperationStep_x002eUsingControlledParametr *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr, SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr, sizeof(ns4__ArrayOfOperationStep_x002eUsingControlledParametr), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__ArrayOfOperationStep_x002eUsingControlledParametr * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__ArrayOfOperationStep_x002eUsingControlledParametr *p;
	size_t k = sizeof(ns4__ArrayOfOperationStep_x002eUsingControlledParametr);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__ArrayOfOperationStep_x002eUsingControlledParametr);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__ArrayOfOperationStep_x002eUsingControlledParametr, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__ArrayOfOperationStep_x002eUsingControlledParametr location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__ArrayOfOperationStep_x002eUsingControlledParametr::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, tag ? tag : "ns4:ArrayOfOperationStep.UsingControlledParametr", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__ArrayOfOperationStep_x002eUsingControlledParametr::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfOperationStep_x002eUsingControlledParametr * SOAP_FMAC4 soap_get_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(struct soap *soap, ns4__ArrayOfOperationStep_x002eUsingControlledParametr *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__OperationStep::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__OperationStep::Active = NULL;
	this->ns4__OperationStep::ControlParams = NULL;
	this->ns4__OperationStep::Number = NULL;
	this->ns4__OperationStep::Params = NULL;
	this->ns4__OperationStep::RequiredChromMode = NULL;
	this->ns4__OperationStep::StepType = NULL;
	this->ns4__OperationStep::Title = NULL;
	this->ns4__OperationStep::xsd__duration = 7;
	this->ns4__OperationStep::WaitBefore = NULL;
	this->ns4__OperationStep::WaitBeforeXml = NULL;
}

void ns4__OperationStep::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->ns4__OperationStep::Active);
	soap_serialize_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, &this->ns4__OperationStep::ControlParams);
	soap_serialize_PointerToint(soap, &this->ns4__OperationStep::Number);
	soap_serialize_PointerTostd__string(soap, &this->ns4__OperationStep::Params);
	soap_serialize_PointerTons9__ChromatographMode(soap, &this->ns4__OperationStep::RequiredChromMode);
	soap_serialize_PointerTons4__OperationStepTypes(soap, &this->ns4__OperationStep::StepType);
	soap_serialize_PointerTostd__string(soap, &this->ns4__OperationStep::Title);
	soap_embedded(soap, &this->ns4__OperationStep::xsd__duration, SOAP_TYPE_int);
	soap_serialize_PointerToint(soap, &this->ns4__OperationStep::WaitBefore);
	soap_serialize_PointerToLONG64(soap, &this->ns4__OperationStep::WaitBeforeXml);
#endif
}

int ns4__OperationStep::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__OperationStep(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__OperationStep(struct soap *soap, const char *tag, int id, const ns4__OperationStep *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__OperationStep), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns4:Active", -1, &a->ns4__OperationStep::Active, ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, "ns4:ControlParams", -1, &a->ns4__OperationStep::ControlParams, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:Number", -1, &a->ns4__OperationStep::Number, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:Params", -1, &a->ns4__OperationStep::Params, ""))
		return soap->error;
	if (soap_out_PointerTons9__ChromatographMode(soap, "ns4:RequiredChromMode", -1, &a->ns4__OperationStep::RequiredChromMode, ""))
		return soap->error;
	if (soap_out_PointerTons4__OperationStepTypes(soap, "ns4:StepType", -1, &a->ns4__OperationStep::StepType, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:Title", -1, &a->ns4__OperationStep::Title, ""))
		return soap->error;
	if (soap_out_int(soap, "xsd:duration", -1, &a->ns4__OperationStep::xsd__duration, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:WaitBefore", -1, &a->ns4__OperationStep::WaitBefore, ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "ns4:WaitBeforeXml", -1, &a->ns4__OperationStep::WaitBeforeXml, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__OperationStep::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__OperationStep(soap, tag, this, type);
}

SOAP_FMAC3 ns4__OperationStep * SOAP_FMAC4 soap_in_ns4__OperationStep(struct soap *soap, const char *tag, ns4__OperationStep *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__OperationStep*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__OperationStep, sizeof(ns4__OperationStep), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__OperationStep)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__OperationStep *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Active1 = 1;
	size_t soap_flag_ControlParams1 = 1;
	size_t soap_flag_Number1 = 1;
	size_t soap_flag_Params1 = 1;
	size_t soap_flag_RequiredChromMode1 = 1;
	size_t soap_flag_StepType1 = 1;
	size_t soap_flag_Title1 = 1;
	size_t soap_flag_xsd__duration1 = 1;
	size_t soap_flag_WaitBefore1 = 1;
	size_t soap_flag_WaitBeforeXml1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Active1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns4:Active", &a->ns4__OperationStep::Active, "xsd:boolean"))
				{	soap_flag_Active1--;
					continue;
				}
			}
			if (soap_flag_ControlParams1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, "ns4:ControlParams", &a->ns4__OperationStep::ControlParams, "ns4:ArrayOfOperationStep.UsingControlledParametr"))
				{	soap_flag_ControlParams1--;
					continue;
				}
			}
			if (soap_flag_Number1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns4:Number", &a->ns4__OperationStep::Number, "xsd:int"))
				{	soap_flag_Number1--;
					continue;
				}
			}
			if (soap_flag_Params1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:Params", &a->ns4__OperationStep::Params, "xsd:string"))
				{	soap_flag_Params1--;
					continue;
				}
			}
			if (soap_flag_RequiredChromMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons9__ChromatographMode(soap, "ns4:RequiredChromMode", &a->ns4__OperationStep::RequiredChromMode, "ns9:ChromatographMode"))
				{	soap_flag_RequiredChromMode1--;
					continue;
				}
			}
			if (soap_flag_StepType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons4__OperationStepTypes(soap, "ns4:StepType", &a->ns4__OperationStep::StepType, "ns4:OperationStepTypes"))
				{	soap_flag_StepType1--;
					continue;
				}
			}
			if (soap_flag_Title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:Title", &a->ns4__OperationStep::Title, "xsd:string"))
				{	soap_flag_Title1--;
					continue;
				}
			}
			if (soap_flag_xsd__duration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "xsd:duration", &a->ns4__OperationStep::xsd__duration, "xsd:int"))
				{	soap_flag_xsd__duration1--;
					continue;
				}
			}
			if (soap_flag_WaitBefore1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns4:WaitBefore", &a->ns4__OperationStep::WaitBefore, "xsd:int"))
				{	soap_flag_WaitBefore1--;
					continue;
				}
			}
			if (soap_flag_WaitBeforeXml1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToLONG64(soap, "ns4:WaitBeforeXml", &a->ns4__OperationStep::WaitBeforeXml, "xsd:long"))
				{	soap_flag_WaitBeforeXml1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_xsd__duration1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns4__OperationStep *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__OperationStep, SOAP_TYPE_ns4__OperationStep, sizeof(ns4__OperationStep), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__OperationStep * SOAP_FMAC2 soap_instantiate_ns4__OperationStep(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__OperationStep(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__OperationStep *p;
	size_t k = sizeof(ns4__OperationStep);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__OperationStep, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__OperationStep);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__OperationStep, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__OperationStep location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__OperationStep::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__OperationStep(soap, tag ? tag : "ns4:OperationStep", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__OperationStep::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__OperationStep(soap, this, tag, type);
}

SOAP_FMAC3 ns4__OperationStep * SOAP_FMAC4 soap_get_ns4__OperationStep(struct soap *soap, ns4__OperationStep *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__OperationStep(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__ArrayOfOperationStep::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__OperationStep(soap, &this->ns4__ArrayOfOperationStep::OperationStep);
}

void ns4__ArrayOfOperationStep::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons4__OperationStep(soap, &this->ns4__ArrayOfOperationStep::OperationStep);
#endif
}

int ns4__ArrayOfOperationStep::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfOperationStep(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfOperationStep(struct soap *soap, const char *tag, int id, const ns4__ArrayOfOperationStep *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfOperationStep), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__OperationStep(soap, "ns4:OperationStep", -1, &a->ns4__ArrayOfOperationStep::OperationStep, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__ArrayOfOperationStep::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__ArrayOfOperationStep(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfOperationStep * SOAP_FMAC4 soap_in_ns4__ArrayOfOperationStep(struct soap *soap, const char *tag, ns4__ArrayOfOperationStep *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfOperationStep*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfOperationStep, sizeof(ns4__ArrayOfOperationStep), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__ArrayOfOperationStep)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__ArrayOfOperationStep *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons4__OperationStep(soap, "ns4:OperationStep", &a->ns4__ArrayOfOperationStep::OperationStep, "ns4:OperationStep"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfOperationStep *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfOperationStep, SOAP_TYPE_ns4__ArrayOfOperationStep, sizeof(ns4__ArrayOfOperationStep), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__ArrayOfOperationStep * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfOperationStep(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfOperationStep(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__ArrayOfOperationStep *p;
	size_t k = sizeof(ns4__ArrayOfOperationStep);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__ArrayOfOperationStep, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__ArrayOfOperationStep);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__ArrayOfOperationStep, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__ArrayOfOperationStep location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__ArrayOfOperationStep::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__ArrayOfOperationStep(soap, tag ? tag : "ns4:ArrayOfOperationStep", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__ArrayOfOperationStep::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfOperationStep(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfOperationStep * SOAP_FMAC4 soap_get_ns4__ArrayOfOperationStep(struct soap *soap, ns4__ArrayOfOperationStep *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfOperationStep(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__Operation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__Operation::Name = NULL;
	this->ns4__Operation::OperationSteps = NULL;
	this->ns4__Operation::OperationType = NULL;
	this->ns4__Operation::Title = NULL;
	this->ns4__Operation::UserVisible = NULL;
}

void ns4__Operation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns4__Operation::Name);
	soap_serialize_PointerTons4__ArrayOfOperationStep(soap, &this->ns4__Operation::OperationSteps);
	soap_serialize_PointerTons4__OperationTypes(soap, &this->ns4__Operation::OperationType);
	soap_serialize_PointerTostd__string(soap, &this->ns4__Operation::Title);
	soap_serialize_PointerTobool(soap, &this->ns4__Operation::UserVisible);
#endif
}

int ns4__Operation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Operation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Operation(struct soap *soap, const char *tag, int id, const ns4__Operation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Operation), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:Name", -1, &a->ns4__Operation::Name, ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfOperationStep(soap, "ns4:OperationSteps", -1, &a->ns4__Operation::OperationSteps, ""))
		return soap->error;
	if (soap_out_PointerTons4__OperationTypes(soap, "ns4:OperationType", -1, &a->ns4__Operation::OperationType, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:Title", -1, &a->ns4__Operation::Title, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns4:UserVisible", -1, &a->ns4__Operation::UserVisible, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__Operation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__Operation(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Operation * SOAP_FMAC4 soap_in_ns4__Operation(struct soap *soap, const char *tag, ns4__Operation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Operation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Operation, sizeof(ns4__Operation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__Operation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__Operation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_OperationSteps1 = 1;
	size_t soap_flag_OperationType1 = 1;
	size_t soap_flag_Title1 = 1;
	size_t soap_flag_UserVisible1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:Name", &a->ns4__Operation::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_OperationSteps1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons4__ArrayOfOperationStep(soap, "ns4:OperationSteps", &a->ns4__Operation::OperationSteps, "ns4:ArrayOfOperationStep"))
				{	soap_flag_OperationSteps1--;
					continue;
				}
			}
			if (soap_flag_OperationType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons4__OperationTypes(soap, "ns4:OperationType", &a->ns4__Operation::OperationType, "ns4:OperationTypes"))
				{	soap_flag_OperationType1--;
					continue;
				}
			}
			if (soap_flag_Title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:Title", &a->ns4__Operation::Title, "xsd:string"))
				{	soap_flag_Title1--;
					continue;
				}
			}
			if (soap_flag_UserVisible1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns4:UserVisible", &a->ns4__Operation::UserVisible, "xsd:boolean"))
				{	soap_flag_UserVisible1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Operation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Operation, SOAP_TYPE_ns4__Operation, sizeof(ns4__Operation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__Operation * SOAP_FMAC2 soap_instantiate_ns4__Operation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Operation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__Operation *p;
	size_t k = sizeof(ns4__Operation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__Operation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__Operation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__Operation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__Operation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__Operation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__Operation(soap, tag ? tag : "ns4:Operation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__Operation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Operation(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Operation * SOAP_FMAC4 soap_get_ns4__Operation(struct soap *soap, ns4__Operation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Operation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__ArrayOfOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__Operation(soap, &this->ns4__ArrayOfOperation::Operation);
}

void ns4__ArrayOfOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons4__Operation(soap, &this->ns4__ArrayOfOperation::Operation);
#endif
}

int ns4__ArrayOfOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfOperation(struct soap *soap, const char *tag, int id, const ns4__ArrayOfOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfOperation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__Operation(soap, "ns4:Operation", -1, &a->ns4__ArrayOfOperation::Operation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__ArrayOfOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__ArrayOfOperation(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfOperation * SOAP_FMAC4 soap_in_ns4__ArrayOfOperation(struct soap *soap, const char *tag, ns4__ArrayOfOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfOperation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfOperation, sizeof(ns4__ArrayOfOperation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__ArrayOfOperation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__ArrayOfOperation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons4__Operation(soap, "ns4:Operation", &a->ns4__ArrayOfOperation::Operation, "ns4:Operation"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfOperation, SOAP_TYPE_ns4__ArrayOfOperation, sizeof(ns4__ArrayOfOperation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__ArrayOfOperation * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfOperation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__ArrayOfOperation *p;
	size_t k = sizeof(ns4__ArrayOfOperation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__ArrayOfOperation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__ArrayOfOperation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__ArrayOfOperation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__ArrayOfOperation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__ArrayOfOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__ArrayOfOperation(soap, tag ? tag : "ns4:ArrayOfOperation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__ArrayOfOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfOperation(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfOperation * SOAP_FMAC4 soap_get_ns4__ArrayOfOperation(struct soap *soap, ns4__ArrayOfOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__MeasuringComponent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__MeasuringComponent::CASCode = NULL;
	this->ns4__MeasuringComponent::Code = NULL;
	this->ns4__MeasuringComponent::Control_USCOREAccuracy = NULL;
	this->ns4__MeasuringComponent::Control_USCOREAccuracyStandardValue = NULL;
	this->ns4__MeasuringComponent::Control_USCOREPeriodicity = NULL;
	this->ns4__MeasuringComponent::Formula = NULL;
	this->ns4__MeasuringComponent::Name = NULL;
	this->ns4__MeasuringComponent::Register = NULL;
	this->ns4__MeasuringComponent::UnitsName = NULL;
	this->ns4__MeasuringComponent::ValueDigAfterPoint = NULL;
}

void ns4__MeasuringComponent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns4__MeasuringComponent::CASCode);
	soap_serialize_PointerToint(soap, &this->ns4__MeasuringComponent::Code);
	soap_serialize_PointerTostd__string(soap, &this->ns4__MeasuringComponent::Control_USCOREAccuracy);
	soap_serialize_PointerToxsd__decimal(soap, &this->ns4__MeasuringComponent::Control_USCOREAccuracyStandardValue);
	soap_serialize_PointerTostd__string(soap, &this->ns4__MeasuringComponent::Control_USCOREPeriodicity);
	soap_serialize_PointerTostd__string(soap, &this->ns4__MeasuringComponent::Formula);
	soap_serialize_PointerTostd__string(soap, &this->ns4__MeasuringComponent::Name);
	soap_serialize_PointerTostd__string(soap, &this->ns4__MeasuringComponent::Register);
	soap_serialize_PointerTostd__string(soap, &this->ns4__MeasuringComponent::UnitsName);
	soap_serialize_PointerToxsd__unsignedByte(soap, &this->ns4__MeasuringComponent::ValueDigAfterPoint);
#endif
}

int ns4__MeasuringComponent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__MeasuringComponent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__MeasuringComponent(struct soap *soap, const char *tag, int id, const ns4__MeasuringComponent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__MeasuringComponent), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:CASCode", -1, &a->ns4__MeasuringComponent::CASCode, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:Code", -1, &a->ns4__MeasuringComponent::Code, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:Control_Accuracy", -1, &a->ns4__MeasuringComponent::Control_USCOREAccuracy, ""))
		return soap->error;
	if (soap_out_PointerToxsd__decimal(soap, "ns4:Control_AccuracyStandardValue", -1, &a->ns4__MeasuringComponent::Control_USCOREAccuracyStandardValue, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:Control_Periodicity", -1, &a->ns4__MeasuringComponent::Control_USCOREPeriodicity, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:Formula", -1, &a->ns4__MeasuringComponent::Formula, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:Name", -1, &a->ns4__MeasuringComponent::Name, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:Register", -1, &a->ns4__MeasuringComponent::Register, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:UnitsName", -1, &a->ns4__MeasuringComponent::UnitsName, ""))
		return soap->error;
	if (soap_out_PointerToxsd__unsignedByte(soap, "ns4:ValueDigAfterPoint", -1, &a->ns4__MeasuringComponent::ValueDigAfterPoint, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__MeasuringComponent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__MeasuringComponent(soap, tag, this, type);
}

SOAP_FMAC3 ns4__MeasuringComponent * SOAP_FMAC4 soap_in_ns4__MeasuringComponent(struct soap *soap, const char *tag, ns4__MeasuringComponent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__MeasuringComponent*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__MeasuringComponent, sizeof(ns4__MeasuringComponent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__MeasuringComponent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__MeasuringComponent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CASCode1 = 1;
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_Control_USCOREAccuracy1 = 1;
	size_t soap_flag_Control_USCOREAccuracyStandardValue1 = 1;
	size_t soap_flag_Control_USCOREPeriodicity1 = 1;
	size_t soap_flag_Formula1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Register1 = 1;
	size_t soap_flag_UnitsName1 = 1;
	size_t soap_flag_ValueDigAfterPoint1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CASCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:CASCode", &a->ns4__MeasuringComponent::CASCode, "xsd:string"))
				{	soap_flag_CASCode1--;
					continue;
				}
			}
			if (soap_flag_Code1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns4:Code", &a->ns4__MeasuringComponent::Code, "xsd:int"))
				{	soap_flag_Code1--;
					continue;
				}
			}
			if (soap_flag_Control_USCOREAccuracy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:Control_Accuracy", &a->ns4__MeasuringComponent::Control_USCOREAccuracy, "xsd:string"))
				{	soap_flag_Control_USCOREAccuracy1--;
					continue;
				}
			}
			if (soap_flag_Control_USCOREAccuracyStandardValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__decimal(soap, "ns4:Control_AccuracyStandardValue", &a->ns4__MeasuringComponent::Control_USCOREAccuracyStandardValue, "xsd:decimal"))
				{	soap_flag_Control_USCOREAccuracyStandardValue1--;
					continue;
				}
			}
			if (soap_flag_Control_USCOREPeriodicity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:Control_Periodicity", &a->ns4__MeasuringComponent::Control_USCOREPeriodicity, "xsd:string"))
				{	soap_flag_Control_USCOREPeriodicity1--;
					continue;
				}
			}
			if (soap_flag_Formula1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:Formula", &a->ns4__MeasuringComponent::Formula, "xsd:string"))
				{	soap_flag_Formula1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:Name", &a->ns4__MeasuringComponent::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Register1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:Register", &a->ns4__MeasuringComponent::Register, "xsd:string"))
				{	soap_flag_Register1--;
					continue;
				}
			}
			if (soap_flag_UnitsName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:UnitsName", &a->ns4__MeasuringComponent::UnitsName, "xsd:string"))
				{	soap_flag_UnitsName1--;
					continue;
				}
			}
			if (soap_flag_ValueDigAfterPoint1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__unsignedByte(soap, "ns4:ValueDigAfterPoint", &a->ns4__MeasuringComponent::ValueDigAfterPoint, "xsd:unsignedByte"))
				{	soap_flag_ValueDigAfterPoint1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__MeasuringComponent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__MeasuringComponent, SOAP_TYPE_ns4__MeasuringComponent, sizeof(ns4__MeasuringComponent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__MeasuringComponent * SOAP_FMAC2 soap_instantiate_ns4__MeasuringComponent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__MeasuringComponent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__MeasuringComponent *p;
	size_t k = sizeof(ns4__MeasuringComponent);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__MeasuringComponent, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__MeasuringComponent);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__MeasuringComponent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__MeasuringComponent location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__MeasuringComponent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__MeasuringComponent(soap, tag ? tag : "ns4:MeasuringComponent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__MeasuringComponent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__MeasuringComponent(soap, this, tag, type);
}

SOAP_FMAC3 ns4__MeasuringComponent * SOAP_FMAC4 soap_get_ns4__MeasuringComponent(struct soap *soap, ns4__MeasuringComponent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__MeasuringComponent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__ArrayOfMeasuringComponent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__MeasuringComponent(soap, &this->ns4__ArrayOfMeasuringComponent::MeasuringComponent);
}

void ns4__ArrayOfMeasuringComponent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons4__MeasuringComponent(soap, &this->ns4__ArrayOfMeasuringComponent::MeasuringComponent);
#endif
}

int ns4__ArrayOfMeasuringComponent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfMeasuringComponent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfMeasuringComponent(struct soap *soap, const char *tag, int id, const ns4__ArrayOfMeasuringComponent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfMeasuringComponent), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__MeasuringComponent(soap, "ns4:MeasuringComponent", -1, &a->ns4__ArrayOfMeasuringComponent::MeasuringComponent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__ArrayOfMeasuringComponent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__ArrayOfMeasuringComponent(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfMeasuringComponent * SOAP_FMAC4 soap_in_ns4__ArrayOfMeasuringComponent(struct soap *soap, const char *tag, ns4__ArrayOfMeasuringComponent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfMeasuringComponent*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfMeasuringComponent, sizeof(ns4__ArrayOfMeasuringComponent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__ArrayOfMeasuringComponent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__ArrayOfMeasuringComponent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons4__MeasuringComponent(soap, "ns4:MeasuringComponent", &a->ns4__ArrayOfMeasuringComponent::MeasuringComponent, "ns4:MeasuringComponent"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfMeasuringComponent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfMeasuringComponent, SOAP_TYPE_ns4__ArrayOfMeasuringComponent, sizeof(ns4__ArrayOfMeasuringComponent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__ArrayOfMeasuringComponent * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfMeasuringComponent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfMeasuringComponent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__ArrayOfMeasuringComponent *p;
	size_t k = sizeof(ns4__ArrayOfMeasuringComponent);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__ArrayOfMeasuringComponent, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__ArrayOfMeasuringComponent);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__ArrayOfMeasuringComponent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__ArrayOfMeasuringComponent location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__ArrayOfMeasuringComponent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__ArrayOfMeasuringComponent(soap, tag ? tag : "ns4:ArrayOfMeasuringComponent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__ArrayOfMeasuringComponent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfMeasuringComponent(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfMeasuringComponent * SOAP_FMAC4 soap_get_ns4__ArrayOfMeasuringComponent(struct soap *soap, ns4__ArrayOfMeasuringComponent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfMeasuringComponent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__ControlledParametr::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__ControlledParametr::ActionMessage = NULL;
	this->ns4__ControlledParametr::ActionType = NULL;
	this->ns4__ControlledParametr::Active = NULL;
	this->ns4__ControlledParametr::Condition = NULL;
	this->ns4__ControlledParametr::Formula = NULL;
	this->ns4__ControlledParametr::Name = NULL;
	this->ns4__ControlledParametr::ShowUser = NULL;
	this->ns4__ControlledParametr::Title = NULL;
	this->ns4__ControlledParametr::UnitsName = NULL;
	this->ns4__ControlledParametr::ValueDigAfterPoint = NULL;
}

void ns4__ControlledParametr::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns4__ControlledParametr::ActionMessage);
	soap_serialize_PointerTons4__ControlledParametr_x002eControlActionType(soap, &this->ns4__ControlledParametr::ActionType);
	soap_serialize_PointerTobool(soap, &this->ns4__ControlledParametr::Active);
	soap_serialize_PointerTostd__string(soap, &this->ns4__ControlledParametr::Condition);
	soap_serialize_PointerTostd__string(soap, &this->ns4__ControlledParametr::Formula);
	soap_serialize_PointerTostd__string(soap, &this->ns4__ControlledParametr::Name);
	soap_serialize_PointerTobool(soap, &this->ns4__ControlledParametr::ShowUser);
	soap_serialize_PointerTostd__string(soap, &this->ns4__ControlledParametr::Title);
	soap_serialize_PointerTostd__string(soap, &this->ns4__ControlledParametr::UnitsName);
	soap_serialize_PointerToxsd__unsignedByte(soap, &this->ns4__ControlledParametr::ValueDigAfterPoint);
#endif
}

int ns4__ControlledParametr::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ControlledParametr(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ControlledParametr(struct soap *soap, const char *tag, int id, const ns4__ControlledParametr *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ControlledParametr), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:ActionMessage", -1, &a->ns4__ControlledParametr::ActionMessage, ""))
		return soap->error;
	if (soap_out_PointerTons4__ControlledParametr_x002eControlActionType(soap, "ns4:ActionType", -1, &a->ns4__ControlledParametr::ActionType, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns4:Active", -1, &a->ns4__ControlledParametr::Active, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:Condition", -1, &a->ns4__ControlledParametr::Condition, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:Formula", -1, &a->ns4__ControlledParametr::Formula, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:Name", -1, &a->ns4__ControlledParametr::Name, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns4:ShowUser", -1, &a->ns4__ControlledParametr::ShowUser, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:Title", -1, &a->ns4__ControlledParametr::Title, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:UnitsName", -1, &a->ns4__ControlledParametr::UnitsName, ""))
		return soap->error;
	if (soap_out_PointerToxsd__unsignedByte(soap, "ns4:ValueDigAfterPoint", -1, &a->ns4__ControlledParametr::ValueDigAfterPoint, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__ControlledParametr::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__ControlledParametr(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ControlledParametr * SOAP_FMAC4 soap_in_ns4__ControlledParametr(struct soap *soap, const char *tag, ns4__ControlledParametr *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ControlledParametr*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ControlledParametr, sizeof(ns4__ControlledParametr), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__ControlledParametr)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__ControlledParametr *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ActionMessage1 = 1;
	size_t soap_flag_ActionType1 = 1;
	size_t soap_flag_Active1 = 1;
	size_t soap_flag_Condition1 = 1;
	size_t soap_flag_Formula1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_ShowUser1 = 1;
	size_t soap_flag_Title1 = 1;
	size_t soap_flag_UnitsName1 = 1;
	size_t soap_flag_ValueDigAfterPoint1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActionMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:ActionMessage", &a->ns4__ControlledParametr::ActionMessage, "xsd:string"))
				{	soap_flag_ActionMessage1--;
					continue;
				}
			}
			if (soap_flag_ActionType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons4__ControlledParametr_x002eControlActionType(soap, "ns4:ActionType", &a->ns4__ControlledParametr::ActionType, "ns4:ControlledParametr.ControlActionType"))
				{	soap_flag_ActionType1--;
					continue;
				}
			}
			if (soap_flag_Active1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns4:Active", &a->ns4__ControlledParametr::Active, "xsd:boolean"))
				{	soap_flag_Active1--;
					continue;
				}
			}
			if (soap_flag_Condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:Condition", &a->ns4__ControlledParametr::Condition, "xsd:string"))
				{	soap_flag_Condition1--;
					continue;
				}
			}
			if (soap_flag_Formula1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:Formula", &a->ns4__ControlledParametr::Formula, "xsd:string"))
				{	soap_flag_Formula1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:Name", &a->ns4__ControlledParametr::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_ShowUser1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns4:ShowUser", &a->ns4__ControlledParametr::ShowUser, "xsd:boolean"))
				{	soap_flag_ShowUser1--;
					continue;
				}
			}
			if (soap_flag_Title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:Title", &a->ns4__ControlledParametr::Title, "xsd:string"))
				{	soap_flag_Title1--;
					continue;
				}
			}
			if (soap_flag_UnitsName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:UnitsName", &a->ns4__ControlledParametr::UnitsName, "xsd:string"))
				{	soap_flag_UnitsName1--;
					continue;
				}
			}
			if (soap_flag_ValueDigAfterPoint1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__unsignedByte(soap, "ns4:ValueDigAfterPoint", &a->ns4__ControlledParametr::ValueDigAfterPoint, "xsd:unsignedByte"))
				{	soap_flag_ValueDigAfterPoint1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ControlledParametr *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ControlledParametr, SOAP_TYPE_ns4__ControlledParametr, sizeof(ns4__ControlledParametr), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__ControlledParametr * SOAP_FMAC2 soap_instantiate_ns4__ControlledParametr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ControlledParametr(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__ControlledParametr *p;
	size_t k = sizeof(ns4__ControlledParametr);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__ControlledParametr, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__ControlledParametr);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__ControlledParametr, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__ControlledParametr location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__ControlledParametr::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__ControlledParametr(soap, tag ? tag : "ns4:ControlledParametr", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__ControlledParametr::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ControlledParametr(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ControlledParametr * SOAP_FMAC4 soap_get_ns4__ControlledParametr(struct soap *soap, ns4__ControlledParametr *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ControlledParametr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__ArrayOfControlledParametr::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__ControlledParametr(soap, &this->ns4__ArrayOfControlledParametr::ControlledParametr);
}

void ns4__ArrayOfControlledParametr::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons4__ControlledParametr(soap, &this->ns4__ArrayOfControlledParametr::ControlledParametr);
#endif
}

int ns4__ArrayOfControlledParametr::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfControlledParametr(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfControlledParametr(struct soap *soap, const char *tag, int id, const ns4__ArrayOfControlledParametr *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfControlledParametr), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__ControlledParametr(soap, "ns4:ControlledParametr", -1, &a->ns4__ArrayOfControlledParametr::ControlledParametr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__ArrayOfControlledParametr::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__ArrayOfControlledParametr(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfControlledParametr * SOAP_FMAC4 soap_in_ns4__ArrayOfControlledParametr(struct soap *soap, const char *tag, ns4__ArrayOfControlledParametr *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfControlledParametr*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfControlledParametr, sizeof(ns4__ArrayOfControlledParametr), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__ArrayOfControlledParametr)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__ArrayOfControlledParametr *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons4__ControlledParametr(soap, "ns4:ControlledParametr", &a->ns4__ArrayOfControlledParametr::ControlledParametr, "ns4:ControlledParametr"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfControlledParametr *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfControlledParametr, SOAP_TYPE_ns4__ArrayOfControlledParametr, sizeof(ns4__ArrayOfControlledParametr), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__ArrayOfControlledParametr * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfControlledParametr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfControlledParametr(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__ArrayOfControlledParametr *p;
	size_t k = sizeof(ns4__ArrayOfControlledParametr);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__ArrayOfControlledParametr, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__ArrayOfControlledParametr);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__ArrayOfControlledParametr, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__ArrayOfControlledParametr location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__ArrayOfControlledParametr::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__ArrayOfControlledParametr(soap, tag ? tag : "ns4:ArrayOfControlledParametr", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__ArrayOfControlledParametr::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfControlledParametr(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfControlledParametr * SOAP_FMAC4 soap_get_ns4__ArrayOfControlledParametr(struct soap *soap, ns4__ArrayOfControlledParametr *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfControlledParametr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__Periodicity_x002eTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__Periodicity_x002eTime::Value = NULL;
}

void ns4__Periodicity_x002eTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTodateTime(soap, &this->ns4__Periodicity_x002eTime::Value);
#endif
}

int ns4__Periodicity_x002eTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Periodicity_x002eTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Periodicity_x002eTime(struct soap *soap, const char *tag, int id, const ns4__Periodicity_x002eTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Periodicity_x002eTime), type))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns4:Value", -1, &a->ns4__Periodicity_x002eTime::Value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__Periodicity_x002eTime::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__Periodicity_x002eTime(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Periodicity_x002eTime * SOAP_FMAC4 soap_in_ns4__Periodicity_x002eTime(struct soap *soap, const char *tag, ns4__Periodicity_x002eTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Periodicity_x002eTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Periodicity_x002eTime, sizeof(ns4__Periodicity_x002eTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__Periodicity_x002eTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__Periodicity_x002eTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Value1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Value1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns4:Value", &a->ns4__Periodicity_x002eTime::Value, "xsd:dateTime"))
				{	soap_flag_Value1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Periodicity_x002eTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Periodicity_x002eTime, SOAP_TYPE_ns4__Periodicity_x002eTime, sizeof(ns4__Periodicity_x002eTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__Periodicity_x002eTime * SOAP_FMAC2 soap_instantiate_ns4__Periodicity_x002eTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Periodicity_x002eTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__Periodicity_x002eTime *p;
	size_t k = sizeof(ns4__Periodicity_x002eTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__Periodicity_x002eTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__Periodicity_x002eTime);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__Periodicity_x002eTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__Periodicity_x002eTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__Periodicity_x002eTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__Periodicity_x002eTime(soap, tag ? tag : "ns4:Periodicity.Time", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__Periodicity_x002eTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Periodicity_x002eTime(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Periodicity_x002eTime * SOAP_FMAC4 soap_get_ns4__Periodicity_x002eTime(struct soap *soap, ns4__Periodicity_x002eTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Periodicity_x002eTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__ArrayOfPeriodicity_x002eTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime(soap, &this->ns4__ArrayOfPeriodicity_x002eTime::Periodicity_x002eTime);
}

void ns4__ArrayOfPeriodicity_x002eTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime(soap, &this->ns4__ArrayOfPeriodicity_x002eTime::Periodicity_x002eTime);
#endif
}

int ns4__ArrayOfPeriodicity_x002eTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfPeriodicity_x002eTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfPeriodicity_x002eTime(struct soap *soap, const char *tag, int id, const ns4__ArrayOfPeriodicity_x002eTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime(soap, "ns4:Periodicity.Time", -1, &a->ns4__ArrayOfPeriodicity_x002eTime::Periodicity_x002eTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__ArrayOfPeriodicity_x002eTime::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__ArrayOfPeriodicity_x002eTime(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfPeriodicity_x002eTime * SOAP_FMAC4 soap_in_ns4__ArrayOfPeriodicity_x002eTime(struct soap *soap, const char *tag, ns4__ArrayOfPeriodicity_x002eTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfPeriodicity_x002eTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime, sizeof(ns4__ArrayOfPeriodicity_x002eTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__ArrayOfPeriodicity_x002eTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime(soap, "ns4:Periodicity.Time", &a->ns4__ArrayOfPeriodicity_x002eTime::Periodicity_x002eTime, "ns4:Periodicity.Time"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfPeriodicity_x002eTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime, SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime, sizeof(ns4__ArrayOfPeriodicity_x002eTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__ArrayOfPeriodicity_x002eTime * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfPeriodicity_x002eTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfPeriodicity_x002eTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__ArrayOfPeriodicity_x002eTime *p;
	size_t k = sizeof(ns4__ArrayOfPeriodicity_x002eTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__ArrayOfPeriodicity_x002eTime);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__ArrayOfPeriodicity_x002eTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__ArrayOfPeriodicity_x002eTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__ArrayOfPeriodicity_x002eTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__ArrayOfPeriodicity_x002eTime(soap, tag ? tag : "ns4:ArrayOfPeriodicity.Time", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__ArrayOfPeriodicity_x002eTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfPeriodicity_x002eTime(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfPeriodicity_x002eTime * SOAP_FMAC4 soap_get_ns4__ArrayOfPeriodicity_x002eTime(struct soap *soap, ns4__ArrayOfPeriodicity_x002eTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfPeriodicity_x002eTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__Periodicity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__Periodicity::Months = NULL;
	this->ns4__Periodicity::Times = NULL;
	this->ns4__Periodicity::WeekDays = NULL;
	this->ns4__Periodicity::Weeks = NULL;
}

void ns4__Periodicity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToarr__ArrayOfboolean(soap, &this->ns4__Periodicity::Months);
	soap_serialize_PointerTons4__ArrayOfPeriodicity_x002eTime(soap, &this->ns4__Periodicity::Times);
	soap_serialize_PointerToarr__ArrayOfboolean(soap, &this->ns4__Periodicity::WeekDays);
	soap_serialize_PointerToarr__ArrayOfboolean(soap, &this->ns4__Periodicity::Weeks);
#endif
}

int ns4__Periodicity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Periodicity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Periodicity(struct soap *soap, const char *tag, int id, const ns4__Periodicity *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Periodicity), type))
		return soap->error;
	if (soap_out_PointerToarr__ArrayOfboolean(soap, "ns4:Months", -1, &a->ns4__Periodicity::Months, ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfPeriodicity_x002eTime(soap, "ns4:Times", -1, &a->ns4__Periodicity::Times, ""))
		return soap->error;
	if (soap_out_PointerToarr__ArrayOfboolean(soap, "ns4:WeekDays", -1, &a->ns4__Periodicity::WeekDays, ""))
		return soap->error;
	if (soap_out_PointerToarr__ArrayOfboolean(soap, "ns4:Weeks", -1, &a->ns4__Periodicity::Weeks, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__Periodicity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__Periodicity(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Periodicity * SOAP_FMAC4 soap_in_ns4__Periodicity(struct soap *soap, const char *tag, ns4__Periodicity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Periodicity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Periodicity, sizeof(ns4__Periodicity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__Periodicity)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__Periodicity *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Months1 = 1;
	size_t soap_flag_Times1 = 1;
	size_t soap_flag_WeekDays1 = 1;
	size_t soap_flag_Weeks1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Months1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfboolean(soap, "ns4:Months", &a->ns4__Periodicity::Months, "arr:ArrayOfboolean"))
				{	soap_flag_Months1--;
					continue;
				}
			}
			if (soap_flag_Times1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons4__ArrayOfPeriodicity_x002eTime(soap, "ns4:Times", &a->ns4__Periodicity::Times, "ns4:ArrayOfPeriodicity.Time"))
				{	soap_flag_Times1--;
					continue;
				}
			}
			if (soap_flag_WeekDays1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfboolean(soap, "ns4:WeekDays", &a->ns4__Periodicity::WeekDays, "arr:ArrayOfboolean"))
				{	soap_flag_WeekDays1--;
					continue;
				}
			}
			if (soap_flag_Weeks1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfboolean(soap, "ns4:Weeks", &a->ns4__Periodicity::Weeks, "arr:ArrayOfboolean"))
				{	soap_flag_Weeks1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Periodicity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Periodicity, SOAP_TYPE_ns4__Periodicity, sizeof(ns4__Periodicity), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__Periodicity * SOAP_FMAC2 soap_instantiate_ns4__Periodicity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Periodicity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__Periodicity *p;
	size_t k = sizeof(ns4__Periodicity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__Periodicity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__Periodicity);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__Periodicity, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__Periodicity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__Periodicity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__Periodicity(soap, tag ? tag : "ns4:Periodicity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__Periodicity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Periodicity(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Periodicity * SOAP_FMAC4 soap_get_ns4__Periodicity(struct soap *soap, ns4__Periodicity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Periodicity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__AutoPlanItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__AutoPlanItem::Active = NULL;
	this->ns4__AutoPlanItem::ItemPeriodicity = NULL;
	this->ns4__AutoPlanItem::OperationName = NULL;
}

void ns4__AutoPlanItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->ns4__AutoPlanItem::Active);
	soap_serialize_PointerTons4__Periodicity(soap, &this->ns4__AutoPlanItem::ItemPeriodicity);
	soap_serialize_PointerTostd__string(soap, &this->ns4__AutoPlanItem::OperationName);
#endif
}

int ns4__AutoPlanItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__AutoPlanItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__AutoPlanItem(struct soap *soap, const char *tag, int id, const ns4__AutoPlanItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__AutoPlanItem), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns4:Active", -1, &a->ns4__AutoPlanItem::Active, ""))
		return soap->error;
	if (soap_out_PointerTons4__Periodicity(soap, "ns4:ItemPeriodicity", -1, &a->ns4__AutoPlanItem::ItemPeriodicity, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns4:OperationName", -1, &a->ns4__AutoPlanItem::OperationName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__AutoPlanItem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__AutoPlanItem(soap, tag, this, type);
}

SOAP_FMAC3 ns4__AutoPlanItem * SOAP_FMAC4 soap_in_ns4__AutoPlanItem(struct soap *soap, const char *tag, ns4__AutoPlanItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__AutoPlanItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__AutoPlanItem, sizeof(ns4__AutoPlanItem), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__AutoPlanItem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__AutoPlanItem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Active1 = 1;
	size_t soap_flag_ItemPeriodicity1 = 1;
	size_t soap_flag_OperationName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Active1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns4:Active", &a->ns4__AutoPlanItem::Active, "xsd:boolean"))
				{	soap_flag_Active1--;
					continue;
				}
			}
			if (soap_flag_ItemPeriodicity1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons4__Periodicity(soap, "ns4:ItemPeriodicity", &a->ns4__AutoPlanItem::ItemPeriodicity, "ns4:Periodicity"))
				{	soap_flag_ItemPeriodicity1--;
					continue;
				}
			}
			if (soap_flag_OperationName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns4:OperationName", &a->ns4__AutoPlanItem::OperationName, "xsd:string"))
				{	soap_flag_OperationName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__AutoPlanItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__AutoPlanItem, SOAP_TYPE_ns4__AutoPlanItem, sizeof(ns4__AutoPlanItem), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__AutoPlanItem * SOAP_FMAC2 soap_instantiate_ns4__AutoPlanItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__AutoPlanItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__AutoPlanItem *p;
	size_t k = sizeof(ns4__AutoPlanItem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__AutoPlanItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__AutoPlanItem);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__AutoPlanItem, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__AutoPlanItem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__AutoPlanItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__AutoPlanItem(soap, tag ? tag : "ns4:AutoPlanItem", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__AutoPlanItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__AutoPlanItem(soap, this, tag, type);
}

SOAP_FMAC3 ns4__AutoPlanItem * SOAP_FMAC4 soap_get_ns4__AutoPlanItem(struct soap *soap, ns4__AutoPlanItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__AutoPlanItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__ArrayOfAutoPlanItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__AutoPlanItem(soap, &this->ns4__ArrayOfAutoPlanItem::AutoPlanItem);
}

void ns4__ArrayOfAutoPlanItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons4__AutoPlanItem(soap, &this->ns4__ArrayOfAutoPlanItem::AutoPlanItem);
#endif
}

int ns4__ArrayOfAutoPlanItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfAutoPlanItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfAutoPlanItem(struct soap *soap, const char *tag, int id, const ns4__ArrayOfAutoPlanItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfAutoPlanItem), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__AutoPlanItem(soap, "ns4:AutoPlanItem", -1, &a->ns4__ArrayOfAutoPlanItem::AutoPlanItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__ArrayOfAutoPlanItem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__ArrayOfAutoPlanItem(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfAutoPlanItem * SOAP_FMAC4 soap_in_ns4__ArrayOfAutoPlanItem(struct soap *soap, const char *tag, ns4__ArrayOfAutoPlanItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfAutoPlanItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfAutoPlanItem, sizeof(ns4__ArrayOfAutoPlanItem), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__ArrayOfAutoPlanItem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__ArrayOfAutoPlanItem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons4__AutoPlanItem(soap, "ns4:AutoPlanItem", &a->ns4__ArrayOfAutoPlanItem::AutoPlanItem, "ns4:AutoPlanItem"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfAutoPlanItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfAutoPlanItem, SOAP_TYPE_ns4__ArrayOfAutoPlanItem, sizeof(ns4__ArrayOfAutoPlanItem), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__ArrayOfAutoPlanItem * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfAutoPlanItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfAutoPlanItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__ArrayOfAutoPlanItem *p;
	size_t k = sizeof(ns4__ArrayOfAutoPlanItem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__ArrayOfAutoPlanItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns4__ArrayOfAutoPlanItem);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns4__ArrayOfAutoPlanItem, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__ArrayOfAutoPlanItem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns4__ArrayOfAutoPlanItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__ArrayOfAutoPlanItem(soap, tag ? tag : "ns4:ArrayOfAutoPlanItem", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__ArrayOfAutoPlanItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfAutoPlanItem(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfAutoPlanItem * SOAP_FMAC4 soap_get_ns4__ArrayOfAutoPlanItem(struct soap *soap, ns4__ArrayOfAutoPlanItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfAutoPlanItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__OperationProcInfo_x002eOperationStepInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__OperationProcInfo_x002eOperationStepInfo::BeginDateTime = NULL;
	this->ns3__OperationProcInfo_x002eOperationStepInfo::Description = NULL;
	this->ns3__OperationProcInfo_x002eOperationStepInfo::ElapsedMilliseconds = NULL;
	this->ns3__OperationProcInfo_x002eOperationStepInfo::EndDateTime = NULL;
	this->ns3__OperationProcInfo_x002eOperationStepInfo::State = NULL;
	this->ns3__OperationProcInfo_x002eOperationStepInfo::StepType = NULL;
	this->ns3__OperationProcInfo_x002eOperationStepInfo::SysTitle = NULL;
	this->ns3__OperationProcInfo_x002eOperationStepInfo::Title = NULL;
}

void ns3__OperationProcInfo_x002eOperationStepInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTodateTime(soap, &this->ns3__OperationProcInfo_x002eOperationStepInfo::BeginDateTime);
	soap_serialize_PointerTostd__string(soap, &this->ns3__OperationProcInfo_x002eOperationStepInfo::Description);
	soap_serialize_PointerTodouble(soap, &this->ns3__OperationProcInfo_x002eOperationStepInfo::ElapsedMilliseconds);
	soap_serialize_PointerTodateTime(soap, &this->ns3__OperationProcInfo_x002eOperationStepInfo::EndDateTime);
	soap_serialize_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates(soap, &this->ns3__OperationProcInfo_x002eOperationStepInfo::State);
	soap_serialize_PointerTons4__OperationStepTypes(soap, &this->ns3__OperationProcInfo_x002eOperationStepInfo::StepType);
	soap_serialize_PointerTostd__string(soap, &this->ns3__OperationProcInfo_x002eOperationStepInfo::SysTitle);
	soap_serialize_PointerTostd__string(soap, &this->ns3__OperationProcInfo_x002eOperationStepInfo::Title);
#endif
}

int ns3__OperationProcInfo_x002eOperationStepInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__OperationProcInfo_x002eOperationStepInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__OperationProcInfo_x002eOperationStepInfo(struct soap *soap, const char *tag, int id, const ns3__OperationProcInfo_x002eOperationStepInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo), type))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns3:BeginDateTime", -1, &a->ns3__OperationProcInfo_x002eOperationStepInfo::BeginDateTime, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Description", -1, &a->ns3__OperationProcInfo_x002eOperationStepInfo::Description, ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns3:ElapsedMilliseconds", -1, &a->ns3__OperationProcInfo_x002eOperationStepInfo::ElapsedMilliseconds, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns3:EndDateTime", -1, &a->ns3__OperationProcInfo_x002eOperationStepInfo::EndDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates(soap, "ns3:State", -1, &a->ns3__OperationProcInfo_x002eOperationStepInfo::State, ""))
		return soap->error;
	if (soap_out_PointerTons4__OperationStepTypes(soap, "ns3:StepType", -1, &a->ns3__OperationProcInfo_x002eOperationStepInfo::StepType, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:SysTitle", -1, &a->ns3__OperationProcInfo_x002eOperationStepInfo::SysTitle, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Title", -1, &a->ns3__OperationProcInfo_x002eOperationStepInfo::Title, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__OperationProcInfo_x002eOperationStepInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__OperationProcInfo_x002eOperationStepInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__OperationProcInfo_x002eOperationStepInfo * SOAP_FMAC4 soap_in_ns3__OperationProcInfo_x002eOperationStepInfo(struct soap *soap, const char *tag, ns3__OperationProcInfo_x002eOperationStepInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__OperationProcInfo_x002eOperationStepInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo, sizeof(ns3__OperationProcInfo_x002eOperationStepInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__OperationProcInfo_x002eOperationStepInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BeginDateTime1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_ElapsedMilliseconds1 = 1;
	size_t soap_flag_EndDateTime1 = 1;
	size_t soap_flag_State1 = 1;
	size_t soap_flag_StepType1 = 1;
	size_t soap_flag_SysTitle1 = 1;
	size_t soap_flag_Title1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BeginDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns3:BeginDateTime", &a->ns3__OperationProcInfo_x002eOperationStepInfo::BeginDateTime, "xsd:dateTime"))
				{	soap_flag_BeginDateTime1--;
					continue;
				}
			}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Description", &a->ns3__OperationProcInfo_x002eOperationStepInfo::Description, "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			}
			if (soap_flag_ElapsedMilliseconds1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodouble(soap, "ns3:ElapsedMilliseconds", &a->ns3__OperationProcInfo_x002eOperationStepInfo::ElapsedMilliseconds, "xsd:double"))
				{	soap_flag_ElapsedMilliseconds1--;
					continue;
				}
			}
			if (soap_flag_EndDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns3:EndDateTime", &a->ns3__OperationProcInfo_x002eOperationStepInfo::EndDateTime, "xsd:dateTime"))
				{	soap_flag_EndDateTime1--;
					continue;
				}
			}
			if (soap_flag_State1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates(soap, "ns3:State", &a->ns3__OperationProcInfo_x002eOperationStepInfo::State, "ns3:OperationProcInfo.OperationStepInfoStates"))
				{	soap_flag_State1--;
					continue;
				}
			}
			if (soap_flag_StepType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons4__OperationStepTypes(soap, "ns3:StepType", &a->ns3__OperationProcInfo_x002eOperationStepInfo::StepType, "ns4:OperationStepTypes"))
				{	soap_flag_StepType1--;
					continue;
				}
			}
			if (soap_flag_SysTitle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:SysTitle", &a->ns3__OperationProcInfo_x002eOperationStepInfo::SysTitle, "xsd:string"))
				{	soap_flag_SysTitle1--;
					continue;
				}
			}
			if (soap_flag_Title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Title", &a->ns3__OperationProcInfo_x002eOperationStepInfo::Title, "xsd:string"))
				{	soap_flag_Title1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__OperationProcInfo_x002eOperationStepInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo, sizeof(ns3__OperationProcInfo_x002eOperationStepInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__OperationProcInfo_x002eOperationStepInfo * SOAP_FMAC2 soap_instantiate_ns3__OperationProcInfo_x002eOperationStepInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__OperationProcInfo_x002eOperationStepInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__OperationProcInfo_x002eOperationStepInfo *p;
	size_t k = sizeof(ns3__OperationProcInfo_x002eOperationStepInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__OperationProcInfo_x002eOperationStepInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__OperationProcInfo_x002eOperationStepInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__OperationProcInfo_x002eOperationStepInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__OperationProcInfo_x002eOperationStepInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__OperationProcInfo_x002eOperationStepInfo(soap, tag ? tag : "ns3:OperationProcInfo.OperationStepInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__OperationProcInfo_x002eOperationStepInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__OperationProcInfo_x002eOperationStepInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__OperationProcInfo_x002eOperationStepInfo * SOAP_FMAC4 soap_get_ns3__OperationProcInfo_x002eOperationStepInfo(struct soap *soap, ns3__OperationProcInfo_x002eOperationStepInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__OperationProcInfo_x002eOperationStepInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo(soap, &this->ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo::OperationProcInfo_x002eOperationStepInfo);
}

void ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo(soap, &this->ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo::OperationProcInfo_x002eOperationStepInfo);
#endif
}

int ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(struct soap *soap, const char *tag, int id, const ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo(soap, "ns3:OperationProcInfo.OperationStepInfo", -1, &a->ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo::OperationProcInfo_x002eOperationStepInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo * SOAP_FMAC4 soap_in_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(struct soap *soap, const char *tag, ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo, sizeof(ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo(soap, "ns3:OperationProcInfo.OperationStepInfo", &a->ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo::OperationProcInfo_x002eOperationStepInfo, "ns3:OperationProcInfo.OperationStepInfo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo, sizeof(ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *p;
	size_t k = sizeof(ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, tag ? tag : "ns3:ArrayOfOperationProcInfo.OperationStepInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo * SOAP_FMAC4 soap_get_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(struct soap *soap, ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__OperationProcInfo_x002eControlParamInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__OperationProcInfo_x002eControlParamInfo::Condition = NULL;
	this->ns3__OperationProcInfo_x002eControlParamInfo::Ok = NULL;
	this->ns3__OperationProcInfo_x002eControlParamInfo::Title = NULL;
	this->ns3__OperationProcInfo_x002eControlParamInfo::Value = NULL;
}

void ns3__OperationProcInfo_x002eControlParamInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__OperationProcInfo_x002eControlParamInfo::Condition);
	soap_serialize_PointerTobool(soap, &this->ns3__OperationProcInfo_x002eControlParamInfo::Ok);
	soap_serialize_PointerTostd__string(soap, &this->ns3__OperationProcInfo_x002eControlParamInfo::Title);
	soap_serialize_PointerTostd__string(soap, &this->ns3__OperationProcInfo_x002eControlParamInfo::Value);
#endif
}

int ns3__OperationProcInfo_x002eControlParamInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__OperationProcInfo_x002eControlParamInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__OperationProcInfo_x002eControlParamInfo(struct soap *soap, const char *tag, int id, const ns3__OperationProcInfo_x002eControlParamInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Condition", -1, &a->ns3__OperationProcInfo_x002eControlParamInfo::Condition, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns3:Ok", -1, &a->ns3__OperationProcInfo_x002eControlParamInfo::Ok, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Title", -1, &a->ns3__OperationProcInfo_x002eControlParamInfo::Title, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Value", -1, &a->ns3__OperationProcInfo_x002eControlParamInfo::Value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__OperationProcInfo_x002eControlParamInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__OperationProcInfo_x002eControlParamInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__OperationProcInfo_x002eControlParamInfo * SOAP_FMAC4 soap_in_ns3__OperationProcInfo_x002eControlParamInfo(struct soap *soap, const char *tag, ns3__OperationProcInfo_x002eControlParamInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__OperationProcInfo_x002eControlParamInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo, sizeof(ns3__OperationProcInfo_x002eControlParamInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__OperationProcInfo_x002eControlParamInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Condition1 = 1;
	size_t soap_flag_Ok1 = 1;
	size_t soap_flag_Title1 = 1;
	size_t soap_flag_Value1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Condition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Condition", &a->ns3__OperationProcInfo_x002eControlParamInfo::Condition, "xsd:string"))
				{	soap_flag_Condition1--;
					continue;
				}
			}
			if (soap_flag_Ok1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns3:Ok", &a->ns3__OperationProcInfo_x002eControlParamInfo::Ok, "xsd:boolean"))
				{	soap_flag_Ok1--;
					continue;
				}
			}
			if (soap_flag_Title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Title", &a->ns3__OperationProcInfo_x002eControlParamInfo::Title, "xsd:string"))
				{	soap_flag_Title1--;
					continue;
				}
			}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Value", &a->ns3__OperationProcInfo_x002eControlParamInfo::Value, "xsd:string"))
				{	soap_flag_Value1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__OperationProcInfo_x002eControlParamInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo, SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo, sizeof(ns3__OperationProcInfo_x002eControlParamInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__OperationProcInfo_x002eControlParamInfo * SOAP_FMAC2 soap_instantiate_ns3__OperationProcInfo_x002eControlParamInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__OperationProcInfo_x002eControlParamInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__OperationProcInfo_x002eControlParamInfo *p;
	size_t k = sizeof(ns3__OperationProcInfo_x002eControlParamInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__OperationProcInfo_x002eControlParamInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__OperationProcInfo_x002eControlParamInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__OperationProcInfo_x002eControlParamInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__OperationProcInfo_x002eControlParamInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__OperationProcInfo_x002eControlParamInfo(soap, tag ? tag : "ns3:OperationProcInfo.ControlParamInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__OperationProcInfo_x002eControlParamInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__OperationProcInfo_x002eControlParamInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__OperationProcInfo_x002eControlParamInfo * SOAP_FMAC4 soap_get_ns3__OperationProcInfo_x002eControlParamInfo(struct soap *soap, ns3__OperationProcInfo_x002eControlParamInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__OperationProcInfo_x002eControlParamInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfOperationProcInfo_x002eControlParamInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo(soap, &this->ns3__ArrayOfOperationProcInfo_x002eControlParamInfo::OperationProcInfo_x002eControlParamInfo);
}

void ns3__ArrayOfOperationProcInfo_x002eControlParamInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo(soap, &this->ns3__ArrayOfOperationProcInfo_x002eControlParamInfo::OperationProcInfo_x002eControlParamInfo);
#endif
}

int ns3__ArrayOfOperationProcInfo_x002eControlParamInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(struct soap *soap, const char *tag, int id, const ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo(soap, "ns3:OperationProcInfo.ControlParamInfo", -1, &a->ns3__ArrayOfOperationProcInfo_x002eControlParamInfo::OperationProcInfo_x002eControlParamInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfOperationProcInfo_x002eControlParamInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfOperationProcInfo_x002eControlParamInfo * SOAP_FMAC4 soap_in_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(struct soap *soap, const char *tag, ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfOperationProcInfo_x002eControlParamInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo, sizeof(ns3__ArrayOfOperationProcInfo_x002eControlParamInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo(soap, "ns3:OperationProcInfo.ControlParamInfo", &a->ns3__ArrayOfOperationProcInfo_x002eControlParamInfo::OperationProcInfo_x002eControlParamInfo, "ns3:OperationProcInfo.ControlParamInfo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo, sizeof(ns3__ArrayOfOperationProcInfo_x002eControlParamInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfOperationProcInfo_x002eControlParamInfo * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *p;
	size_t k = sizeof(ns3__ArrayOfOperationProcInfo_x002eControlParamInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfOperationProcInfo_x002eControlParamInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfOperationProcInfo_x002eControlParamInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfOperationProcInfo_x002eControlParamInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfOperationProcInfo_x002eControlParamInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, tag ? tag : "ns3:ArrayOfOperationProcInfo.ControlParamInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfOperationProcInfo_x002eControlParamInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfOperationProcInfo_x002eControlParamInfo * SOAP_FMAC4 soap_get_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(struct soap *soap, ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__OperationProcInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__OperationProcInfo::AuxDevicesStatus = NULL;
	this->ns3__OperationProcInfo::BeginDateTime = NULL;
	this->ns3__OperationProcInfo::ControlParams = NULL;
	this->ns3__OperationProcInfo::EndDateTime = NULL;
	this->ns3__OperationProcInfo::OperationStepsInfo = NULL;
	this->ns3__OperationProcInfo::OperationTitle = NULL;
	this->ns3__OperationProcInfo::PanelErrors = NULL;
	this->ns3__OperationProcInfo::PanelMode = NULL;
	this->ns3__OperationProcInfo::PanelStatus = NULL;
}

void ns3__OperationProcInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__OperationProcInfo::AuxDevicesStatus);
	soap_serialize_PointerTodateTime(soap, &this->ns3__OperationProcInfo::BeginDateTime);
	soap_serialize_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, &this->ns3__OperationProcInfo::ControlParams);
	soap_serialize_PointerTodateTime(soap, &this->ns3__OperationProcInfo::EndDateTime);
	soap_serialize_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, &this->ns3__OperationProcInfo::OperationStepsInfo);
	soap_serialize_PointerTostd__string(soap, &this->ns3__OperationProcInfo::OperationTitle);
	soap_serialize_PointerToarr__ArrayOfstring(soap, &this->ns3__OperationProcInfo::PanelErrors);
	soap_serialize_PointerTostd__string(soap, &this->ns3__OperationProcInfo::PanelMode);
	soap_serialize_PointerTostd__string(soap, &this->ns3__OperationProcInfo::PanelStatus);
#endif
}

int ns3__OperationProcInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__OperationProcInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__OperationProcInfo(struct soap *soap, const char *tag, int id, const ns3__OperationProcInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__OperationProcInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:AuxDevicesStatus", -1, &a->ns3__OperationProcInfo::AuxDevicesStatus, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns3:BeginDateTime", -1, &a->ns3__OperationProcInfo::BeginDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, "ns3:ControlParams", -1, &a->ns3__OperationProcInfo::ControlParams, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns3:EndDateTime", -1, &a->ns3__OperationProcInfo::EndDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, "ns3:OperationStepsInfo", -1, &a->ns3__OperationProcInfo::OperationStepsInfo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:OperationTitle", -1, &a->ns3__OperationProcInfo::OperationTitle, ""))
		return soap->error;
	if (soap_out_PointerToarr__ArrayOfstring(soap, "ns3:PanelErrors", -1, &a->ns3__OperationProcInfo::PanelErrors, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:PanelMode", -1, &a->ns3__OperationProcInfo::PanelMode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:PanelStatus", -1, &a->ns3__OperationProcInfo::PanelStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__OperationProcInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__OperationProcInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__OperationProcInfo * SOAP_FMAC4 soap_in_ns3__OperationProcInfo(struct soap *soap, const char *tag, ns3__OperationProcInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__OperationProcInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__OperationProcInfo, sizeof(ns3__OperationProcInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__OperationProcInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__OperationProcInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AuxDevicesStatus1 = 1;
	size_t soap_flag_BeginDateTime1 = 1;
	size_t soap_flag_ControlParams1 = 1;
	size_t soap_flag_EndDateTime1 = 1;
	size_t soap_flag_OperationStepsInfo1 = 1;
	size_t soap_flag_OperationTitle1 = 1;
	size_t soap_flag_PanelErrors1 = 1;
	size_t soap_flag_PanelMode1 = 1;
	size_t soap_flag_PanelStatus1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxDevicesStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:AuxDevicesStatus", &a->ns3__OperationProcInfo::AuxDevicesStatus, "xsd:string"))
				{	soap_flag_AuxDevicesStatus1--;
					continue;
				}
			}
			if (soap_flag_BeginDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns3:BeginDateTime", &a->ns3__OperationProcInfo::BeginDateTime, "xsd:dateTime"))
				{	soap_flag_BeginDateTime1--;
					continue;
				}
			}
			if (soap_flag_ControlParams1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, "ns3:ControlParams", &a->ns3__OperationProcInfo::ControlParams, "ns3:ArrayOfOperationProcInfo.ControlParamInfo"))
				{	soap_flag_ControlParams1--;
					continue;
				}
			}
			if (soap_flag_EndDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns3:EndDateTime", &a->ns3__OperationProcInfo::EndDateTime, "xsd:dateTime"))
				{	soap_flag_EndDateTime1--;
					continue;
				}
			}
			if (soap_flag_OperationStepsInfo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, "ns3:OperationStepsInfo", &a->ns3__OperationProcInfo::OperationStepsInfo, "ns3:ArrayOfOperationProcInfo.OperationStepInfo"))
				{	soap_flag_OperationStepsInfo1--;
					continue;
				}
			}
			if (soap_flag_OperationTitle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:OperationTitle", &a->ns3__OperationProcInfo::OperationTitle, "xsd:string"))
				{	soap_flag_OperationTitle1--;
					continue;
				}
			}
			if (soap_flag_PanelErrors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToarr__ArrayOfstring(soap, "ns3:PanelErrors", &a->ns3__OperationProcInfo::PanelErrors, "arr:ArrayOfstring"))
				{	soap_flag_PanelErrors1--;
					continue;
				}
			}
			if (soap_flag_PanelMode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:PanelMode", &a->ns3__OperationProcInfo::PanelMode, "xsd:string"))
				{	soap_flag_PanelMode1--;
					continue;
				}
			}
			if (soap_flag_PanelStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:PanelStatus", &a->ns3__OperationProcInfo::PanelStatus, "xsd:string"))
				{	soap_flag_PanelStatus1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__OperationProcInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__OperationProcInfo, SOAP_TYPE_ns3__OperationProcInfo, sizeof(ns3__OperationProcInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__OperationProcInfo * SOAP_FMAC2 soap_instantiate_ns3__OperationProcInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__OperationProcInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__OperationProcInfo *p;
	size_t k = sizeof(ns3__OperationProcInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__OperationProcInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__OperationProcInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__OperationProcInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__OperationProcInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__OperationProcInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__OperationProcInfo(soap, tag ? tag : "ns3:OperationProcInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__OperationProcInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__OperationProcInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__OperationProcInfo * SOAP_FMAC4 soap_get_ns3__OperationProcInfo(struct soap *soap, ns3__OperationProcInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__OperationProcInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ProcessingInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ProcessingInfo::CurrentDateTime = NULL;
	this->ns3__ProcessingInfo::IgnoreClearing = NULL;
	this->ns3__ProcessingInfo::OperationInfo = NULL;
	this->ns3__ProcessingInfo::ProcessingMode = NULL;
}

void ns3__ProcessingInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTodateTime(soap, &this->ns3__ProcessingInfo::CurrentDateTime);
	soap_serialize_PointerTobool(soap, &this->ns3__ProcessingInfo::IgnoreClearing);
	soap_serialize_PointerTons3__OperationProcInfo(soap, &this->ns3__ProcessingInfo::OperationInfo);
	soap_serialize_PointerTons3__ProcessingModes(soap, &this->ns3__ProcessingInfo::ProcessingMode);
#endif
}

int ns3__ProcessingInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ProcessingInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ProcessingInfo(struct soap *soap, const char *tag, int id, const ns3__ProcessingInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ProcessingInfo), type))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns3:CurrentDateTime", -1, &a->ns3__ProcessingInfo::CurrentDateTime, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns3:IgnoreClearing", -1, &a->ns3__ProcessingInfo::IgnoreClearing, ""))
		return soap->error;
	if (soap_out_PointerTons3__OperationProcInfo(soap, "ns3:OperationInfo", -1, &a->ns3__ProcessingInfo::OperationInfo, ""))
		return soap->error;
	if (soap_out_PointerTons3__ProcessingModes(soap, "ns3:ProcessingMode", -1, &a->ns3__ProcessingInfo::ProcessingMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ProcessingInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ProcessingInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ProcessingInfo * SOAP_FMAC4 soap_in_ns3__ProcessingInfo(struct soap *soap, const char *tag, ns3__ProcessingInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ProcessingInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ProcessingInfo, sizeof(ns3__ProcessingInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__ProcessingInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ProcessingInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CurrentDateTime1 = 1;
	size_t soap_flag_IgnoreClearing1 = 1;
	size_t soap_flag_OperationInfo1 = 1;
	size_t soap_flag_ProcessingMode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CurrentDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns3:CurrentDateTime", &a->ns3__ProcessingInfo::CurrentDateTime, "xsd:dateTime"))
				{	soap_flag_CurrentDateTime1--;
					continue;
				}
			}
			if (soap_flag_IgnoreClearing1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns3:IgnoreClearing", &a->ns3__ProcessingInfo::IgnoreClearing, "xsd:boolean"))
				{	soap_flag_IgnoreClearing1--;
					continue;
				}
			}
			if (soap_flag_OperationInfo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__OperationProcInfo(soap, "ns3:OperationInfo", &a->ns3__ProcessingInfo::OperationInfo, "ns3:OperationProcInfo"))
				{	soap_flag_OperationInfo1--;
					continue;
				}
			}
			if (soap_flag_ProcessingMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ProcessingModes(soap, "ns3:ProcessingMode", &a->ns3__ProcessingInfo::ProcessingMode, "ns3:ProcessingModes"))
				{	soap_flag_ProcessingMode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ProcessingInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ProcessingInfo, SOAP_TYPE_ns3__ProcessingInfo, sizeof(ns3__ProcessingInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ProcessingInfo * SOAP_FMAC2 soap_instantiate_ns3__ProcessingInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ProcessingInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ProcessingInfo *p;
	size_t k = sizeof(ns3__ProcessingInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__ProcessingInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ProcessingInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ProcessingInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ProcessingInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ProcessingInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ProcessingInfo(soap, tag ? tag : "ns3:ProcessingInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ProcessingInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ProcessingInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ProcessingInfo * SOAP_FMAC4 soap_get_ns3__ProcessingInfo(struct soap *soap, ns3__ProcessingInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ProcessingInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetEventsSinceIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetEventsSinceIdResponse::GetEventsSinceIdResult = NULL;
}

void _ns2__GetEventsSinceIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons10__ArrayOfEEvent(soap, &this->_ns2__GetEventsSinceIdResponse::GetEventsSinceIdResult);
#endif
}

int _ns2__GetEventsSinceIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetEventsSinceIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetEventsSinceIdResponse(struct soap *soap, const char *tag, int id, const _ns2__GetEventsSinceIdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetEventsSinceIdResponse), type))
		return soap->error;
	if (a->GetEventsSinceIdResult)
		soap_element_result(soap, "ns2:GetEventsSinceIdResult");
	if (soap_out_PointerTons10__ArrayOfEEvent(soap, "ns2:GetEventsSinceIdResult", -1, &a->_ns2__GetEventsSinceIdResponse::GetEventsSinceIdResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetEventsSinceIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetEventsSinceIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetEventsSinceIdResponse * SOAP_FMAC4 soap_in__ns2__GetEventsSinceIdResponse(struct soap *soap, const char *tag, _ns2__GetEventsSinceIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetEventsSinceIdResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetEventsSinceIdResponse, sizeof(_ns2__GetEventsSinceIdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetEventsSinceIdResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetEventsSinceIdResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetEventsSinceIdResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetEventsSinceIdResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons10__ArrayOfEEvent(soap, "ns2:GetEventsSinceIdResult", &a->_ns2__GetEventsSinceIdResponse::GetEventsSinceIdResult, "ns10:ArrayOfEEvent"))
				{	soap_flag_GetEventsSinceIdResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns2:GetEventsSinceIdResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetEventsSinceIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetEventsSinceIdResponse, SOAP_TYPE__ns2__GetEventsSinceIdResponse, sizeof(_ns2__GetEventsSinceIdResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetEventsSinceIdResponse * SOAP_FMAC2 soap_instantiate__ns2__GetEventsSinceIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetEventsSinceIdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetEventsSinceIdResponse *p;
	size_t k = sizeof(_ns2__GetEventsSinceIdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetEventsSinceIdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetEventsSinceIdResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetEventsSinceIdResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetEventsSinceIdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetEventsSinceIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetEventsSinceIdResponse(soap, tag ? tag : "ns2:GetEventsSinceIdResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetEventsSinceIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetEventsSinceIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetEventsSinceIdResponse * SOAP_FMAC4 soap_get__ns2__GetEventsSinceIdResponse(struct soap *soap, _ns2__GetEventsSinceIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetEventsSinceIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetEventsSinceId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetEventsSinceId::lastId = NULL;
}

void _ns2__GetEventsSinceId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_ns2__GetEventsSinceId::lastId);
#endif
}

int _ns2__GetEventsSinceId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetEventsSinceId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetEventsSinceId(struct soap *soap, const char *tag, int id, const _ns2__GetEventsSinceId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetEventsSinceId), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns2:lastId", -1, &a->_ns2__GetEventsSinceId::lastId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetEventsSinceId::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetEventsSinceId(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetEventsSinceId * SOAP_FMAC4 soap_in__ns2__GetEventsSinceId(struct soap *soap, const char *tag, _ns2__GetEventsSinceId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetEventsSinceId*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetEventsSinceId, sizeof(_ns2__GetEventsSinceId), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetEventsSinceId)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetEventsSinceId *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_lastId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lastId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns2:lastId", &a->_ns2__GetEventsSinceId::lastId, "xsd:int"))
				{	soap_flag_lastId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetEventsSinceId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetEventsSinceId, SOAP_TYPE__ns2__GetEventsSinceId, sizeof(_ns2__GetEventsSinceId), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetEventsSinceId * SOAP_FMAC2 soap_instantiate__ns2__GetEventsSinceId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetEventsSinceId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetEventsSinceId *p;
	size_t k = sizeof(_ns2__GetEventsSinceId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetEventsSinceId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetEventsSinceId);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetEventsSinceId, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetEventsSinceId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetEventsSinceId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetEventsSinceId(soap, tag ? tag : "ns2:GetEventsSinceId", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetEventsSinceId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetEventsSinceId(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetEventsSinceId * SOAP_FMAC4 soap_get__ns2__GetEventsSinceId(struct soap *soap, _ns2__GetEventsSinceId *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetEventsSinceId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetLastEventIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetLastEventIdResponse::GetLastEventIdResult = NULL;
}

void _ns2__GetLastEventIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_ns2__GetLastEventIdResponse::GetLastEventIdResult);
#endif
}

int _ns2__GetLastEventIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetLastEventIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetLastEventIdResponse(struct soap *soap, const char *tag, int id, const _ns2__GetLastEventIdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetLastEventIdResponse), type))
		return soap->error;
	if (a->GetLastEventIdResult)
		soap_element_result(soap, "ns2:GetLastEventIdResult");
	if (soap_out_PointerToint(soap, "ns2:GetLastEventIdResult", -1, &a->_ns2__GetLastEventIdResponse::GetLastEventIdResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetLastEventIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetLastEventIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetLastEventIdResponse * SOAP_FMAC4 soap_in__ns2__GetLastEventIdResponse(struct soap *soap, const char *tag, _ns2__GetLastEventIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetLastEventIdResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetLastEventIdResponse, sizeof(_ns2__GetLastEventIdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetLastEventIdResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetLastEventIdResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetLastEventIdResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLastEventIdResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns2:GetLastEventIdResult", &a->_ns2__GetLastEventIdResponse::GetLastEventIdResult, "xsd:int"))
				{	soap_flag_GetLastEventIdResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns2:GetLastEventIdResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetLastEventIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetLastEventIdResponse, SOAP_TYPE__ns2__GetLastEventIdResponse, sizeof(_ns2__GetLastEventIdResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetLastEventIdResponse * SOAP_FMAC2 soap_instantiate__ns2__GetLastEventIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetLastEventIdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetLastEventIdResponse *p;
	size_t k = sizeof(_ns2__GetLastEventIdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetLastEventIdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetLastEventIdResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetLastEventIdResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetLastEventIdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetLastEventIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetLastEventIdResponse(soap, tag ? tag : "ns2:GetLastEventIdResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetLastEventIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetLastEventIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetLastEventIdResponse * SOAP_FMAC4 soap_get__ns2__GetLastEventIdResponse(struct soap *soap, _ns2__GetLastEventIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetLastEventIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetLastEventId::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns2__GetLastEventId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__GetLastEventId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetLastEventId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetLastEventId(struct soap *soap, const char *tag, int id, const _ns2__GetLastEventId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetLastEventId), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetLastEventId::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetLastEventId(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetLastEventId * SOAP_FMAC4 soap_in__ns2__GetLastEventId(struct soap *soap, const char *tag, _ns2__GetLastEventId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetLastEventId*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetLastEventId, sizeof(_ns2__GetLastEventId), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetLastEventId)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetLastEventId *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetLastEventId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetLastEventId, SOAP_TYPE__ns2__GetLastEventId, sizeof(_ns2__GetLastEventId), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetLastEventId * SOAP_FMAC2 soap_instantiate__ns2__GetLastEventId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetLastEventId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetLastEventId *p;
	size_t k = sizeof(_ns2__GetLastEventId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetLastEventId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetLastEventId);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetLastEventId, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetLastEventId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetLastEventId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetLastEventId(soap, tag ? tag : "ns2:GetLastEventId", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetLastEventId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetLastEventId(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetLastEventId * SOAP_FMAC4 soap_get__ns2__GetLastEventId(struct soap *soap, _ns2__GetLastEventId *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetLastEventId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetEventsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetEventsResponse::GetEventsResult = NULL;
}

void _ns2__GetEventsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons10__ArrayOfEEvent(soap, &this->_ns2__GetEventsResponse::GetEventsResult);
#endif
}

int _ns2__GetEventsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetEventsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetEventsResponse(struct soap *soap, const char *tag, int id, const _ns2__GetEventsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetEventsResponse), type))
		return soap->error;
	if (a->GetEventsResult)
		soap_element_result(soap, "ns2:GetEventsResult");
	if (soap_out_PointerTons10__ArrayOfEEvent(soap, "ns2:GetEventsResult", -1, &a->_ns2__GetEventsResponse::GetEventsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetEventsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetEventsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetEventsResponse * SOAP_FMAC4 soap_in__ns2__GetEventsResponse(struct soap *soap, const char *tag, _ns2__GetEventsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetEventsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetEventsResponse, sizeof(_ns2__GetEventsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetEventsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetEventsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetEventsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetEventsResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons10__ArrayOfEEvent(soap, "ns2:GetEventsResult", &a->_ns2__GetEventsResponse::GetEventsResult, "ns10:ArrayOfEEvent"))
				{	soap_flag_GetEventsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns2:GetEventsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetEventsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetEventsResponse, SOAP_TYPE__ns2__GetEventsResponse, sizeof(_ns2__GetEventsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetEventsResponse * SOAP_FMAC2 soap_instantiate__ns2__GetEventsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetEventsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetEventsResponse *p;
	size_t k = sizeof(_ns2__GetEventsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetEventsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetEventsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetEventsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetEventsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetEventsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetEventsResponse(soap, tag ? tag : "ns2:GetEventsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetEventsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetEventsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetEventsResponse * SOAP_FMAC4 soap_get__ns2__GetEventsResponse(struct soap *soap, _ns2__GetEventsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetEventsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetEvents::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetEvents::beginDateTime = NULL;
	this->_ns2__GetEvents::endDateTime = NULL;
}

void _ns2__GetEvents::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTodateTime(soap, &this->_ns2__GetEvents::beginDateTime);
	soap_serialize_PointerTodateTime(soap, &this->_ns2__GetEvents::endDateTime);
#endif
}

int _ns2__GetEvents::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetEvents(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetEvents(struct soap *soap, const char *tag, int id, const _ns2__GetEvents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetEvents), type))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns2:beginDateTime", -1, &a->_ns2__GetEvents::beginDateTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns2:endDateTime", -1, &a->_ns2__GetEvents::endDateTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetEvents::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetEvents(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetEvents * SOAP_FMAC4 soap_in__ns2__GetEvents(struct soap *soap, const char *tag, _ns2__GetEvents *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetEvents*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetEvents, sizeof(_ns2__GetEvents), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetEvents)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetEvents *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_beginDateTime1 = 1;
	size_t soap_flag_endDateTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_beginDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns2:beginDateTime", &a->_ns2__GetEvents::beginDateTime, "xsd:dateTime"))
				{	soap_flag_beginDateTime1--;
					continue;
				}
			}
			if (soap_flag_endDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns2:endDateTime", &a->_ns2__GetEvents::endDateTime, "xsd:dateTime"))
				{	soap_flag_endDateTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetEvents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetEvents, SOAP_TYPE__ns2__GetEvents, sizeof(_ns2__GetEvents), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetEvents * SOAP_FMAC2 soap_instantiate__ns2__GetEvents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetEvents(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetEvents *p;
	size_t k = sizeof(_ns2__GetEvents);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetEvents, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetEvents);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetEvents, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetEvents location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetEvents::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetEvents(soap, tag ? tag : "ns2:GetEvents", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetEvents::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetEvents(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetEvents * SOAP_FMAC4 soap_get__ns2__GetEvents(struct soap *soap, _ns2__GetEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetResultsSinceIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetResultsSinceIdResponse::GetResultsSinceIdResult = NULL;
}

void _ns2__GetResultsSinceIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons10__ArrayOfESample(soap, &this->_ns2__GetResultsSinceIdResponse::GetResultsSinceIdResult);
#endif
}

int _ns2__GetResultsSinceIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetResultsSinceIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetResultsSinceIdResponse(struct soap *soap, const char *tag, int id, const _ns2__GetResultsSinceIdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetResultsSinceIdResponse), type))
		return soap->error;
	if (a->GetResultsSinceIdResult)
		soap_element_result(soap, "ns2:GetResultsSinceIdResult");
	if (soap_out_PointerTons10__ArrayOfESample(soap, "ns2:GetResultsSinceIdResult", -1, &a->_ns2__GetResultsSinceIdResponse::GetResultsSinceIdResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetResultsSinceIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetResultsSinceIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetResultsSinceIdResponse * SOAP_FMAC4 soap_in__ns2__GetResultsSinceIdResponse(struct soap *soap, const char *tag, _ns2__GetResultsSinceIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetResultsSinceIdResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetResultsSinceIdResponse, sizeof(_ns2__GetResultsSinceIdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetResultsSinceIdResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetResultsSinceIdResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetResultsSinceIdResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetResultsSinceIdResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons10__ArrayOfESample(soap, "ns2:GetResultsSinceIdResult", &a->_ns2__GetResultsSinceIdResponse::GetResultsSinceIdResult, "ns10:ArrayOfESample"))
				{	soap_flag_GetResultsSinceIdResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns2:GetResultsSinceIdResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetResultsSinceIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetResultsSinceIdResponse, SOAP_TYPE__ns2__GetResultsSinceIdResponse, sizeof(_ns2__GetResultsSinceIdResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetResultsSinceIdResponse * SOAP_FMAC2 soap_instantiate__ns2__GetResultsSinceIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetResultsSinceIdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetResultsSinceIdResponse *p;
	size_t k = sizeof(_ns2__GetResultsSinceIdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetResultsSinceIdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetResultsSinceIdResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetResultsSinceIdResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetResultsSinceIdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetResultsSinceIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetResultsSinceIdResponse(soap, tag ? tag : "ns2:GetResultsSinceIdResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetResultsSinceIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetResultsSinceIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetResultsSinceIdResponse * SOAP_FMAC4 soap_get__ns2__GetResultsSinceIdResponse(struct soap *soap, _ns2__GetResultsSinceIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetResultsSinceIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetResultsSinceId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetResultsSinceId::lastId = NULL;
}

void _ns2__GetResultsSinceId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_ns2__GetResultsSinceId::lastId);
#endif
}

int _ns2__GetResultsSinceId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetResultsSinceId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetResultsSinceId(struct soap *soap, const char *tag, int id, const _ns2__GetResultsSinceId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetResultsSinceId), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns2:lastId", -1, &a->_ns2__GetResultsSinceId::lastId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetResultsSinceId::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetResultsSinceId(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetResultsSinceId * SOAP_FMAC4 soap_in__ns2__GetResultsSinceId(struct soap *soap, const char *tag, _ns2__GetResultsSinceId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetResultsSinceId*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetResultsSinceId, sizeof(_ns2__GetResultsSinceId), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetResultsSinceId)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetResultsSinceId *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_lastId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lastId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns2:lastId", &a->_ns2__GetResultsSinceId::lastId, "xsd:int"))
				{	soap_flag_lastId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetResultsSinceId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetResultsSinceId, SOAP_TYPE__ns2__GetResultsSinceId, sizeof(_ns2__GetResultsSinceId), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetResultsSinceId * SOAP_FMAC2 soap_instantiate__ns2__GetResultsSinceId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetResultsSinceId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetResultsSinceId *p;
	size_t k = sizeof(_ns2__GetResultsSinceId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetResultsSinceId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetResultsSinceId);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetResultsSinceId, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetResultsSinceId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetResultsSinceId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetResultsSinceId(soap, tag ? tag : "ns2:GetResultsSinceId", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetResultsSinceId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetResultsSinceId(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetResultsSinceId * SOAP_FMAC4 soap_get__ns2__GetResultsSinceId(struct soap *soap, _ns2__GetResultsSinceId *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetResultsSinceId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetLastResultIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetLastResultIdResponse::GetLastResultIdResult = NULL;
}

void _ns2__GetLastResultIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_ns2__GetLastResultIdResponse::GetLastResultIdResult);
#endif
}

int _ns2__GetLastResultIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetLastResultIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetLastResultIdResponse(struct soap *soap, const char *tag, int id, const _ns2__GetLastResultIdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetLastResultIdResponse), type))
		return soap->error;
	if (a->GetLastResultIdResult)
		soap_element_result(soap, "ns2:GetLastResultIdResult");
	if (soap_out_PointerToint(soap, "ns2:GetLastResultIdResult", -1, &a->_ns2__GetLastResultIdResponse::GetLastResultIdResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetLastResultIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetLastResultIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetLastResultIdResponse * SOAP_FMAC4 soap_in__ns2__GetLastResultIdResponse(struct soap *soap, const char *tag, _ns2__GetLastResultIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetLastResultIdResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetLastResultIdResponse, sizeof(_ns2__GetLastResultIdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetLastResultIdResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetLastResultIdResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetLastResultIdResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLastResultIdResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns2:GetLastResultIdResult", &a->_ns2__GetLastResultIdResponse::GetLastResultIdResult, "xsd:int"))
				{	soap_flag_GetLastResultIdResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns2:GetLastResultIdResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetLastResultIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetLastResultIdResponse, SOAP_TYPE__ns2__GetLastResultIdResponse, sizeof(_ns2__GetLastResultIdResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetLastResultIdResponse * SOAP_FMAC2 soap_instantiate__ns2__GetLastResultIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetLastResultIdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetLastResultIdResponse *p;
	size_t k = sizeof(_ns2__GetLastResultIdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetLastResultIdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetLastResultIdResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetLastResultIdResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetLastResultIdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetLastResultIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetLastResultIdResponse(soap, tag ? tag : "ns2:GetLastResultIdResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetLastResultIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetLastResultIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetLastResultIdResponse * SOAP_FMAC4 soap_get__ns2__GetLastResultIdResponse(struct soap *soap, _ns2__GetLastResultIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetLastResultIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetLastResultId::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns2__GetLastResultId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__GetLastResultId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetLastResultId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetLastResultId(struct soap *soap, const char *tag, int id, const _ns2__GetLastResultId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetLastResultId), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetLastResultId::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetLastResultId(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetLastResultId * SOAP_FMAC4 soap_in__ns2__GetLastResultId(struct soap *soap, const char *tag, _ns2__GetLastResultId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetLastResultId*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetLastResultId, sizeof(_ns2__GetLastResultId), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetLastResultId)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetLastResultId *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetLastResultId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetLastResultId, SOAP_TYPE__ns2__GetLastResultId, sizeof(_ns2__GetLastResultId), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetLastResultId * SOAP_FMAC2 soap_instantiate__ns2__GetLastResultId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetLastResultId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetLastResultId *p;
	size_t k = sizeof(_ns2__GetLastResultId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetLastResultId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetLastResultId);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetLastResultId, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetLastResultId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetLastResultId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetLastResultId(soap, tag ? tag : "ns2:GetLastResultId", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetLastResultId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetLastResultId(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetLastResultId * SOAP_FMAC4 soap_get__ns2__GetLastResultId(struct soap *soap, _ns2__GetLastResultId *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetLastResultId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetLastResultResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetLastResultResponse::GetLastResultResult = NULL;
}

void _ns2__GetLastResultResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons10__ESample(soap, &this->_ns2__GetLastResultResponse::GetLastResultResult);
#endif
}

int _ns2__GetLastResultResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetLastResultResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetLastResultResponse(struct soap *soap, const char *tag, int id, const _ns2__GetLastResultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetLastResultResponse), type))
		return soap->error;
	if (a->GetLastResultResult)
		soap_element_result(soap, "ns2:GetLastResultResult");
	if (soap_out_PointerTons10__ESample(soap, "ns2:GetLastResultResult", -1, &a->_ns2__GetLastResultResponse::GetLastResultResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetLastResultResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetLastResultResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetLastResultResponse * SOAP_FMAC4 soap_in__ns2__GetLastResultResponse(struct soap *soap, const char *tag, _ns2__GetLastResultResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetLastResultResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetLastResultResponse, sizeof(_ns2__GetLastResultResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetLastResultResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetLastResultResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetLastResultResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLastResultResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons10__ESample(soap, "ns2:GetLastResultResult", &a->_ns2__GetLastResultResponse::GetLastResultResult, "ns10:ESample"))
				{	soap_flag_GetLastResultResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns2:GetLastResultResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetLastResultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetLastResultResponse, SOAP_TYPE__ns2__GetLastResultResponse, sizeof(_ns2__GetLastResultResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetLastResultResponse * SOAP_FMAC2 soap_instantiate__ns2__GetLastResultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetLastResultResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetLastResultResponse *p;
	size_t k = sizeof(_ns2__GetLastResultResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetLastResultResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetLastResultResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetLastResultResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetLastResultResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetLastResultResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetLastResultResponse(soap, tag ? tag : "ns2:GetLastResultResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetLastResultResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetLastResultResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetLastResultResponse * SOAP_FMAC4 soap_get__ns2__GetLastResultResponse(struct soap *soap, _ns2__GetLastResultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetLastResultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetLastResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetLastResult::sampleType = NULL;
}

void _ns2__GetLastResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons10__ESampleTypes(soap, &this->_ns2__GetLastResult::sampleType);
#endif
}

int _ns2__GetLastResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetLastResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetLastResult(struct soap *soap, const char *tag, int id, const _ns2__GetLastResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetLastResult), type))
		return soap->error;
	if (soap_out_PointerTons10__ESampleTypes(soap, "ns2:sampleType", -1, &a->_ns2__GetLastResult::sampleType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetLastResult::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetLastResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetLastResult * SOAP_FMAC4 soap_in__ns2__GetLastResult(struct soap *soap, const char *tag, _ns2__GetLastResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetLastResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetLastResult, sizeof(_ns2__GetLastResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetLastResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetLastResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sampleType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sampleType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons10__ESampleTypes(soap, "ns2:sampleType", &a->_ns2__GetLastResult::sampleType, "ns10:ESampleTypes"))
				{	soap_flag_sampleType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetLastResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetLastResult, SOAP_TYPE__ns2__GetLastResult, sizeof(_ns2__GetLastResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetLastResult * SOAP_FMAC2 soap_instantiate__ns2__GetLastResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetLastResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetLastResult *p;
	size_t k = sizeof(_ns2__GetLastResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetLastResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetLastResult);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetLastResult, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetLastResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetLastResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetLastResult(soap, tag ? tag : "ns2:GetLastResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetLastResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetLastResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetLastResult * SOAP_FMAC4 soap_get__ns2__GetLastResult(struct soap *soap, _ns2__GetLastResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetLastResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetResultsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetResultsResponse::GetResultsResult = NULL;
}

void _ns2__GetResultsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons10__ArrayOfESample(soap, &this->_ns2__GetResultsResponse::GetResultsResult);
#endif
}

int _ns2__GetResultsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetResultsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetResultsResponse(struct soap *soap, const char *tag, int id, const _ns2__GetResultsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetResultsResponse), type))
		return soap->error;
	if (a->GetResultsResult)
		soap_element_result(soap, "ns2:GetResultsResult");
	if (soap_out_PointerTons10__ArrayOfESample(soap, "ns2:GetResultsResult", -1, &a->_ns2__GetResultsResponse::GetResultsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetResultsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetResultsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetResultsResponse * SOAP_FMAC4 soap_in__ns2__GetResultsResponse(struct soap *soap, const char *tag, _ns2__GetResultsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetResultsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetResultsResponse, sizeof(_ns2__GetResultsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetResultsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetResultsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetResultsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetResultsResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons10__ArrayOfESample(soap, "ns2:GetResultsResult", &a->_ns2__GetResultsResponse::GetResultsResult, "ns10:ArrayOfESample"))
				{	soap_flag_GetResultsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns2:GetResultsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetResultsResponse, SOAP_TYPE__ns2__GetResultsResponse, sizeof(_ns2__GetResultsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetResultsResponse * SOAP_FMAC2 soap_instantiate__ns2__GetResultsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetResultsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetResultsResponse *p;
	size_t k = sizeof(_ns2__GetResultsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetResultsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetResultsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetResultsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetResultsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetResultsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetResultsResponse(soap, tag ? tag : "ns2:GetResultsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetResultsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetResultsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetResultsResponse * SOAP_FMAC4 soap_get__ns2__GetResultsResponse(struct soap *soap, _ns2__GetResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetResults::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetResults::beginDateTime = NULL;
	this->_ns2__GetResults::endDateTime = NULL;
	this->_ns2__GetResults::sampleType = NULL;
}

void _ns2__GetResults::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTodateTime(soap, &this->_ns2__GetResults::beginDateTime);
	soap_serialize_PointerTodateTime(soap, &this->_ns2__GetResults::endDateTime);
	soap_serialize_PointerTons10__ESampleTypes(soap, &this->_ns2__GetResults::sampleType);
#endif
}

int _ns2__GetResults::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetResults(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetResults(struct soap *soap, const char *tag, int id, const _ns2__GetResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetResults), type))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns2:beginDateTime", -1, &a->_ns2__GetResults::beginDateTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns2:endDateTime", -1, &a->_ns2__GetResults::endDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons10__ESampleTypes(soap, "ns2:sampleType", -1, &a->_ns2__GetResults::sampleType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetResults::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetResults(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetResults * SOAP_FMAC4 soap_in__ns2__GetResults(struct soap *soap, const char *tag, _ns2__GetResults *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetResults*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetResults, sizeof(_ns2__GetResults), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetResults)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetResults *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_beginDateTime1 = 1;
	size_t soap_flag_endDateTime1 = 1;
	size_t soap_flag_sampleType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_beginDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns2:beginDateTime", &a->_ns2__GetResults::beginDateTime, "xsd:dateTime"))
				{	soap_flag_beginDateTime1--;
					continue;
				}
			}
			if (soap_flag_endDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns2:endDateTime", &a->_ns2__GetResults::endDateTime, "xsd:dateTime"))
				{	soap_flag_endDateTime1--;
					continue;
				}
			}
			if (soap_flag_sampleType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons10__ESampleTypes(soap, "ns2:sampleType", &a->_ns2__GetResults::sampleType, "ns10:ESampleTypes"))
				{	soap_flag_sampleType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetResults, SOAP_TYPE__ns2__GetResults, sizeof(_ns2__GetResults), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetResults * SOAP_FMAC2 soap_instantiate__ns2__GetResults(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetResults(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetResults *p;
	size_t k = sizeof(_ns2__GetResults);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetResults, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetResults);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetResults, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetResults location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetResults::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetResults(soap, tag ? tag : "ns2:GetResults", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetResults::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetResults(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetResults * SOAP_FMAC4 soap_get__ns2__GetResults(struct soap *soap, _ns2__GetResults *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__SetSystemConfigurationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns2__SetSystemConfigurationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__SetSystemConfigurationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__SetSystemConfigurationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__SetSystemConfigurationsResponse(struct soap *soap, const char *tag, int id, const _ns2__SetSystemConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__SetSystemConfigurationsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__SetSystemConfigurationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__SetSystemConfigurationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__SetSystemConfigurationsResponse * SOAP_FMAC4 soap_in__ns2__SetSystemConfigurationsResponse(struct soap *soap, const char *tag, _ns2__SetSystemConfigurationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__SetSystemConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__SetSystemConfigurationsResponse, sizeof(_ns2__SetSystemConfigurationsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__SetSystemConfigurationsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__SetSystemConfigurationsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__SetSystemConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__SetSystemConfigurationsResponse, SOAP_TYPE__ns2__SetSystemConfigurationsResponse, sizeof(_ns2__SetSystemConfigurationsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__SetSystemConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns2__SetSystemConfigurationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__SetSystemConfigurationsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__SetSystemConfigurationsResponse *p;
	size_t k = sizeof(_ns2__SetSystemConfigurationsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__SetSystemConfigurationsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__SetSystemConfigurationsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__SetSystemConfigurationsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__SetSystemConfigurationsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__SetSystemConfigurationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__SetSystemConfigurationsResponse(soap, tag ? tag : "ns2:SetSystemConfigurationsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__SetSystemConfigurationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__SetSystemConfigurationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__SetSystemConfigurationsResponse * SOAP_FMAC4 soap_get__ns2__SetSystemConfigurationsResponse(struct soap *soap, _ns2__SetSystemConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__SetSystemConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__SetSystemConfigurations::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__SetSystemConfigurations::systemConfigurations = NULL;
}

void _ns2__SetSystemConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__SystemConfigurations(soap, &this->_ns2__SetSystemConfigurations::systemConfigurations);
#endif
}

int _ns2__SetSystemConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__SetSystemConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__SetSystemConfigurations(struct soap *soap, const char *tag, int id, const _ns2__SetSystemConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__SetSystemConfigurations), type))
		return soap->error;
	if (soap_out_PointerTons5__SystemConfigurations(soap, "ns2:systemConfigurations", -1, &a->_ns2__SetSystemConfigurations::systemConfigurations, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__SetSystemConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__SetSystemConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__SetSystemConfigurations * SOAP_FMAC4 soap_in__ns2__SetSystemConfigurations(struct soap *soap, const char *tag, _ns2__SetSystemConfigurations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__SetSystemConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__SetSystemConfigurations, sizeof(_ns2__SetSystemConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__SetSystemConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__SetSystemConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_systemConfigurations1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_systemConfigurations1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__SystemConfigurations(soap, "ns2:systemConfigurations", &a->_ns2__SetSystemConfigurations::systemConfigurations, "ns5:SystemConfigurations"))
				{	soap_flag_systemConfigurations1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__SetSystemConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__SetSystemConfigurations, SOAP_TYPE__ns2__SetSystemConfigurations, sizeof(_ns2__SetSystemConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__SetSystemConfigurations * SOAP_FMAC2 soap_instantiate__ns2__SetSystemConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__SetSystemConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__SetSystemConfigurations *p;
	size_t k = sizeof(_ns2__SetSystemConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__SetSystemConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__SetSystemConfigurations);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__SetSystemConfigurations, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__SetSystemConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__SetSystemConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__SetSystemConfigurations(soap, tag ? tag : "ns2:SetSystemConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__SetSystemConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__SetSystemConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__SetSystemConfigurations * SOAP_FMAC4 soap_get__ns2__SetSystemConfigurations(struct soap *soap, _ns2__SetSystemConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__SetSystemConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetSystemConfigurationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetSystemConfigurationsResponse::GetSystemConfigurationsResult = NULL;
}

void _ns2__GetSystemConfigurationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__SystemConfigurations(soap, &this->_ns2__GetSystemConfigurationsResponse::GetSystemConfigurationsResult);
#endif
}

int _ns2__GetSystemConfigurationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetSystemConfigurationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetSystemConfigurationsResponse(struct soap *soap, const char *tag, int id, const _ns2__GetSystemConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetSystemConfigurationsResponse), type))
		return soap->error;
	if (a->GetSystemConfigurationsResult)
		soap_element_result(soap, "ns2:GetSystemConfigurationsResult");
	if (soap_out_PointerTons5__SystemConfigurations(soap, "ns2:GetSystemConfigurationsResult", -1, &a->_ns2__GetSystemConfigurationsResponse::GetSystemConfigurationsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetSystemConfigurationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetSystemConfigurationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetSystemConfigurationsResponse * SOAP_FMAC4 soap_in__ns2__GetSystemConfigurationsResponse(struct soap *soap, const char *tag, _ns2__GetSystemConfigurationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetSystemConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetSystemConfigurationsResponse, sizeof(_ns2__GetSystemConfigurationsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetSystemConfigurationsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetSystemConfigurationsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetSystemConfigurationsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetSystemConfigurationsResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__SystemConfigurations(soap, "ns2:GetSystemConfigurationsResult", &a->_ns2__GetSystemConfigurationsResponse::GetSystemConfigurationsResult, "ns5:SystemConfigurations"))
				{	soap_flag_GetSystemConfigurationsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns2:GetSystemConfigurationsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetSystemConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetSystemConfigurationsResponse, SOAP_TYPE__ns2__GetSystemConfigurationsResponse, sizeof(_ns2__GetSystemConfigurationsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetSystemConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns2__GetSystemConfigurationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetSystemConfigurationsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetSystemConfigurationsResponse *p;
	size_t k = sizeof(_ns2__GetSystemConfigurationsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetSystemConfigurationsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetSystemConfigurationsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetSystemConfigurationsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetSystemConfigurationsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetSystemConfigurationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetSystemConfigurationsResponse(soap, tag ? tag : "ns2:GetSystemConfigurationsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetSystemConfigurationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetSystemConfigurationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetSystemConfigurationsResponse * SOAP_FMAC4 soap_get__ns2__GetSystemConfigurationsResponse(struct soap *soap, _ns2__GetSystemConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetSystemConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetSystemConfigurations::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns2__GetSystemConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__GetSystemConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetSystemConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetSystemConfigurations(struct soap *soap, const char *tag, int id, const _ns2__GetSystemConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetSystemConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetSystemConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetSystemConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetSystemConfigurations * SOAP_FMAC4 soap_in__ns2__GetSystemConfigurations(struct soap *soap, const char *tag, _ns2__GetSystemConfigurations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetSystemConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetSystemConfigurations, sizeof(_ns2__GetSystemConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetSystemConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetSystemConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetSystemConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetSystemConfigurations, SOAP_TYPE__ns2__GetSystemConfigurations, sizeof(_ns2__GetSystemConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetSystemConfigurations * SOAP_FMAC2 soap_instantiate__ns2__GetSystemConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetSystemConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetSystemConfigurations *p;
	size_t k = sizeof(_ns2__GetSystemConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetSystemConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetSystemConfigurations);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetSystemConfigurations, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetSystemConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetSystemConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetSystemConfigurations(soap, tag ? tag : "ns2:GetSystemConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetSystemConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetSystemConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetSystemConfigurations * SOAP_FMAC4 soap_get__ns2__GetSystemConfigurations(struct soap *soap, _ns2__GetSystemConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetSystemConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__SetIgnoreClearingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns2__SetIgnoreClearingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__SetIgnoreClearingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__SetIgnoreClearingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__SetIgnoreClearingResponse(struct soap *soap, const char *tag, int id, const _ns2__SetIgnoreClearingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__SetIgnoreClearingResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__SetIgnoreClearingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__SetIgnoreClearingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__SetIgnoreClearingResponse * SOAP_FMAC4 soap_in__ns2__SetIgnoreClearingResponse(struct soap *soap, const char *tag, _ns2__SetIgnoreClearingResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__SetIgnoreClearingResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__SetIgnoreClearingResponse, sizeof(_ns2__SetIgnoreClearingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__SetIgnoreClearingResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__SetIgnoreClearingResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__SetIgnoreClearingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__SetIgnoreClearingResponse, SOAP_TYPE__ns2__SetIgnoreClearingResponse, sizeof(_ns2__SetIgnoreClearingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__SetIgnoreClearingResponse * SOAP_FMAC2 soap_instantiate__ns2__SetIgnoreClearingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__SetIgnoreClearingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__SetIgnoreClearingResponse *p;
	size_t k = sizeof(_ns2__SetIgnoreClearingResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__SetIgnoreClearingResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__SetIgnoreClearingResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__SetIgnoreClearingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__SetIgnoreClearingResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__SetIgnoreClearingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__SetIgnoreClearingResponse(soap, tag ? tag : "ns2:SetIgnoreClearingResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__SetIgnoreClearingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__SetIgnoreClearingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__SetIgnoreClearingResponse * SOAP_FMAC4 soap_get__ns2__SetIgnoreClearingResponse(struct soap *soap, _ns2__SetIgnoreClearingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__SetIgnoreClearingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__SetIgnoreClearing::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__SetIgnoreClearing::ignoreClearing = NULL;
}

void _ns2__SetIgnoreClearing::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->_ns2__SetIgnoreClearing::ignoreClearing);
#endif
}

int _ns2__SetIgnoreClearing::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__SetIgnoreClearing(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__SetIgnoreClearing(struct soap *soap, const char *tag, int id, const _ns2__SetIgnoreClearing *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__SetIgnoreClearing), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns2:ignoreClearing", -1, &a->_ns2__SetIgnoreClearing::ignoreClearing, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__SetIgnoreClearing::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__SetIgnoreClearing(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__SetIgnoreClearing * SOAP_FMAC4 soap_in__ns2__SetIgnoreClearing(struct soap *soap, const char *tag, _ns2__SetIgnoreClearing *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__SetIgnoreClearing*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__SetIgnoreClearing, sizeof(_ns2__SetIgnoreClearing), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__SetIgnoreClearing)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__SetIgnoreClearing *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ignoreClearing1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ignoreClearing1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns2:ignoreClearing", &a->_ns2__SetIgnoreClearing::ignoreClearing, "xsd:boolean"))
				{	soap_flag_ignoreClearing1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__SetIgnoreClearing *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__SetIgnoreClearing, SOAP_TYPE__ns2__SetIgnoreClearing, sizeof(_ns2__SetIgnoreClearing), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__SetIgnoreClearing * SOAP_FMAC2 soap_instantiate__ns2__SetIgnoreClearing(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__SetIgnoreClearing(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__SetIgnoreClearing *p;
	size_t k = sizeof(_ns2__SetIgnoreClearing);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__SetIgnoreClearing, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__SetIgnoreClearing);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__SetIgnoreClearing, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__SetIgnoreClearing location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__SetIgnoreClearing::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__SetIgnoreClearing(soap, tag ? tag : "ns2:SetIgnoreClearing", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__SetIgnoreClearing::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__SetIgnoreClearing(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__SetIgnoreClearing * SOAP_FMAC4 soap_get__ns2__SetIgnoreClearing(struct soap *soap, _ns2__SetIgnoreClearing *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__SetIgnoreClearing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetProcessingInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetProcessingInfoResponse::GetProcessingInfoResult = NULL;
}

void _ns2__GetProcessingInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__ProcessingInfo(soap, &this->_ns2__GetProcessingInfoResponse::GetProcessingInfoResult);
#endif
}

int _ns2__GetProcessingInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetProcessingInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetProcessingInfoResponse(struct soap *soap, const char *tag, int id, const _ns2__GetProcessingInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetProcessingInfoResponse), type))
		return soap->error;
	if (a->GetProcessingInfoResult)
		soap_element_result(soap, "ns2:GetProcessingInfoResult");
	if (soap_out_PointerTons3__ProcessingInfo(soap, "ns2:GetProcessingInfoResult", -1, &a->_ns2__GetProcessingInfoResponse::GetProcessingInfoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetProcessingInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetProcessingInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetProcessingInfoResponse * SOAP_FMAC4 soap_in__ns2__GetProcessingInfoResponse(struct soap *soap, const char *tag, _ns2__GetProcessingInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetProcessingInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetProcessingInfoResponse, sizeof(_ns2__GetProcessingInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetProcessingInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetProcessingInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetProcessingInfoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetProcessingInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ProcessingInfo(soap, "ns2:GetProcessingInfoResult", &a->_ns2__GetProcessingInfoResponse::GetProcessingInfoResult, "ns3:ProcessingInfo"))
				{	soap_flag_GetProcessingInfoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns2:GetProcessingInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetProcessingInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetProcessingInfoResponse, SOAP_TYPE__ns2__GetProcessingInfoResponse, sizeof(_ns2__GetProcessingInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetProcessingInfoResponse * SOAP_FMAC2 soap_instantiate__ns2__GetProcessingInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetProcessingInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetProcessingInfoResponse *p;
	size_t k = sizeof(_ns2__GetProcessingInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetProcessingInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetProcessingInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetProcessingInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetProcessingInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetProcessingInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetProcessingInfoResponse(soap, tag ? tag : "ns2:GetProcessingInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetProcessingInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetProcessingInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetProcessingInfoResponse * SOAP_FMAC4 soap_get__ns2__GetProcessingInfoResponse(struct soap *soap, _ns2__GetProcessingInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetProcessingInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__GetProcessingInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns2__GetProcessingInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__GetProcessingInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetProcessingInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetProcessingInfo(struct soap *soap, const char *tag, int id, const _ns2__GetProcessingInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetProcessingInfo), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetProcessingInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__GetProcessingInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetProcessingInfo * SOAP_FMAC4 soap_in__ns2__GetProcessingInfo(struct soap *soap, const char *tag, _ns2__GetProcessingInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetProcessingInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetProcessingInfo, sizeof(_ns2__GetProcessingInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__GetProcessingInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__GetProcessingInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetProcessingInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetProcessingInfo, SOAP_TYPE__ns2__GetProcessingInfo, sizeof(_ns2__GetProcessingInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__GetProcessingInfo * SOAP_FMAC2 soap_instantiate__ns2__GetProcessingInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetProcessingInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__GetProcessingInfo *p;
	size_t k = sizeof(_ns2__GetProcessingInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__GetProcessingInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__GetProcessingInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__GetProcessingInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__GetProcessingInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__GetProcessingInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__GetProcessingInfo(soap, tag ? tag : "ns2:GetProcessingInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetProcessingInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetProcessingInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetProcessingInfo * SOAP_FMAC4 soap_get__ns2__GetProcessingInfo(struct soap *soap, _ns2__GetProcessingInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetProcessingInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__AbortAnalyzingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns2__AbortAnalyzingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__AbortAnalyzingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__AbortAnalyzingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__AbortAnalyzingResponse(struct soap *soap, const char *tag, int id, const _ns2__AbortAnalyzingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__AbortAnalyzingResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__AbortAnalyzingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__AbortAnalyzingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__AbortAnalyzingResponse * SOAP_FMAC4 soap_in__ns2__AbortAnalyzingResponse(struct soap *soap, const char *tag, _ns2__AbortAnalyzingResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__AbortAnalyzingResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__AbortAnalyzingResponse, sizeof(_ns2__AbortAnalyzingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__AbortAnalyzingResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__AbortAnalyzingResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__AbortAnalyzingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__AbortAnalyzingResponse, SOAP_TYPE__ns2__AbortAnalyzingResponse, sizeof(_ns2__AbortAnalyzingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__AbortAnalyzingResponse * SOAP_FMAC2 soap_instantiate__ns2__AbortAnalyzingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__AbortAnalyzingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__AbortAnalyzingResponse *p;
	size_t k = sizeof(_ns2__AbortAnalyzingResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__AbortAnalyzingResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__AbortAnalyzingResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__AbortAnalyzingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__AbortAnalyzingResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__AbortAnalyzingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__AbortAnalyzingResponse(soap, tag ? tag : "ns2:AbortAnalyzingResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__AbortAnalyzingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__AbortAnalyzingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__AbortAnalyzingResponse * SOAP_FMAC4 soap_get__ns2__AbortAnalyzingResponse(struct soap *soap, _ns2__AbortAnalyzingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__AbortAnalyzingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__AbortAnalyzing::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns2__AbortAnalyzing::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__AbortAnalyzing::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__AbortAnalyzing(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__AbortAnalyzing(struct soap *soap, const char *tag, int id, const _ns2__AbortAnalyzing *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__AbortAnalyzing), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__AbortAnalyzing::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__AbortAnalyzing(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__AbortAnalyzing * SOAP_FMAC4 soap_in__ns2__AbortAnalyzing(struct soap *soap, const char *tag, _ns2__AbortAnalyzing *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__AbortAnalyzing*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__AbortAnalyzing, sizeof(_ns2__AbortAnalyzing), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__AbortAnalyzing)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__AbortAnalyzing *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__AbortAnalyzing *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__AbortAnalyzing, SOAP_TYPE__ns2__AbortAnalyzing, sizeof(_ns2__AbortAnalyzing), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__AbortAnalyzing * SOAP_FMAC2 soap_instantiate__ns2__AbortAnalyzing(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__AbortAnalyzing(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__AbortAnalyzing *p;
	size_t k = sizeof(_ns2__AbortAnalyzing);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__AbortAnalyzing, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__AbortAnalyzing);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__AbortAnalyzing, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__AbortAnalyzing location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__AbortAnalyzing::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__AbortAnalyzing(soap, tag ? tag : "ns2:AbortAnalyzing", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__AbortAnalyzing::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__AbortAnalyzing(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__AbortAnalyzing * SOAP_FMAC4 soap_get__ns2__AbortAnalyzing(struct soap *soap, _ns2__AbortAnalyzing *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__AbortAnalyzing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__StopAnalyzingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns2__StopAnalyzingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__StopAnalyzingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__StopAnalyzingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__StopAnalyzingResponse(struct soap *soap, const char *tag, int id, const _ns2__StopAnalyzingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__StopAnalyzingResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__StopAnalyzingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__StopAnalyzingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__StopAnalyzingResponse * SOAP_FMAC4 soap_in__ns2__StopAnalyzingResponse(struct soap *soap, const char *tag, _ns2__StopAnalyzingResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__StopAnalyzingResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__StopAnalyzingResponse, sizeof(_ns2__StopAnalyzingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__StopAnalyzingResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__StopAnalyzingResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__StopAnalyzingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__StopAnalyzingResponse, SOAP_TYPE__ns2__StopAnalyzingResponse, sizeof(_ns2__StopAnalyzingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__StopAnalyzingResponse * SOAP_FMAC2 soap_instantiate__ns2__StopAnalyzingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__StopAnalyzingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__StopAnalyzingResponse *p;
	size_t k = sizeof(_ns2__StopAnalyzingResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__StopAnalyzingResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__StopAnalyzingResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__StopAnalyzingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__StopAnalyzingResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__StopAnalyzingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__StopAnalyzingResponse(soap, tag ? tag : "ns2:StopAnalyzingResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__StopAnalyzingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__StopAnalyzingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__StopAnalyzingResponse * SOAP_FMAC4 soap_get__ns2__StopAnalyzingResponse(struct soap *soap, _ns2__StopAnalyzingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__StopAnalyzingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__StopAnalyzing::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns2__StopAnalyzing::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__StopAnalyzing::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__StopAnalyzing(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__StopAnalyzing(struct soap *soap, const char *tag, int id, const _ns2__StopAnalyzing *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__StopAnalyzing), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__StopAnalyzing::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__StopAnalyzing(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__StopAnalyzing * SOAP_FMAC4 soap_in__ns2__StopAnalyzing(struct soap *soap, const char *tag, _ns2__StopAnalyzing *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__StopAnalyzing*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__StopAnalyzing, sizeof(_ns2__StopAnalyzing), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__StopAnalyzing)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__StopAnalyzing *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__StopAnalyzing *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__StopAnalyzing, SOAP_TYPE__ns2__StopAnalyzing, sizeof(_ns2__StopAnalyzing), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__StopAnalyzing * SOAP_FMAC2 soap_instantiate__ns2__StopAnalyzing(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__StopAnalyzing(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__StopAnalyzing *p;
	size_t k = sizeof(_ns2__StopAnalyzing);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__StopAnalyzing, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__StopAnalyzing);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__StopAnalyzing, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__StopAnalyzing location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__StopAnalyzing::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__StopAnalyzing(soap, tag ? tag : "ns2:StopAnalyzing", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__StopAnalyzing::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__StopAnalyzing(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__StopAnalyzing * SOAP_FMAC4 soap_get__ns2__StopAnalyzing(struct soap *soap, _ns2__StopAnalyzing *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__StopAnalyzing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__StartOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns2__StartOperationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__StartOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__StartOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__StartOperationResponse(struct soap *soap, const char *tag, int id, const _ns2__StartOperationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__StartOperationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__StartOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__StartOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__StartOperationResponse * SOAP_FMAC4 soap_in__ns2__StartOperationResponse(struct soap *soap, const char *tag, _ns2__StartOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__StartOperationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__StartOperationResponse, sizeof(_ns2__StartOperationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__StartOperationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__StartOperationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__StartOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__StartOperationResponse, SOAP_TYPE__ns2__StartOperationResponse, sizeof(_ns2__StartOperationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__StartOperationResponse * SOAP_FMAC2 soap_instantiate__ns2__StartOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__StartOperationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__StartOperationResponse *p;
	size_t k = sizeof(_ns2__StartOperationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__StartOperationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__StartOperationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__StartOperationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__StartOperationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__StartOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__StartOperationResponse(soap, tag ? tag : "ns2:StartOperationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__StartOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__StartOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__StartOperationResponse * SOAP_FMAC4 soap_get__ns2__StartOperationResponse(struct soap *soap, _ns2__StartOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__StartOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__StartOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__StartOperation::operationName = NULL;
}

void _ns2__StartOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns2__StartOperation::operationName);
#endif
}

int _ns2__StartOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__StartOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__StartOperation(struct soap *soap, const char *tag, int id, const _ns2__StartOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__StartOperation), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:operationName", -1, &a->_ns2__StartOperation::operationName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__StartOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__StartOperation(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__StartOperation * SOAP_FMAC4 soap_in__ns2__StartOperation(struct soap *soap, const char *tag, _ns2__StartOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__StartOperation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__StartOperation, sizeof(_ns2__StartOperation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__StartOperation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__StartOperation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_operationName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_operationName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns2:operationName", &a->_ns2__StartOperation::operationName, "xsd:string"))
				{	soap_flag_operationName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__StartOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__StartOperation, SOAP_TYPE__ns2__StartOperation, sizeof(_ns2__StartOperation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__StartOperation * SOAP_FMAC2 soap_instantiate__ns2__StartOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__StartOperation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__StartOperation *p;
	size_t k = sizeof(_ns2__StartOperation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__StartOperation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__StartOperation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__StartOperation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__StartOperation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__StartOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__StartOperation(soap, tag ? tag : "ns2:StartOperation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__StartOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__StartOperation(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__StartOperation * SOAP_FMAC4 soap_get__ns2__StartOperation(struct soap *soap, _ns2__StartOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__StartOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__StartAutoPlanResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns2__StartAutoPlanResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__StartAutoPlanResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__StartAutoPlanResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__StartAutoPlanResponse(struct soap *soap, const char *tag, int id, const _ns2__StartAutoPlanResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__StartAutoPlanResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__StartAutoPlanResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__StartAutoPlanResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__StartAutoPlanResponse * SOAP_FMAC4 soap_in__ns2__StartAutoPlanResponse(struct soap *soap, const char *tag, _ns2__StartAutoPlanResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__StartAutoPlanResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__StartAutoPlanResponse, sizeof(_ns2__StartAutoPlanResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__StartAutoPlanResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__StartAutoPlanResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__StartAutoPlanResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__StartAutoPlanResponse, SOAP_TYPE__ns2__StartAutoPlanResponse, sizeof(_ns2__StartAutoPlanResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__StartAutoPlanResponse * SOAP_FMAC2 soap_instantiate__ns2__StartAutoPlanResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__StartAutoPlanResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__StartAutoPlanResponse *p;
	size_t k = sizeof(_ns2__StartAutoPlanResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__StartAutoPlanResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__StartAutoPlanResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__StartAutoPlanResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__StartAutoPlanResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__StartAutoPlanResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__StartAutoPlanResponse(soap, tag ? tag : "ns2:StartAutoPlanResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__StartAutoPlanResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__StartAutoPlanResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__StartAutoPlanResponse * SOAP_FMAC4 soap_get__ns2__StartAutoPlanResponse(struct soap *soap, _ns2__StartAutoPlanResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__StartAutoPlanResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__StartAutoPlan::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns2__StartAutoPlan::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__StartAutoPlan::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__StartAutoPlan(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__StartAutoPlan(struct soap *soap, const char *tag, int id, const _ns2__StartAutoPlan *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__StartAutoPlan), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__StartAutoPlan::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns2__StartAutoPlan(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__StartAutoPlan * SOAP_FMAC4 soap_in__ns2__StartAutoPlan(struct soap *soap, const char *tag, _ns2__StartAutoPlan *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__StartAutoPlan*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__StartAutoPlan, sizeof(_ns2__StartAutoPlan), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__StartAutoPlan)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__StartAutoPlan *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__StartAutoPlan *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__StartAutoPlan, SOAP_TYPE__ns2__StartAutoPlan, sizeof(_ns2__StartAutoPlan), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__StartAutoPlan * SOAP_FMAC2 soap_instantiate__ns2__StartAutoPlan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__StartAutoPlan(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__StartAutoPlan *p;
	size_t k = sizeof(_ns2__StartAutoPlan);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns2__StartAutoPlan, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns2__StartAutoPlan);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns2__StartAutoPlan, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__StartAutoPlan location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns2__StartAutoPlan::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__StartAutoPlan(soap, tag ? tag : "ns2:StartAutoPlan", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__StartAutoPlan::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__StartAutoPlan(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__StartAutoPlan * SOAP_FMAC4 soap_get__ns2__StartAutoPlan(struct soap *soap, _ns2__StartAutoPlan *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__StartAutoPlan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?(\\d+|\\d*\\.\\d*)")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__decimal, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->chan__ChannelInstance = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa5__MessageID(soap, (char*const*)&a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, (char*const*)&a->wsa5__To);
	soap_serialize__wsa5__Action(soap, (char*const*)&a->wsa5__Action);
	soap_serialize_PointerTochan__ChannelInstanceType(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, (char*const*)&a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, (char*const*)&a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, (char*const*)&a->wsa5__Action, ""))
		return soap->error;
	if (soap_out_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_chan__ChannelInstance = 1;
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", (char**)&a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__To(soap, "wsa5:To", (char**)&a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__Action(soap, "wsa5:Action", (char**)&a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			}
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "chan:ChannelInstanceType"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->__item);
	a->wsa5__IsReferenceParameter = (enum _wsa5__IsReferenceParameter)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__item, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_chan__ChannelInstanceType(struct soap *soap, const char *tag, int id, const struct chan__ChannelInstanceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (a->wsa5__IsReferenceParameter != (enum _wsa5__IsReferenceParameter)0)
	{	soap_set_attr(soap, "wsa5:IsReferenceParameter", soap__wsa5__IsReferenceParameter2s(soap, a->wsa5__IsReferenceParameter), 1);
	}
	return soap_out_int(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_in_chan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct chan__ChannelInstanceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_chan__ChannelInstanceType(soap, a);
	if (soap_s2_wsa5__IsReferenceParameter(soap, soap_attr_value(soap, "wsa5:IsReferenceParameter", 5, 0), &a->wsa5__IsReferenceParameter))
		return NULL;
	if (!soap_in_int(soap, tag, &a->__item, "chan:ChannelInstanceType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_chan__ChannelInstanceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct chan__ChannelInstanceType *p;
	size_t k = sizeof(struct chan__ChannelInstanceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_chan__ChannelInstanceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct chan__ChannelInstanceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct chan__ChannelInstanceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct chan__ChannelInstanceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a, const char *tag, const char *type)
{
	if (soap_out_chan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_get_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_chan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemAction(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemAction(soap, tag ? tag : "wsa5:ProblemAction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__FaultTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__From(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReplyTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RelatesTo(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Metadata(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Metadata(soap, tag ? tag : "wsa5:Metadata", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReferenceParameters(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReferenceParameters(soap, tag ? tag : "wsa5:ReferenceParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__EndpointReference(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__EndpointReference(soap, tag ? tag : "wsa5:EndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Action);
	soap_serialize_string(soap, (char*const*)&a->SoapAction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, (char*const*)&a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, (char*const*)&a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (struct wsa5__ProblemActionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Action", (char**)&a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:SoapAction", (char**)&a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ProblemActionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__ProblemActionType *p;
	size_t k = sizeof(struct wsa5__ProblemActionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__ProblemActionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__ProblemActionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__ProblemActionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__ProblemActionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ProblemActionType(soap, tag ? tag : "wsa5:ProblemActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_wsa5__RelationshipTypeOpenEnum2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2wsa5__RelationshipTypeOpenEnum(soap, soap_attr_value(soap, "RelationshipType", 1, 0), &a->RelationshipType))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__RelatesToType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__RelatesToType *p;
	size_t k = sizeof(struct wsa5__RelatesToType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__RelatesToType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__RelatesToType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__RelatesToType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__RelatesToType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelatesToType(soap, tag ? tag : "wsa5:RelatesToType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (struct wsa5__MetadataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__MetadataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__MetadataType *p;
	size_t k = sizeof(struct wsa5__MetadataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__MetadataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__MetadataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__MetadataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__MetadataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->chan__ChannelInstance = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	size_t soap_flag_chan__ChannelInstance = 1;
	struct soap_blist *soap_blist___any = NULL;
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (struct wsa5__ReferenceParametersType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "xsd:int"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ReferenceParametersType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__ReferenceParametersType *p;
	size_t k = sizeof(struct wsa5__ReferenceParametersType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__ReferenceParametersType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__ReferenceParametersType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__ReferenceParametersType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__ReferenceParametersType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "wsa5:Address"))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsa5:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (struct wsa5__EndpointReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Address", (char**)&a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__EndpointReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__EndpointReferenceType *p;
	size_t k = sizeof(struct wsa5__EndpointReferenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__EndpointReferenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__EndpointReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__EndpointReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__EndpointReferenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetEventsSinceId(struct soap *soap, struct __tempuri__GetEventsSinceId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetEventsSinceId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetEventsSinceId(struct soap *soap, const struct __tempuri__GetEventsSinceId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__GetEventsSinceId(soap, &a->ns2__GetEventsSinceId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetEventsSinceId(struct soap *soap, const char *tag, int id, const struct __tempuri__GetEventsSinceId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns2__GetEventsSinceId(soap, "ns2:GetEventsSinceId", -1, &a->ns2__GetEventsSinceId, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetEventsSinceId * SOAP_FMAC4 soap_in___tempuri__GetEventsSinceId(struct soap *soap, const char *tag, struct __tempuri__GetEventsSinceId *a, const char *type)
{
	size_t soap_flag_ns2__GetEventsSinceId = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetEventsSinceId*)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetEventsSinceId, sizeof(struct __tempuri__GetEventsSinceId), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetEventsSinceId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetEventsSinceId && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__GetEventsSinceId(soap, "ns2:GetEventsSinceId", &a->ns2__GetEventsSinceId, ""))
				{	soap_flag_ns2__GetEventsSinceId--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetEventsSinceId * SOAP_FMAC2 soap_instantiate___tempuri__GetEventsSinceId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetEventsSinceId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetEventsSinceId *p;
	size_t k = sizeof(struct __tempuri__GetEventsSinceId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetEventsSinceId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetEventsSinceId);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetEventsSinceId, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetEventsSinceId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetEventsSinceId(struct soap *soap, const struct __tempuri__GetEventsSinceId *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetEventsSinceId(soap, tag ? tag : "-tempuri:GetEventsSinceId", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetEventsSinceId * SOAP_FMAC4 soap_get___tempuri__GetEventsSinceId(struct soap *soap, struct __tempuri__GetEventsSinceId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetEventsSinceId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetLastEventId(struct soap *soap, struct __tempuri__GetLastEventId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetLastEventId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetLastEventId(struct soap *soap, const struct __tempuri__GetLastEventId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__GetLastEventId(soap, &a->ns2__GetLastEventId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetLastEventId(struct soap *soap, const char *tag, int id, const struct __tempuri__GetLastEventId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns2__GetLastEventId(soap, "ns2:GetLastEventId", -1, &a->ns2__GetLastEventId, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetLastEventId * SOAP_FMAC4 soap_in___tempuri__GetLastEventId(struct soap *soap, const char *tag, struct __tempuri__GetLastEventId *a, const char *type)
{
	size_t soap_flag_ns2__GetLastEventId = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetLastEventId*)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetLastEventId, sizeof(struct __tempuri__GetLastEventId), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetLastEventId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetLastEventId && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__GetLastEventId(soap, "ns2:GetLastEventId", &a->ns2__GetLastEventId, ""))
				{	soap_flag_ns2__GetLastEventId--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetLastEventId * SOAP_FMAC2 soap_instantiate___tempuri__GetLastEventId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetLastEventId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetLastEventId *p;
	size_t k = sizeof(struct __tempuri__GetLastEventId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetLastEventId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetLastEventId);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetLastEventId, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetLastEventId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetLastEventId(struct soap *soap, const struct __tempuri__GetLastEventId *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetLastEventId(soap, tag ? tag : "-tempuri:GetLastEventId", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetLastEventId * SOAP_FMAC4 soap_get___tempuri__GetLastEventId(struct soap *soap, struct __tempuri__GetLastEventId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetLastEventId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetEvents(struct soap *soap, struct __tempuri__GetEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetEvents = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetEvents(struct soap *soap, const struct __tempuri__GetEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__GetEvents(soap, &a->ns2__GetEvents);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetEvents(struct soap *soap, const char *tag, int id, const struct __tempuri__GetEvents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns2__GetEvents(soap, "ns2:GetEvents", -1, &a->ns2__GetEvents, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetEvents * SOAP_FMAC4 soap_in___tempuri__GetEvents(struct soap *soap, const char *tag, struct __tempuri__GetEvents *a, const char *type)
{
	size_t soap_flag_ns2__GetEvents = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetEvents*)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetEvents, sizeof(struct __tempuri__GetEvents), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetEvents(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetEvents && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__GetEvents(soap, "ns2:GetEvents", &a->ns2__GetEvents, ""))
				{	soap_flag_ns2__GetEvents--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetEvents * SOAP_FMAC2 soap_instantiate___tempuri__GetEvents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetEvents(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetEvents *p;
	size_t k = sizeof(struct __tempuri__GetEvents);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetEvents, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetEvents);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetEvents, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetEvents location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetEvents(struct soap *soap, const struct __tempuri__GetEvents *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetEvents(soap, tag ? tag : "-tempuri:GetEvents", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetEvents * SOAP_FMAC4 soap_get___tempuri__GetEvents(struct soap *soap, struct __tempuri__GetEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetResultsSinceId(struct soap *soap, struct __tempuri__GetResultsSinceId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetResultsSinceId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetResultsSinceId(struct soap *soap, const struct __tempuri__GetResultsSinceId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__GetResultsSinceId(soap, &a->ns2__GetResultsSinceId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetResultsSinceId(struct soap *soap, const char *tag, int id, const struct __tempuri__GetResultsSinceId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns2__GetResultsSinceId(soap, "ns2:GetResultsSinceId", -1, &a->ns2__GetResultsSinceId, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetResultsSinceId * SOAP_FMAC4 soap_in___tempuri__GetResultsSinceId(struct soap *soap, const char *tag, struct __tempuri__GetResultsSinceId *a, const char *type)
{
	size_t soap_flag_ns2__GetResultsSinceId = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetResultsSinceId*)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetResultsSinceId, sizeof(struct __tempuri__GetResultsSinceId), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetResultsSinceId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetResultsSinceId && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__GetResultsSinceId(soap, "ns2:GetResultsSinceId", &a->ns2__GetResultsSinceId, ""))
				{	soap_flag_ns2__GetResultsSinceId--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetResultsSinceId * SOAP_FMAC2 soap_instantiate___tempuri__GetResultsSinceId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetResultsSinceId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetResultsSinceId *p;
	size_t k = sizeof(struct __tempuri__GetResultsSinceId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetResultsSinceId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetResultsSinceId);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetResultsSinceId, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetResultsSinceId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetResultsSinceId(struct soap *soap, const struct __tempuri__GetResultsSinceId *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetResultsSinceId(soap, tag ? tag : "-tempuri:GetResultsSinceId", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetResultsSinceId * SOAP_FMAC4 soap_get___tempuri__GetResultsSinceId(struct soap *soap, struct __tempuri__GetResultsSinceId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetResultsSinceId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetLastResultId(struct soap *soap, struct __tempuri__GetLastResultId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetLastResultId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetLastResultId(struct soap *soap, const struct __tempuri__GetLastResultId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__GetLastResultId(soap, &a->ns2__GetLastResultId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetLastResultId(struct soap *soap, const char *tag, int id, const struct __tempuri__GetLastResultId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns2__GetLastResultId(soap, "ns2:GetLastResultId", -1, &a->ns2__GetLastResultId, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetLastResultId * SOAP_FMAC4 soap_in___tempuri__GetLastResultId(struct soap *soap, const char *tag, struct __tempuri__GetLastResultId *a, const char *type)
{
	size_t soap_flag_ns2__GetLastResultId = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetLastResultId*)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetLastResultId, sizeof(struct __tempuri__GetLastResultId), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetLastResultId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetLastResultId && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__GetLastResultId(soap, "ns2:GetLastResultId", &a->ns2__GetLastResultId, ""))
				{	soap_flag_ns2__GetLastResultId--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetLastResultId * SOAP_FMAC2 soap_instantiate___tempuri__GetLastResultId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetLastResultId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetLastResultId *p;
	size_t k = sizeof(struct __tempuri__GetLastResultId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetLastResultId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetLastResultId);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetLastResultId, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetLastResultId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetLastResultId(struct soap *soap, const struct __tempuri__GetLastResultId *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetLastResultId(soap, tag ? tag : "-tempuri:GetLastResultId", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetLastResultId * SOAP_FMAC4 soap_get___tempuri__GetLastResultId(struct soap *soap, struct __tempuri__GetLastResultId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetLastResultId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetLastResult(struct soap *soap, struct __tempuri__GetLastResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetLastResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetLastResult(struct soap *soap, const struct __tempuri__GetLastResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__GetLastResult(soap, &a->ns2__GetLastResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetLastResult(struct soap *soap, const char *tag, int id, const struct __tempuri__GetLastResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns2__GetLastResult(soap, "ns2:GetLastResult", -1, &a->ns2__GetLastResult, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetLastResult * SOAP_FMAC4 soap_in___tempuri__GetLastResult(struct soap *soap, const char *tag, struct __tempuri__GetLastResult *a, const char *type)
{
	size_t soap_flag_ns2__GetLastResult = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetLastResult*)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetLastResult, sizeof(struct __tempuri__GetLastResult), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetLastResult(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetLastResult && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__GetLastResult(soap, "ns2:GetLastResult", &a->ns2__GetLastResult, ""))
				{	soap_flag_ns2__GetLastResult--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetLastResult * SOAP_FMAC2 soap_instantiate___tempuri__GetLastResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetLastResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetLastResult *p;
	size_t k = sizeof(struct __tempuri__GetLastResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetLastResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetLastResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetLastResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetLastResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetLastResult(struct soap *soap, const struct __tempuri__GetLastResult *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetLastResult(soap, tag ? tag : "-tempuri:GetLastResult", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetLastResult * SOAP_FMAC4 soap_get___tempuri__GetLastResult(struct soap *soap, struct __tempuri__GetLastResult *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetLastResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetResults(struct soap *soap, struct __tempuri__GetResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetResults = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetResults(struct soap *soap, const struct __tempuri__GetResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__GetResults(soap, &a->ns2__GetResults);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetResults(struct soap *soap, const char *tag, int id, const struct __tempuri__GetResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns2__GetResults(soap, "ns2:GetResults", -1, &a->ns2__GetResults, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetResults * SOAP_FMAC4 soap_in___tempuri__GetResults(struct soap *soap, const char *tag, struct __tempuri__GetResults *a, const char *type)
{
	size_t soap_flag_ns2__GetResults = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetResults*)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetResults, sizeof(struct __tempuri__GetResults), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetResults(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetResults && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__GetResults(soap, "ns2:GetResults", &a->ns2__GetResults, ""))
				{	soap_flag_ns2__GetResults--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetResults * SOAP_FMAC2 soap_instantiate___tempuri__GetResults(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetResults(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetResults *p;
	size_t k = sizeof(struct __tempuri__GetResults);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetResults, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetResults);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetResults, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetResults location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetResults(struct soap *soap, const struct __tempuri__GetResults *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetResults(soap, tag ? tag : "-tempuri:GetResults", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetResults * SOAP_FMAC4 soap_get___tempuri__GetResults(struct soap *soap, struct __tempuri__GetResults *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__SetSystemConfigurations(struct soap *soap, struct __tempuri__SetSystemConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__SetSystemConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__SetSystemConfigurations(struct soap *soap, const struct __tempuri__SetSystemConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__SetSystemConfigurations(soap, &a->ns2__SetSystemConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__SetSystemConfigurations(struct soap *soap, const char *tag, int id, const struct __tempuri__SetSystemConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns2__SetSystemConfigurations(soap, "ns2:SetSystemConfigurations", -1, &a->ns2__SetSystemConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__SetSystemConfigurations * SOAP_FMAC4 soap_in___tempuri__SetSystemConfigurations(struct soap *soap, const char *tag, struct __tempuri__SetSystemConfigurations *a, const char *type)
{
	size_t soap_flag_ns2__SetSystemConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__SetSystemConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__SetSystemConfigurations, sizeof(struct __tempuri__SetSystemConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__SetSystemConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__SetSystemConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__SetSystemConfigurations(soap, "ns2:SetSystemConfigurations", &a->ns2__SetSystemConfigurations, ""))
				{	soap_flag_ns2__SetSystemConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__SetSystemConfigurations * SOAP_FMAC2 soap_instantiate___tempuri__SetSystemConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__SetSystemConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__SetSystemConfigurations *p;
	size_t k = sizeof(struct __tempuri__SetSystemConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__SetSystemConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__SetSystemConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__SetSystemConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__SetSystemConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__SetSystemConfigurations(struct soap *soap, const struct __tempuri__SetSystemConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__SetSystemConfigurations(soap, tag ? tag : "-tempuri:SetSystemConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__SetSystemConfigurations * SOAP_FMAC4 soap_get___tempuri__SetSystemConfigurations(struct soap *soap, struct __tempuri__SetSystemConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__SetSystemConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetSystemConfigurations(struct soap *soap, struct __tempuri__GetSystemConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetSystemConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetSystemConfigurations(struct soap *soap, const struct __tempuri__GetSystemConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__GetSystemConfigurations(soap, &a->ns2__GetSystemConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetSystemConfigurations(struct soap *soap, const char *tag, int id, const struct __tempuri__GetSystemConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns2__GetSystemConfigurations(soap, "ns2:GetSystemConfigurations", -1, &a->ns2__GetSystemConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetSystemConfigurations * SOAP_FMAC4 soap_in___tempuri__GetSystemConfigurations(struct soap *soap, const char *tag, struct __tempuri__GetSystemConfigurations *a, const char *type)
{
	size_t soap_flag_ns2__GetSystemConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetSystemConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetSystemConfigurations, sizeof(struct __tempuri__GetSystemConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetSystemConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetSystemConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__GetSystemConfigurations(soap, "ns2:GetSystemConfigurations", &a->ns2__GetSystemConfigurations, ""))
				{	soap_flag_ns2__GetSystemConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetSystemConfigurations * SOAP_FMAC2 soap_instantiate___tempuri__GetSystemConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetSystemConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetSystemConfigurations *p;
	size_t k = sizeof(struct __tempuri__GetSystemConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetSystemConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetSystemConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetSystemConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetSystemConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetSystemConfigurations(struct soap *soap, const struct __tempuri__GetSystemConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetSystemConfigurations(soap, tag ? tag : "-tempuri:GetSystemConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetSystemConfigurations * SOAP_FMAC4 soap_get___tempuri__GetSystemConfigurations(struct soap *soap, struct __tempuri__GetSystemConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetSystemConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__SetIgnoreClearing(struct soap *soap, struct __tempuri__SetIgnoreClearing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__SetIgnoreClearing = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__SetIgnoreClearing(struct soap *soap, const struct __tempuri__SetIgnoreClearing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__SetIgnoreClearing(soap, &a->ns2__SetIgnoreClearing);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__SetIgnoreClearing(struct soap *soap, const char *tag, int id, const struct __tempuri__SetIgnoreClearing *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns2__SetIgnoreClearing(soap, "ns2:SetIgnoreClearing", -1, &a->ns2__SetIgnoreClearing, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__SetIgnoreClearing * SOAP_FMAC4 soap_in___tempuri__SetIgnoreClearing(struct soap *soap, const char *tag, struct __tempuri__SetIgnoreClearing *a, const char *type)
{
	size_t soap_flag_ns2__SetIgnoreClearing = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__SetIgnoreClearing*)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__SetIgnoreClearing, sizeof(struct __tempuri__SetIgnoreClearing), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__SetIgnoreClearing(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__SetIgnoreClearing && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__SetIgnoreClearing(soap, "ns2:SetIgnoreClearing", &a->ns2__SetIgnoreClearing, ""))
				{	soap_flag_ns2__SetIgnoreClearing--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__SetIgnoreClearing * SOAP_FMAC2 soap_instantiate___tempuri__SetIgnoreClearing(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__SetIgnoreClearing(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__SetIgnoreClearing *p;
	size_t k = sizeof(struct __tempuri__SetIgnoreClearing);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__SetIgnoreClearing, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__SetIgnoreClearing);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__SetIgnoreClearing, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__SetIgnoreClearing location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__SetIgnoreClearing(struct soap *soap, const struct __tempuri__SetIgnoreClearing *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__SetIgnoreClearing(soap, tag ? tag : "-tempuri:SetIgnoreClearing", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__SetIgnoreClearing * SOAP_FMAC4 soap_get___tempuri__SetIgnoreClearing(struct soap *soap, struct __tempuri__SetIgnoreClearing *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__SetIgnoreClearing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__GetProcessingInfo(struct soap *soap, struct __tempuri__GetProcessingInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetProcessingInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__GetProcessingInfo(struct soap *soap, const struct __tempuri__GetProcessingInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__GetProcessingInfo(soap, &a->ns2__GetProcessingInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__GetProcessingInfo(struct soap *soap, const char *tag, int id, const struct __tempuri__GetProcessingInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns2__GetProcessingInfo(soap, "ns2:GetProcessingInfo", -1, &a->ns2__GetProcessingInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetProcessingInfo * SOAP_FMAC4 soap_in___tempuri__GetProcessingInfo(struct soap *soap, const char *tag, struct __tempuri__GetProcessingInfo *a, const char *type)
{
	size_t soap_flag_ns2__GetProcessingInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__GetProcessingInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__GetProcessingInfo, sizeof(struct __tempuri__GetProcessingInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__GetProcessingInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetProcessingInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__GetProcessingInfo(soap, "ns2:GetProcessingInfo", &a->ns2__GetProcessingInfo, ""))
				{	soap_flag_ns2__GetProcessingInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__GetProcessingInfo * SOAP_FMAC2 soap_instantiate___tempuri__GetProcessingInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__GetProcessingInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__GetProcessingInfo *p;
	size_t k = sizeof(struct __tempuri__GetProcessingInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__GetProcessingInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__GetProcessingInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__GetProcessingInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__GetProcessingInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__GetProcessingInfo(struct soap *soap, const struct __tempuri__GetProcessingInfo *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__GetProcessingInfo(soap, tag ? tag : "-tempuri:GetProcessingInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__GetProcessingInfo * SOAP_FMAC4 soap_get___tempuri__GetProcessingInfo(struct soap *soap, struct __tempuri__GetProcessingInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__GetProcessingInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AbortAnalyzing(struct soap *soap, struct __tempuri__AbortAnalyzing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__AbortAnalyzing = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AbortAnalyzing(struct soap *soap, const struct __tempuri__AbortAnalyzing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__AbortAnalyzing(soap, &a->ns2__AbortAnalyzing);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AbortAnalyzing(struct soap *soap, const char *tag, int id, const struct __tempuri__AbortAnalyzing *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns2__AbortAnalyzing(soap, "ns2:AbortAnalyzing", -1, &a->ns2__AbortAnalyzing, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AbortAnalyzing * SOAP_FMAC4 soap_in___tempuri__AbortAnalyzing(struct soap *soap, const char *tag, struct __tempuri__AbortAnalyzing *a, const char *type)
{
	size_t soap_flag_ns2__AbortAnalyzing = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AbortAnalyzing*)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AbortAnalyzing, sizeof(struct __tempuri__AbortAnalyzing), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AbortAnalyzing(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__AbortAnalyzing && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__AbortAnalyzing(soap, "ns2:AbortAnalyzing", &a->ns2__AbortAnalyzing, ""))
				{	soap_flag_ns2__AbortAnalyzing--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AbortAnalyzing * SOAP_FMAC2 soap_instantiate___tempuri__AbortAnalyzing(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AbortAnalyzing(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AbortAnalyzing *p;
	size_t k = sizeof(struct __tempuri__AbortAnalyzing);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__AbortAnalyzing, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__AbortAnalyzing);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__AbortAnalyzing, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AbortAnalyzing location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AbortAnalyzing(struct soap *soap, const struct __tempuri__AbortAnalyzing *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AbortAnalyzing(soap, tag ? tag : "-tempuri:AbortAnalyzing", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AbortAnalyzing * SOAP_FMAC4 soap_get___tempuri__AbortAnalyzing(struct soap *soap, struct __tempuri__AbortAnalyzing *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AbortAnalyzing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__StopAnalyzing(struct soap *soap, struct __tempuri__StopAnalyzing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__StopAnalyzing = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__StopAnalyzing(struct soap *soap, const struct __tempuri__StopAnalyzing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__StopAnalyzing(soap, &a->ns2__StopAnalyzing);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__StopAnalyzing(struct soap *soap, const char *tag, int id, const struct __tempuri__StopAnalyzing *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns2__StopAnalyzing(soap, "ns2:StopAnalyzing", -1, &a->ns2__StopAnalyzing, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__StopAnalyzing * SOAP_FMAC4 soap_in___tempuri__StopAnalyzing(struct soap *soap, const char *tag, struct __tempuri__StopAnalyzing *a, const char *type)
{
	size_t soap_flag_ns2__StopAnalyzing = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__StopAnalyzing*)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__StopAnalyzing, sizeof(struct __tempuri__StopAnalyzing), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__StopAnalyzing(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__StopAnalyzing && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__StopAnalyzing(soap, "ns2:StopAnalyzing", &a->ns2__StopAnalyzing, ""))
				{	soap_flag_ns2__StopAnalyzing--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__StopAnalyzing * SOAP_FMAC2 soap_instantiate___tempuri__StopAnalyzing(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__StopAnalyzing(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__StopAnalyzing *p;
	size_t k = sizeof(struct __tempuri__StopAnalyzing);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__StopAnalyzing, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__StopAnalyzing);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__StopAnalyzing, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__StopAnalyzing location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__StopAnalyzing(struct soap *soap, const struct __tempuri__StopAnalyzing *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__StopAnalyzing(soap, tag ? tag : "-tempuri:StopAnalyzing", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__StopAnalyzing * SOAP_FMAC4 soap_get___tempuri__StopAnalyzing(struct soap *soap, struct __tempuri__StopAnalyzing *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__StopAnalyzing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__StartOperation(struct soap *soap, struct __tempuri__StartOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__StartOperation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__StartOperation(struct soap *soap, const struct __tempuri__StartOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__StartOperation(soap, &a->ns2__StartOperation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__StartOperation(struct soap *soap, const char *tag, int id, const struct __tempuri__StartOperation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns2__StartOperation(soap, "ns2:StartOperation", -1, &a->ns2__StartOperation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__StartOperation * SOAP_FMAC4 soap_in___tempuri__StartOperation(struct soap *soap, const char *tag, struct __tempuri__StartOperation *a, const char *type)
{
	size_t soap_flag_ns2__StartOperation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__StartOperation*)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__StartOperation, sizeof(struct __tempuri__StartOperation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__StartOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__StartOperation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__StartOperation(soap, "ns2:StartOperation", &a->ns2__StartOperation, ""))
				{	soap_flag_ns2__StartOperation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__StartOperation * SOAP_FMAC2 soap_instantiate___tempuri__StartOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__StartOperation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__StartOperation *p;
	size_t k = sizeof(struct __tempuri__StartOperation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__StartOperation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__StartOperation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__StartOperation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__StartOperation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__StartOperation(struct soap *soap, const struct __tempuri__StartOperation *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__StartOperation(soap, tag ? tag : "-tempuri:StartOperation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__StartOperation * SOAP_FMAC4 soap_get___tempuri__StartOperation(struct soap *soap, struct __tempuri__StartOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__StartOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__StartAutoPlan(struct soap *soap, struct __tempuri__StartAutoPlan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__StartAutoPlan = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__StartAutoPlan(struct soap *soap, const struct __tempuri__StartAutoPlan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__StartAutoPlan(soap, &a->ns2__StartAutoPlan);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__StartAutoPlan(struct soap *soap, const char *tag, int id, const struct __tempuri__StartAutoPlan *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns2__StartAutoPlan(soap, "ns2:StartAutoPlan", -1, &a->ns2__StartAutoPlan, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__StartAutoPlan * SOAP_FMAC4 soap_in___tempuri__StartAutoPlan(struct soap *soap, const char *tag, struct __tempuri__StartAutoPlan *a, const char *type)
{
	size_t soap_flag_ns2__StartAutoPlan = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__StartAutoPlan*)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__StartAutoPlan, sizeof(struct __tempuri__StartAutoPlan), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__StartAutoPlan(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__StartAutoPlan && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__StartAutoPlan(soap, "ns2:StartAutoPlan", &a->ns2__StartAutoPlan, ""))
				{	soap_flag_ns2__StartAutoPlan--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__StartAutoPlan * SOAP_FMAC2 soap_instantiate___tempuri__StartAutoPlan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__StartAutoPlan(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__StartAutoPlan *p;
	size_t k = sizeof(struct __tempuri__StartAutoPlan);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tempuri__StartAutoPlan, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tempuri__StartAutoPlan);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tempuri__StartAutoPlan, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__StartAutoPlan location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__StartAutoPlan(struct soap *soap, const struct __tempuri__StartAutoPlan *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__StartAutoPlan(soap, tag ? tag : "-tempuri:StartAutoPlan", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__StartAutoPlan * SOAP_FMAC4 soap_get___tempuri__StartAutoPlan(struct soap *soap, struct __tempuri__StartAutoPlan *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__StartAutoPlan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ser__anyType(struct soap *soap, struct __ser__anyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->ser__anyType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ser__anyType(struct soap *soap, const struct __ser__anyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->ser__anyType, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ser__anyType(struct soap *soap, const char *tag, int id, const struct __ser__anyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_putelement(soap, a->ser__anyType, "ser:anyType", -1, a->__type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ser__anyType * SOAP_FMAC4 soap_in___ser__anyType(struct soap *soap, const char *tag, struct __ser__anyType *a, const char *type)
{
	size_t soap_flag_ser__anyType = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ser__anyType*)soap_id_enter(soap, "", a, SOAP_TYPE___ser__anyType, sizeof(struct __ser__anyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ser__anyType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ser__anyType && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ser__anyType = soap_getelement(soap, "ser:anyType", &a->__type)))
				{	soap_flag_ser__anyType = 0;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ser__anyType * SOAP_FMAC2 soap_instantiate___ser__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ser__anyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ser__anyType *p;
	size_t k = sizeof(struct __ser__anyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ser__anyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ser__anyType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ser__anyType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ser__anyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ser__anyType(struct soap *soap, const struct __ser__anyType *a, const char *tag, const char *type)
{
	if (soap_out___ser__anyType(soap, tag ? tag : "-ser:anyType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ser__anyType * SOAP_FMAC4 soap_get___ser__anyType(struct soap *soap, struct __ser__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in___ser__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_chan__ChannelInstanceType))
		soap_serialize_chan__ChannelInstanceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, int id, struct chan__ChannelInstanceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_chan__ChannelInstanceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_chan__ChannelInstanceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_in_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct chan__ChannelInstanceType **)soap_malloc(soap, sizeof(struct chan__ChannelInstanceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_chan__ChannelInstanceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct chan__ChannelInstanceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTochan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_get_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTochan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemIRI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemIRI(soap, tag ? tag : "wsa5:ProblemIRI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Action(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Action(soap, tag ? tag : "wsa5:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__To(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__To(soap, tag ? tag : "wsa5:To", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__MessageID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__MessageID(soap, tag ? tag : "wsa5:MessageID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag ? tag : "wsa5:FaultCodesOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag ? tag : "wsa5:RelationshipTypeOpenEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GetEventsSinceId(struct soap *soap, _ns2__GetEventsSinceId *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GetEventsSinceId))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GetEventsSinceId(struct soap *soap, const char *tag, int id, _ns2__GetEventsSinceId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GetEventsSinceId, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns2__GetEventsSinceId ? type : NULL);
}

SOAP_FMAC3 _ns2__GetEventsSinceId ** SOAP_FMAC4 soap_in_PointerTo_ns2__GetEventsSinceId(struct soap *soap, const char *tag, _ns2__GetEventsSinceId **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__GetEventsSinceId **)soap_malloc(soap, sizeof(_ns2__GetEventsSinceId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__GetEventsSinceId *)soap_instantiate__ns2__GetEventsSinceId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns2__GetEventsSinceId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetEventsSinceId, sizeof(_ns2__GetEventsSinceId), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GetEventsSinceId(struct soap *soap, _ns2__GetEventsSinceId *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__GetEventsSinceId(soap, tag ? tag : "ns2:GetEventsSinceId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__GetEventsSinceId ** SOAP_FMAC4 soap_get_PointerTo_ns2__GetEventsSinceId(struct soap *soap, _ns2__GetEventsSinceId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GetEventsSinceId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GetLastEventId(struct soap *soap, _ns2__GetLastEventId *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GetLastEventId))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GetLastEventId(struct soap *soap, const char *tag, int id, _ns2__GetLastEventId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GetLastEventId, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns2__GetLastEventId ? type : NULL);
}

SOAP_FMAC3 _ns2__GetLastEventId ** SOAP_FMAC4 soap_in_PointerTo_ns2__GetLastEventId(struct soap *soap, const char *tag, _ns2__GetLastEventId **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__GetLastEventId **)soap_malloc(soap, sizeof(_ns2__GetLastEventId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__GetLastEventId *)soap_instantiate__ns2__GetLastEventId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns2__GetLastEventId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetLastEventId, sizeof(_ns2__GetLastEventId), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GetLastEventId(struct soap *soap, _ns2__GetLastEventId *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__GetLastEventId(soap, tag ? tag : "ns2:GetLastEventId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__GetLastEventId ** SOAP_FMAC4 soap_get_PointerTo_ns2__GetLastEventId(struct soap *soap, _ns2__GetLastEventId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GetLastEventId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GetEvents(struct soap *soap, _ns2__GetEvents *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GetEvents))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GetEvents(struct soap *soap, const char *tag, int id, _ns2__GetEvents *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GetEvents, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns2__GetEvents ? type : NULL);
}

SOAP_FMAC3 _ns2__GetEvents ** SOAP_FMAC4 soap_in_PointerTo_ns2__GetEvents(struct soap *soap, const char *tag, _ns2__GetEvents **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__GetEvents **)soap_malloc(soap, sizeof(_ns2__GetEvents *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__GetEvents *)soap_instantiate__ns2__GetEvents(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns2__GetEvents **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetEvents, sizeof(_ns2__GetEvents), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GetEvents(struct soap *soap, _ns2__GetEvents *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__GetEvents(soap, tag ? tag : "ns2:GetEvents", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__GetEvents ** SOAP_FMAC4 soap_get_PointerTo_ns2__GetEvents(struct soap *soap, _ns2__GetEvents **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GetEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GetResultsSinceId(struct soap *soap, _ns2__GetResultsSinceId *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GetResultsSinceId))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GetResultsSinceId(struct soap *soap, const char *tag, int id, _ns2__GetResultsSinceId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GetResultsSinceId, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns2__GetResultsSinceId ? type : NULL);
}

SOAP_FMAC3 _ns2__GetResultsSinceId ** SOAP_FMAC4 soap_in_PointerTo_ns2__GetResultsSinceId(struct soap *soap, const char *tag, _ns2__GetResultsSinceId **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__GetResultsSinceId **)soap_malloc(soap, sizeof(_ns2__GetResultsSinceId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__GetResultsSinceId *)soap_instantiate__ns2__GetResultsSinceId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns2__GetResultsSinceId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetResultsSinceId, sizeof(_ns2__GetResultsSinceId), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GetResultsSinceId(struct soap *soap, _ns2__GetResultsSinceId *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__GetResultsSinceId(soap, tag ? tag : "ns2:GetResultsSinceId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__GetResultsSinceId ** SOAP_FMAC4 soap_get_PointerTo_ns2__GetResultsSinceId(struct soap *soap, _ns2__GetResultsSinceId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GetResultsSinceId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GetLastResultId(struct soap *soap, _ns2__GetLastResultId *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GetLastResultId))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GetLastResultId(struct soap *soap, const char *tag, int id, _ns2__GetLastResultId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GetLastResultId, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns2__GetLastResultId ? type : NULL);
}

SOAP_FMAC3 _ns2__GetLastResultId ** SOAP_FMAC4 soap_in_PointerTo_ns2__GetLastResultId(struct soap *soap, const char *tag, _ns2__GetLastResultId **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__GetLastResultId **)soap_malloc(soap, sizeof(_ns2__GetLastResultId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__GetLastResultId *)soap_instantiate__ns2__GetLastResultId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns2__GetLastResultId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetLastResultId, sizeof(_ns2__GetLastResultId), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GetLastResultId(struct soap *soap, _ns2__GetLastResultId *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__GetLastResultId(soap, tag ? tag : "ns2:GetLastResultId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__GetLastResultId ** SOAP_FMAC4 soap_get_PointerTo_ns2__GetLastResultId(struct soap *soap, _ns2__GetLastResultId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GetLastResultId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GetLastResult(struct soap *soap, _ns2__GetLastResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GetLastResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GetLastResult(struct soap *soap, const char *tag, int id, _ns2__GetLastResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GetLastResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns2__GetLastResult ? type : NULL);
}

SOAP_FMAC3 _ns2__GetLastResult ** SOAP_FMAC4 soap_in_PointerTo_ns2__GetLastResult(struct soap *soap, const char *tag, _ns2__GetLastResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__GetLastResult **)soap_malloc(soap, sizeof(_ns2__GetLastResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__GetLastResult *)soap_instantiate__ns2__GetLastResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns2__GetLastResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetLastResult, sizeof(_ns2__GetLastResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GetLastResult(struct soap *soap, _ns2__GetLastResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__GetLastResult(soap, tag ? tag : "ns2:GetLastResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__GetLastResult ** SOAP_FMAC4 soap_get_PointerTo_ns2__GetLastResult(struct soap *soap, _ns2__GetLastResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GetLastResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GetResults(struct soap *soap, _ns2__GetResults *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GetResults))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GetResults(struct soap *soap, const char *tag, int id, _ns2__GetResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GetResults, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns2__GetResults ? type : NULL);
}

SOAP_FMAC3 _ns2__GetResults ** SOAP_FMAC4 soap_in_PointerTo_ns2__GetResults(struct soap *soap, const char *tag, _ns2__GetResults **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__GetResults **)soap_malloc(soap, sizeof(_ns2__GetResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__GetResults *)soap_instantiate__ns2__GetResults(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns2__GetResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetResults, sizeof(_ns2__GetResults), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GetResults(struct soap *soap, _ns2__GetResults *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__GetResults(soap, tag ? tag : "ns2:GetResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__GetResults ** SOAP_FMAC4 soap_get_PointerTo_ns2__GetResults(struct soap *soap, _ns2__GetResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GetResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__SetSystemConfigurations(struct soap *soap, _ns2__SetSystemConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__SetSystemConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__SetSystemConfigurations(struct soap *soap, const char *tag, int id, _ns2__SetSystemConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__SetSystemConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns2__SetSystemConfigurations ? type : NULL);
}

SOAP_FMAC3 _ns2__SetSystemConfigurations ** SOAP_FMAC4 soap_in_PointerTo_ns2__SetSystemConfigurations(struct soap *soap, const char *tag, _ns2__SetSystemConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__SetSystemConfigurations **)soap_malloc(soap, sizeof(_ns2__SetSystemConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__SetSystemConfigurations *)soap_instantiate__ns2__SetSystemConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns2__SetSystemConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__SetSystemConfigurations, sizeof(_ns2__SetSystemConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__SetSystemConfigurations(struct soap *soap, _ns2__SetSystemConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__SetSystemConfigurations(soap, tag ? tag : "ns2:SetSystemConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__SetSystemConfigurations ** SOAP_FMAC4 soap_get_PointerTo_ns2__SetSystemConfigurations(struct soap *soap, _ns2__SetSystemConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__SetSystemConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GetSystemConfigurations(struct soap *soap, _ns2__GetSystemConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GetSystemConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GetSystemConfigurations(struct soap *soap, const char *tag, int id, _ns2__GetSystemConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GetSystemConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns2__GetSystemConfigurations ? type : NULL);
}

SOAP_FMAC3 _ns2__GetSystemConfigurations ** SOAP_FMAC4 soap_in_PointerTo_ns2__GetSystemConfigurations(struct soap *soap, const char *tag, _ns2__GetSystemConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__GetSystemConfigurations **)soap_malloc(soap, sizeof(_ns2__GetSystemConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__GetSystemConfigurations *)soap_instantiate__ns2__GetSystemConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns2__GetSystemConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetSystemConfigurations, sizeof(_ns2__GetSystemConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GetSystemConfigurations(struct soap *soap, _ns2__GetSystemConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__GetSystemConfigurations(soap, tag ? tag : "ns2:GetSystemConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__GetSystemConfigurations ** SOAP_FMAC4 soap_get_PointerTo_ns2__GetSystemConfigurations(struct soap *soap, _ns2__GetSystemConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GetSystemConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__SetIgnoreClearing(struct soap *soap, _ns2__SetIgnoreClearing *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__SetIgnoreClearing))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__SetIgnoreClearing(struct soap *soap, const char *tag, int id, _ns2__SetIgnoreClearing *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__SetIgnoreClearing, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns2__SetIgnoreClearing ? type : NULL);
}

SOAP_FMAC3 _ns2__SetIgnoreClearing ** SOAP_FMAC4 soap_in_PointerTo_ns2__SetIgnoreClearing(struct soap *soap, const char *tag, _ns2__SetIgnoreClearing **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__SetIgnoreClearing **)soap_malloc(soap, sizeof(_ns2__SetIgnoreClearing *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__SetIgnoreClearing *)soap_instantiate__ns2__SetIgnoreClearing(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns2__SetIgnoreClearing **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__SetIgnoreClearing, sizeof(_ns2__SetIgnoreClearing), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__SetIgnoreClearing(struct soap *soap, _ns2__SetIgnoreClearing *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__SetIgnoreClearing(soap, tag ? tag : "ns2:SetIgnoreClearing", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__SetIgnoreClearing ** SOAP_FMAC4 soap_get_PointerTo_ns2__SetIgnoreClearing(struct soap *soap, _ns2__SetIgnoreClearing **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__SetIgnoreClearing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GetProcessingInfo(struct soap *soap, _ns2__GetProcessingInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GetProcessingInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GetProcessingInfo(struct soap *soap, const char *tag, int id, _ns2__GetProcessingInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GetProcessingInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns2__GetProcessingInfo ? type : NULL);
}

SOAP_FMAC3 _ns2__GetProcessingInfo ** SOAP_FMAC4 soap_in_PointerTo_ns2__GetProcessingInfo(struct soap *soap, const char *tag, _ns2__GetProcessingInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__GetProcessingInfo **)soap_malloc(soap, sizeof(_ns2__GetProcessingInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__GetProcessingInfo *)soap_instantiate__ns2__GetProcessingInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns2__GetProcessingInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetProcessingInfo, sizeof(_ns2__GetProcessingInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GetProcessingInfo(struct soap *soap, _ns2__GetProcessingInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__GetProcessingInfo(soap, tag ? tag : "ns2:GetProcessingInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__GetProcessingInfo ** SOAP_FMAC4 soap_get_PointerTo_ns2__GetProcessingInfo(struct soap *soap, _ns2__GetProcessingInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GetProcessingInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__AbortAnalyzing(struct soap *soap, _ns2__AbortAnalyzing *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__AbortAnalyzing))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__AbortAnalyzing(struct soap *soap, const char *tag, int id, _ns2__AbortAnalyzing *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__AbortAnalyzing, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns2__AbortAnalyzing ? type : NULL);
}

SOAP_FMAC3 _ns2__AbortAnalyzing ** SOAP_FMAC4 soap_in_PointerTo_ns2__AbortAnalyzing(struct soap *soap, const char *tag, _ns2__AbortAnalyzing **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__AbortAnalyzing **)soap_malloc(soap, sizeof(_ns2__AbortAnalyzing *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__AbortAnalyzing *)soap_instantiate__ns2__AbortAnalyzing(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns2__AbortAnalyzing **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__AbortAnalyzing, sizeof(_ns2__AbortAnalyzing), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__AbortAnalyzing(struct soap *soap, _ns2__AbortAnalyzing *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__AbortAnalyzing(soap, tag ? tag : "ns2:AbortAnalyzing", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__AbortAnalyzing ** SOAP_FMAC4 soap_get_PointerTo_ns2__AbortAnalyzing(struct soap *soap, _ns2__AbortAnalyzing **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__AbortAnalyzing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__StopAnalyzing(struct soap *soap, _ns2__StopAnalyzing *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__StopAnalyzing))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__StopAnalyzing(struct soap *soap, const char *tag, int id, _ns2__StopAnalyzing *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__StopAnalyzing, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns2__StopAnalyzing ? type : NULL);
}

SOAP_FMAC3 _ns2__StopAnalyzing ** SOAP_FMAC4 soap_in_PointerTo_ns2__StopAnalyzing(struct soap *soap, const char *tag, _ns2__StopAnalyzing **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__StopAnalyzing **)soap_malloc(soap, sizeof(_ns2__StopAnalyzing *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__StopAnalyzing *)soap_instantiate__ns2__StopAnalyzing(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns2__StopAnalyzing **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__StopAnalyzing, sizeof(_ns2__StopAnalyzing), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__StopAnalyzing(struct soap *soap, _ns2__StopAnalyzing *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__StopAnalyzing(soap, tag ? tag : "ns2:StopAnalyzing", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__StopAnalyzing ** SOAP_FMAC4 soap_get_PointerTo_ns2__StopAnalyzing(struct soap *soap, _ns2__StopAnalyzing **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__StopAnalyzing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__StartOperation(struct soap *soap, _ns2__StartOperation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__StartOperation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__StartOperation(struct soap *soap, const char *tag, int id, _ns2__StartOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__StartOperation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns2__StartOperation ? type : NULL);
}

SOAP_FMAC3 _ns2__StartOperation ** SOAP_FMAC4 soap_in_PointerTo_ns2__StartOperation(struct soap *soap, const char *tag, _ns2__StartOperation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__StartOperation **)soap_malloc(soap, sizeof(_ns2__StartOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__StartOperation *)soap_instantiate__ns2__StartOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns2__StartOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__StartOperation, sizeof(_ns2__StartOperation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__StartOperation(struct soap *soap, _ns2__StartOperation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__StartOperation(soap, tag ? tag : "ns2:StartOperation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__StartOperation ** SOAP_FMAC4 soap_get_PointerTo_ns2__StartOperation(struct soap *soap, _ns2__StartOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__StartOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__StartAutoPlan(struct soap *soap, _ns2__StartAutoPlan *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__StartAutoPlan))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__StartAutoPlan(struct soap *soap, const char *tag, int id, _ns2__StartAutoPlan *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__StartAutoPlan, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns2__StartAutoPlan ? type : NULL);
}

SOAP_FMAC3 _ns2__StartAutoPlan ** SOAP_FMAC4 soap_in_PointerTo_ns2__StartAutoPlan(struct soap *soap, const char *tag, _ns2__StartAutoPlan **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__StartAutoPlan **)soap_malloc(soap, sizeof(_ns2__StartAutoPlan *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__StartAutoPlan *)soap_instantiate__ns2__StartAutoPlan(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns2__StartAutoPlan **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__StartAutoPlan, sizeof(_ns2__StartAutoPlan), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__StartAutoPlan(struct soap *soap, _ns2__StartAutoPlan *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__StartAutoPlan(soap, tag ? tag : "ns2:StartAutoPlan", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__StartAutoPlan ** SOAP_FMAC4 soap_get_PointerTo_ns2__StartAutoPlan(struct soap *soap, _ns2__StartAutoPlan **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__StartAutoPlan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__EEventTypes(struct soap *soap, enum ns10__EEventTypes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns10__EEventTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__EEventTypes(struct soap *soap, const char *tag, int id, enum ns10__EEventTypes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__EEventTypes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns10__EEventTypes(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns10__EEventTypes ** SOAP_FMAC4 soap_in_PointerTons10__EEventTypes(struct soap *soap, const char *tag, enum ns10__EEventTypes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns10__EEventTypes **)soap_malloc(soap, sizeof(enum ns10__EEventTypes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns10__EEventTypes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns10__EEventTypes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__EEventTypes, sizeof(enum ns10__EEventTypes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__EEventTypes(struct soap *soap, enum ns10__EEventTypes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons10__EEventTypes(soap, tag ? tag : "ns10:EEventTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns10__EEventTypes ** SOAP_FMAC4 soap_get_PointerTons10__EEventTypes(struct soap *soap, enum ns10__EEventTypes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__EEventTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__EEvent(struct soap *soap, ns10__EEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns10__EEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__EEvent(struct soap *soap, const char *tag, int id, ns10__EEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__EEvent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns10__EEvent ? type : NULL);
}

SOAP_FMAC3 ns10__EEvent ** SOAP_FMAC4 soap_in_PointerTons10__EEvent(struct soap *soap, const char *tag, ns10__EEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns10__EEvent **)soap_malloc(soap, sizeof(ns10__EEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns10__EEvent *)soap_instantiate_ns10__EEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns10__EEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__EEvent, sizeof(ns10__EEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__EEvent(struct soap *soap, ns10__EEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons10__EEvent(soap, tag ? tag : "ns10:EEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns10__EEvent ** SOAP_FMAC4 soap_get_PointerTons10__EEvent(struct soap *soap, ns10__EEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__EEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__EResultValueStatus(struct soap *soap, enum ns10__EResultValueStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns10__EResultValueStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__EResultValueStatus(struct soap *soap, const char *tag, int id, enum ns10__EResultValueStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__EResultValueStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns10__EResultValueStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns10__EResultValueStatus ** SOAP_FMAC4 soap_in_PointerTons10__EResultValueStatus(struct soap *soap, const char *tag, enum ns10__EResultValueStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns10__EResultValueStatus **)soap_malloc(soap, sizeof(enum ns10__EResultValueStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns10__EResultValueStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns10__EResultValueStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__EResultValueStatus, sizeof(enum ns10__EResultValueStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__EResultValueStatus(struct soap *soap, enum ns10__EResultValueStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons10__EResultValueStatus(soap, tag ? tag : "ns10:EResultValueStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns10__EResultValueStatus ** SOAP_FMAC4 soap_get_PointerTons10__EResultValueStatus(struct soap *soap, enum ns10__EResultValueStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__EResultValueStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__EResultStatus(struct soap *soap, enum ns10__EResultStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns10__EResultStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__EResultStatus(struct soap *soap, const char *tag, int id, enum ns10__EResultStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__EResultStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns10__EResultStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns10__EResultStatus ** SOAP_FMAC4 soap_in_PointerTons10__EResultStatus(struct soap *soap, const char *tag, enum ns10__EResultStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns10__EResultStatus **)soap_malloc(soap, sizeof(enum ns10__EResultStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns10__EResultStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns10__EResultStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__EResultStatus, sizeof(enum ns10__EResultStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__EResultStatus(struct soap *soap, enum ns10__EResultStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons10__EResultStatus(soap, tag ? tag : "ns10:EResultStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns10__EResultStatus ** SOAP_FMAC4 soap_get_PointerTons10__EResultStatus(struct soap *soap, enum ns10__EResultStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__EResultStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__EResult(struct soap *soap, ns10__EResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns10__EResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__EResult(struct soap *soap, const char *tag, int id, ns10__EResult *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__EResult, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns10__EResult ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns10__EResult ** SOAP_FMAC4 soap_in_PointerTons10__EResult(struct soap *soap, const char *tag, ns10__EResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns10__EResult **)soap_malloc(soap, sizeof(ns10__EResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns10__EResult *)soap_instantiate_ns10__EResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns10__EResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__EResult, sizeof(ns10__EResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__EResult(struct soap *soap, ns10__EResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons10__EResult(soap, tag ? tag : "ns10:EResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns10__EResult ** SOAP_FMAC4 soap_get_PointerTons10__EResult(struct soap *soap, ns10__EResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__EResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__ArrayOfEResult(struct soap *soap, ns10__ArrayOfEResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns10__ArrayOfEResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__ArrayOfEResult(struct soap *soap, const char *tag, int id, ns10__ArrayOfEResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__ArrayOfEResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns10__ArrayOfEResult ? type : NULL);
}

SOAP_FMAC3 ns10__ArrayOfEResult ** SOAP_FMAC4 soap_in_PointerTons10__ArrayOfEResult(struct soap *soap, const char *tag, ns10__ArrayOfEResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns10__ArrayOfEResult **)soap_malloc(soap, sizeof(ns10__ArrayOfEResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns10__ArrayOfEResult *)soap_instantiate_ns10__ArrayOfEResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns10__ArrayOfEResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__ArrayOfEResult, sizeof(ns10__ArrayOfEResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__ArrayOfEResult(struct soap *soap, ns10__ArrayOfEResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons10__ArrayOfEResult(soap, tag ? tag : "ns10:ArrayOfEResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns10__ArrayOfEResult ** SOAP_FMAC4 soap_get_PointerTons10__ArrayOfEResult(struct soap *soap, ns10__ArrayOfEResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__ArrayOfEResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__AuxDeviceState(struct soap *soap, ns7__AuxDeviceState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__AuxDeviceState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__AuxDeviceState(struct soap *soap, const char *tag, int id, ns7__AuxDeviceState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__AuxDeviceState, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__AuxDeviceState ? type : NULL);
}

SOAP_FMAC3 ns7__AuxDeviceState ** SOAP_FMAC4 soap_in_PointerTons7__AuxDeviceState(struct soap *soap, const char *tag, ns7__AuxDeviceState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__AuxDeviceState **)soap_malloc(soap, sizeof(ns7__AuxDeviceState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__AuxDeviceState *)soap_instantiate_ns7__AuxDeviceState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__AuxDeviceState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__AuxDeviceState, sizeof(ns7__AuxDeviceState), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__AuxDeviceState(struct soap *soap, ns7__AuxDeviceState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__AuxDeviceState(soap, tag ? tag : "ns7:AuxDeviceState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__AuxDeviceState ** SOAP_FMAC4 soap_get_PointerTons7__AuxDeviceState(struct soap *soap, ns7__AuxDeviceState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__AuxDeviceState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ArrayOfAuxDeviceState(struct soap *soap, ns7__ArrayOfAuxDeviceState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__ArrayOfAuxDeviceState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__ArrayOfAuxDeviceState(struct soap *soap, const char *tag, int id, ns7__ArrayOfAuxDeviceState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ArrayOfAuxDeviceState, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__ArrayOfAuxDeviceState ? type : NULL);
}

SOAP_FMAC3 ns7__ArrayOfAuxDeviceState ** SOAP_FMAC4 soap_in_PointerTons7__ArrayOfAuxDeviceState(struct soap *soap, const char *tag, ns7__ArrayOfAuxDeviceState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__ArrayOfAuxDeviceState **)soap_malloc(soap, sizeof(ns7__ArrayOfAuxDeviceState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__ArrayOfAuxDeviceState *)soap_instantiate_ns7__ArrayOfAuxDeviceState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__ArrayOfAuxDeviceState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ArrayOfAuxDeviceState, sizeof(ns7__ArrayOfAuxDeviceState), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ArrayOfAuxDeviceState(struct soap *soap, ns7__ArrayOfAuxDeviceState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__ArrayOfAuxDeviceState(soap, tag ? tag : "ns7:ArrayOfAuxDeviceState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__ArrayOfAuxDeviceState ** SOAP_FMAC4 soap_get_PointerTons7__ArrayOfAuxDeviceState(struct soap *soap, ns7__ArrayOfAuxDeviceState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__ArrayOfAuxDeviceState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__AuxDevice(struct soap *soap, ns7__AuxDevice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__AuxDevice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__AuxDevice(struct soap *soap, const char *tag, int id, ns7__AuxDevice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__AuxDevice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__AuxDevice ? type : NULL);
}

SOAP_FMAC3 ns7__AuxDevice ** SOAP_FMAC4 soap_in_PointerTons7__AuxDevice(struct soap *soap, const char *tag, ns7__AuxDevice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__AuxDevice **)soap_malloc(soap, sizeof(ns7__AuxDevice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__AuxDevice *)soap_instantiate_ns7__AuxDevice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__AuxDevice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__AuxDevice, sizeof(ns7__AuxDevice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__AuxDevice(struct soap *soap, ns7__AuxDevice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__AuxDevice(soap, tag ? tag : "ns7:AuxDevice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__AuxDevice ** SOAP_FMAC4 soap_get_PointerTons7__AuxDevice(struct soap *soap, ns7__AuxDevice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__AuxDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ArrayOfAuxDevice(struct soap *soap, ns7__ArrayOfAuxDevice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__ArrayOfAuxDevice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__ArrayOfAuxDevice(struct soap *soap, const char *tag, int id, ns7__ArrayOfAuxDevice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ArrayOfAuxDevice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__ArrayOfAuxDevice ? type : NULL);
}

SOAP_FMAC3 ns7__ArrayOfAuxDevice ** SOAP_FMAC4 soap_in_PointerTons7__ArrayOfAuxDevice(struct soap *soap, const char *tag, ns7__ArrayOfAuxDevice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__ArrayOfAuxDevice **)soap_malloc(soap, sizeof(ns7__ArrayOfAuxDevice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__ArrayOfAuxDevice *)soap_instantiate_ns7__ArrayOfAuxDevice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__ArrayOfAuxDevice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ArrayOfAuxDevice, sizeof(ns7__ArrayOfAuxDevice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ArrayOfAuxDevice(struct soap *soap, ns7__ArrayOfAuxDevice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__ArrayOfAuxDevice(soap, tag ? tag : "ns7:ArrayOfAuxDevice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__ArrayOfAuxDevice ** SOAP_FMAC4 soap_get_PointerTons7__ArrayOfAuxDevice(struct soap *soap, ns7__ArrayOfAuxDevice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__ArrayOfAuxDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfOperation(struct soap *soap, ns4__ArrayOfOperation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfOperation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfOperation(struct soap *soap, const char *tag, int id, ns4__ArrayOfOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfOperation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns4__ArrayOfOperation ? type : NULL);
}

SOAP_FMAC3 ns4__ArrayOfOperation ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfOperation(struct soap *soap, const char *tag, ns4__ArrayOfOperation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfOperation **)soap_malloc(soap, sizeof(ns4__ArrayOfOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfOperation *)soap_instantiate_ns4__ArrayOfOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns4__ArrayOfOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfOperation, sizeof(ns4__ArrayOfOperation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfOperation(struct soap *soap, ns4__ArrayOfOperation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__ArrayOfOperation(soap, tag ? tag : "ns4:ArrayOfOperation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__ArrayOfOperation ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfOperation(struct soap *soap, ns4__ArrayOfOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfMeasuringComponent(struct soap *soap, ns4__ArrayOfMeasuringComponent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfMeasuringComponent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfMeasuringComponent(struct soap *soap, const char *tag, int id, ns4__ArrayOfMeasuringComponent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfMeasuringComponent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns4__ArrayOfMeasuringComponent ? type : NULL);
}

SOAP_FMAC3 ns4__ArrayOfMeasuringComponent ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfMeasuringComponent(struct soap *soap, const char *tag, ns4__ArrayOfMeasuringComponent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfMeasuringComponent **)soap_malloc(soap, sizeof(ns4__ArrayOfMeasuringComponent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfMeasuringComponent *)soap_instantiate_ns4__ArrayOfMeasuringComponent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns4__ArrayOfMeasuringComponent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfMeasuringComponent, sizeof(ns4__ArrayOfMeasuringComponent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfMeasuringComponent(struct soap *soap, ns4__ArrayOfMeasuringComponent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__ArrayOfMeasuringComponent(soap, tag ? tag : "ns4:ArrayOfMeasuringComponent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__ArrayOfMeasuringComponent ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfMeasuringComponent(struct soap *soap, ns4__ArrayOfMeasuringComponent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfMeasuringComponent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfControlledParametr(struct soap *soap, ns4__ArrayOfControlledParametr *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfControlledParametr))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfControlledParametr(struct soap *soap, const char *tag, int id, ns4__ArrayOfControlledParametr *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfControlledParametr, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns4__ArrayOfControlledParametr ? type : NULL);
}

SOAP_FMAC3 ns4__ArrayOfControlledParametr ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfControlledParametr(struct soap *soap, const char *tag, ns4__ArrayOfControlledParametr **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfControlledParametr **)soap_malloc(soap, sizeof(ns4__ArrayOfControlledParametr *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfControlledParametr *)soap_instantiate_ns4__ArrayOfControlledParametr(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns4__ArrayOfControlledParametr **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfControlledParametr, sizeof(ns4__ArrayOfControlledParametr), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfControlledParametr(struct soap *soap, ns4__ArrayOfControlledParametr *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__ArrayOfControlledParametr(soap, tag ? tag : "ns4:ArrayOfControlledParametr", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__ArrayOfControlledParametr ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfControlledParametr(struct soap *soap, ns4__ArrayOfControlledParametr **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfControlledParametr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__Logger_x002eLogLevel(struct soap *soap, enum ns8__Logger_x002eLogLevel *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns8__Logger_x002eLogLevel);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__Logger_x002eLogLevel(struct soap *soap, const char *tag, int id, enum ns8__Logger_x002eLogLevel *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__Logger_x002eLogLevel, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns8__Logger_x002eLogLevel(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns8__Logger_x002eLogLevel ** SOAP_FMAC4 soap_in_PointerTons8__Logger_x002eLogLevel(struct soap *soap, const char *tag, enum ns8__Logger_x002eLogLevel **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns8__Logger_x002eLogLevel **)soap_malloc(soap, sizeof(enum ns8__Logger_x002eLogLevel *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns8__Logger_x002eLogLevel(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns8__Logger_x002eLogLevel **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__Logger_x002eLogLevel, sizeof(enum ns8__Logger_x002eLogLevel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__Logger_x002eLogLevel(struct soap *soap, enum ns8__Logger_x002eLogLevel *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons8__Logger_x002eLogLevel(soap, tag ? tag : "ns8:Logger.LogLevel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns8__Logger_x002eLogLevel ** SOAP_FMAC4 soap_get_PointerTons8__Logger_x002eLogLevel(struct soap *soap, enum ns8__Logger_x002eLogLevel **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons8__Logger_x002eLogLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__AuxControllerConfiguration(struct soap *soap, ns7__AuxControllerConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__AuxControllerConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__AuxControllerConfiguration(struct soap *soap, const char *tag, int id, ns7__AuxControllerConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__AuxControllerConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__AuxControllerConfiguration ? type : NULL);
}

SOAP_FMAC3 ns7__AuxControllerConfiguration ** SOAP_FMAC4 soap_in_PointerTons7__AuxControllerConfiguration(struct soap *soap, const char *tag, ns7__AuxControllerConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__AuxControllerConfiguration **)soap_malloc(soap, sizeof(ns7__AuxControllerConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__AuxControllerConfiguration *)soap_instantiate_ns7__AuxControllerConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__AuxControllerConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__AuxControllerConfiguration, sizeof(ns7__AuxControllerConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__AuxControllerConfiguration(struct soap *soap, ns7__AuxControllerConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__AuxControllerConfiguration(soap, tag ? tag : "ns7:AuxControllerConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__AuxControllerConfiguration ** SOAP_FMAC4 soap_get_PointerTons7__AuxControllerConfiguration(struct soap *soap, ns7__AuxControllerConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__AuxControllerConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Aux2Config(struct soap *soap, ns6__Aux2Config *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__Aux2Config))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__Aux2Config(struct soap *soap, const char *tag, int id, ns6__Aux2Config *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Aux2Config, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__Aux2Config ? type : NULL);
}

SOAP_FMAC3 ns6__Aux2Config ** SOAP_FMAC4 soap_in_PointerTons6__Aux2Config(struct soap *soap, const char *tag, ns6__Aux2Config **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__Aux2Config **)soap_malloc(soap, sizeof(ns6__Aux2Config *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__Aux2Config *)soap_instantiate_ns6__Aux2Config(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__Aux2Config **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Aux2Config, sizeof(ns6__Aux2Config), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Aux2Config(struct soap *soap, ns6__Aux2Config *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__Aux2Config(soap, tag ? tag : "ns6:Aux2Config", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Aux2Config ** SOAP_FMAC4 soap_get_PointerTons6__Aux2Config(struct soap *soap, ns6__Aux2Config **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__Aux2Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfAutoPlanItem(struct soap *soap, ns4__ArrayOfAutoPlanItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfAutoPlanItem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfAutoPlanItem(struct soap *soap, const char *tag, int id, ns4__ArrayOfAutoPlanItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfAutoPlanItem, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns4__ArrayOfAutoPlanItem ? type : NULL);
}

SOAP_FMAC3 ns4__ArrayOfAutoPlanItem ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfAutoPlanItem(struct soap *soap, const char *tag, ns4__ArrayOfAutoPlanItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfAutoPlanItem **)soap_malloc(soap, sizeof(ns4__ArrayOfAutoPlanItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfAutoPlanItem *)soap_instantiate_ns4__ArrayOfAutoPlanItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns4__ArrayOfAutoPlanItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfAutoPlanItem, sizeof(ns4__ArrayOfAutoPlanItem), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfAutoPlanItem(struct soap *soap, ns4__ArrayOfAutoPlanItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__ArrayOfAutoPlanItem(soap, tag ? tag : "ns4:ArrayOfAutoPlanItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__ArrayOfAutoPlanItem ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfAutoPlanItem(struct soap *soap, ns4__ArrayOfAutoPlanItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfAutoPlanItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__OperationStep_x002eUsingControlledParametr(struct soap *soap, ns4__OperationStep_x002eUsingControlledParametr *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__OperationStep_x002eUsingControlledParametr(struct soap *soap, const char *tag, int id, ns4__OperationStep_x002eUsingControlledParametr *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr ? type : NULL);
}

SOAP_FMAC3 ns4__OperationStep_x002eUsingControlledParametr ** SOAP_FMAC4 soap_in_PointerTons4__OperationStep_x002eUsingControlledParametr(struct soap *soap, const char *tag, ns4__OperationStep_x002eUsingControlledParametr **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__OperationStep_x002eUsingControlledParametr **)soap_malloc(soap, sizeof(ns4__OperationStep_x002eUsingControlledParametr *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__OperationStep_x002eUsingControlledParametr *)soap_instantiate_ns4__OperationStep_x002eUsingControlledParametr(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns4__OperationStep_x002eUsingControlledParametr **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr, sizeof(ns4__OperationStep_x002eUsingControlledParametr), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__OperationStep_x002eUsingControlledParametr(struct soap *soap, ns4__OperationStep_x002eUsingControlledParametr *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__OperationStep_x002eUsingControlledParametr(soap, tag ? tag : "ns4:OperationStep.UsingControlledParametr", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__OperationStep_x002eUsingControlledParametr ** SOAP_FMAC4 soap_get_PointerTons4__OperationStep_x002eUsingControlledParametr(struct soap *soap, ns4__OperationStep_x002eUsingControlledParametr **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__OperationStep_x002eUsingControlledParametr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToLONG64(soap, tag ? tag : "long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons9__ChromatographMode(struct soap *soap, enum ns9__ChromatographMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns9__ChromatographMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons9__ChromatographMode(struct soap *soap, const char *tag, int id, enum ns9__ChromatographMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns9__ChromatographMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns9__ChromatographMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns9__ChromatographMode ** SOAP_FMAC4 soap_in_PointerTons9__ChromatographMode(struct soap *soap, const char *tag, enum ns9__ChromatographMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns9__ChromatographMode **)soap_malloc(soap, sizeof(enum ns9__ChromatographMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns9__ChromatographMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns9__ChromatographMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns9__ChromatographMode, sizeof(enum ns9__ChromatographMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons9__ChromatographMode(struct soap *soap, enum ns9__ChromatographMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons9__ChromatographMode(soap, tag ? tag : "ns9:ChromatographMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns9__ChromatographMode ** SOAP_FMAC4 soap_get_PointerTons9__ChromatographMode(struct soap *soap, enum ns9__ChromatographMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons9__ChromatographMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr(struct soap *soap, ns4__ArrayOfOperationStep_x002eUsingControlledParametr *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr(struct soap *soap, const char *tag, int id, ns4__ArrayOfOperationStep_x002eUsingControlledParametr *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr ? type : NULL);
}

SOAP_FMAC3 ns4__ArrayOfOperationStep_x002eUsingControlledParametr ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr(struct soap *soap, const char *tag, ns4__ArrayOfOperationStep_x002eUsingControlledParametr **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfOperationStep_x002eUsingControlledParametr **)soap_malloc(soap, sizeof(ns4__ArrayOfOperationStep_x002eUsingControlledParametr *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfOperationStep_x002eUsingControlledParametr *)soap_instantiate_ns4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns4__ArrayOfOperationStep_x002eUsingControlledParametr **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfOperationStep_x002eUsingControlledParametr, sizeof(ns4__ArrayOfOperationStep_x002eUsingControlledParametr), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr(struct soap *soap, ns4__ArrayOfOperationStep_x002eUsingControlledParametr *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, tag ? tag : "ns4:ArrayOfOperationStep.UsingControlledParametr", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__ArrayOfOperationStep_x002eUsingControlledParametr ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr(struct soap *soap, ns4__ArrayOfOperationStep_x002eUsingControlledParametr **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfOperationStep_x002eUsingControlledParametr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__OperationStep(struct soap *soap, ns4__OperationStep *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__OperationStep))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__OperationStep(struct soap *soap, const char *tag, int id, ns4__OperationStep *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__OperationStep, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns4__OperationStep ? type : NULL);
}

SOAP_FMAC3 ns4__OperationStep ** SOAP_FMAC4 soap_in_PointerTons4__OperationStep(struct soap *soap, const char *tag, ns4__OperationStep **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__OperationStep **)soap_malloc(soap, sizeof(ns4__OperationStep *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__OperationStep *)soap_instantiate_ns4__OperationStep(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns4__OperationStep **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__OperationStep, sizeof(ns4__OperationStep), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__OperationStep(struct soap *soap, ns4__OperationStep *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__OperationStep(soap, tag ? tag : "ns4:OperationStep", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__OperationStep ** SOAP_FMAC4 soap_get_PointerTons4__OperationStep(struct soap *soap, ns4__OperationStep **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__OperationStep(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__OperationTypes(struct soap *soap, enum ns4__OperationTypes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns4__OperationTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__OperationTypes(struct soap *soap, const char *tag, int id, enum ns4__OperationTypes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__OperationTypes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__OperationTypes(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__OperationTypes ** SOAP_FMAC4 soap_in_PointerTons4__OperationTypes(struct soap *soap, const char *tag, enum ns4__OperationTypes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__OperationTypes **)soap_malloc(soap, sizeof(enum ns4__OperationTypes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__OperationTypes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__OperationTypes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__OperationTypes, sizeof(enum ns4__OperationTypes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__OperationTypes(struct soap *soap, enum ns4__OperationTypes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__OperationTypes(soap, tag ? tag : "ns4:OperationTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__OperationTypes ** SOAP_FMAC4 soap_get_PointerTons4__OperationTypes(struct soap *soap, enum ns4__OperationTypes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__OperationTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfOperationStep(struct soap *soap, ns4__ArrayOfOperationStep *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfOperationStep))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfOperationStep(struct soap *soap, const char *tag, int id, ns4__ArrayOfOperationStep *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfOperationStep, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns4__ArrayOfOperationStep ? type : NULL);
}

SOAP_FMAC3 ns4__ArrayOfOperationStep ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfOperationStep(struct soap *soap, const char *tag, ns4__ArrayOfOperationStep **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfOperationStep **)soap_malloc(soap, sizeof(ns4__ArrayOfOperationStep *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfOperationStep *)soap_instantiate_ns4__ArrayOfOperationStep(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns4__ArrayOfOperationStep **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfOperationStep, sizeof(ns4__ArrayOfOperationStep), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfOperationStep(struct soap *soap, ns4__ArrayOfOperationStep *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__ArrayOfOperationStep(soap, tag ? tag : "ns4:ArrayOfOperationStep", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__ArrayOfOperationStep ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfOperationStep(struct soap *soap, ns4__ArrayOfOperationStep **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfOperationStep(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Operation(struct soap *soap, ns4__Operation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Operation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Operation(struct soap *soap, const char *tag, int id, ns4__Operation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Operation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns4__Operation ? type : NULL);
}

SOAP_FMAC3 ns4__Operation ** SOAP_FMAC4 soap_in_PointerTons4__Operation(struct soap *soap, const char *tag, ns4__Operation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Operation **)soap_malloc(soap, sizeof(ns4__Operation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Operation *)soap_instantiate_ns4__Operation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns4__Operation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Operation, sizeof(ns4__Operation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Operation(struct soap *soap, ns4__Operation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__Operation(soap, tag ? tag : "ns4:Operation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__Operation ** SOAP_FMAC4 soap_get_PointerTons4__Operation(struct soap *soap, ns4__Operation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Operation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__decimal(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__decimal))
		soap_serialize_xsd__decimal(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__decimal(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__decimal, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__decimal(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__decimal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__decimal(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__decimal(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__MeasuringComponent(struct soap *soap, ns4__MeasuringComponent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__MeasuringComponent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__MeasuringComponent(struct soap *soap, const char *tag, int id, ns4__MeasuringComponent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__MeasuringComponent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns4__MeasuringComponent ? type : NULL);
}

SOAP_FMAC3 ns4__MeasuringComponent ** SOAP_FMAC4 soap_in_PointerTons4__MeasuringComponent(struct soap *soap, const char *tag, ns4__MeasuringComponent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__MeasuringComponent **)soap_malloc(soap, sizeof(ns4__MeasuringComponent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__MeasuringComponent *)soap_instantiate_ns4__MeasuringComponent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns4__MeasuringComponent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__MeasuringComponent, sizeof(ns4__MeasuringComponent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__MeasuringComponent(struct soap *soap, ns4__MeasuringComponent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__MeasuringComponent(soap, tag ? tag : "ns4:MeasuringComponent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__MeasuringComponent ** SOAP_FMAC4 soap_get_PointerTons4__MeasuringComponent(struct soap *soap, ns4__MeasuringComponent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__MeasuringComponent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__unsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__unsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerToxsd__unsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__unsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__unsignedByte(soap, tag ? tag : "xsd:unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerToxsd__unsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ControlledParametr_x002eControlActionType(struct soap *soap, enum ns4__ControlledParametr_x002eControlActionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns4__ControlledParametr_x002eControlActionType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ControlledParametr_x002eControlActionType(struct soap *soap, const char *tag, int id, enum ns4__ControlledParametr_x002eControlActionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ControlledParametr_x002eControlActionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__ControlledParametr_x002eControlActionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__ControlledParametr_x002eControlActionType ** SOAP_FMAC4 soap_in_PointerTons4__ControlledParametr_x002eControlActionType(struct soap *soap, const char *tag, enum ns4__ControlledParametr_x002eControlActionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__ControlledParametr_x002eControlActionType **)soap_malloc(soap, sizeof(enum ns4__ControlledParametr_x002eControlActionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__ControlledParametr_x002eControlActionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__ControlledParametr_x002eControlActionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ControlledParametr_x002eControlActionType, sizeof(enum ns4__ControlledParametr_x002eControlActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ControlledParametr_x002eControlActionType(struct soap *soap, enum ns4__ControlledParametr_x002eControlActionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__ControlledParametr_x002eControlActionType(soap, tag ? tag : "ns4:ControlledParametr.ControlActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__ControlledParametr_x002eControlActionType ** SOAP_FMAC4 soap_get_PointerTons4__ControlledParametr_x002eControlActionType(struct soap *soap, enum ns4__ControlledParametr_x002eControlActionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ControlledParametr_x002eControlActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ControlledParametr(struct soap *soap, ns4__ControlledParametr *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ControlledParametr))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ControlledParametr(struct soap *soap, const char *tag, int id, ns4__ControlledParametr *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ControlledParametr, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns4__ControlledParametr ? type : NULL);
}

SOAP_FMAC3 ns4__ControlledParametr ** SOAP_FMAC4 soap_in_PointerTons4__ControlledParametr(struct soap *soap, const char *tag, ns4__ControlledParametr **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ControlledParametr **)soap_malloc(soap, sizeof(ns4__ControlledParametr *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ControlledParametr *)soap_instantiate_ns4__ControlledParametr(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns4__ControlledParametr **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ControlledParametr, sizeof(ns4__ControlledParametr), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ControlledParametr(struct soap *soap, ns4__ControlledParametr *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__ControlledParametr(soap, tag ? tag : "ns4:ControlledParametr", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__ControlledParametr ** SOAP_FMAC4 soap_get_PointerTons4__ControlledParametr(struct soap *soap, ns4__ControlledParametr **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ControlledParametr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Periodicity_x002eTime(struct soap *soap, ns4__Periodicity_x002eTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Periodicity_x002eTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Periodicity_x002eTime(struct soap *soap, const char *tag, int id, ns4__Periodicity_x002eTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Periodicity_x002eTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns4__Periodicity_x002eTime ? type : NULL);
}

SOAP_FMAC3 ns4__Periodicity_x002eTime ** SOAP_FMAC4 soap_in_PointerTons4__Periodicity_x002eTime(struct soap *soap, const char *tag, ns4__Periodicity_x002eTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Periodicity_x002eTime **)soap_malloc(soap, sizeof(ns4__Periodicity_x002eTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Periodicity_x002eTime *)soap_instantiate_ns4__Periodicity_x002eTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns4__Periodicity_x002eTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Periodicity_x002eTime, sizeof(ns4__Periodicity_x002eTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Periodicity_x002eTime(struct soap *soap, ns4__Periodicity_x002eTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__Periodicity_x002eTime(soap, tag ? tag : "ns4:Periodicity.Time", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__Periodicity_x002eTime ** SOAP_FMAC4 soap_get_PointerTons4__Periodicity_x002eTime(struct soap *soap, ns4__Periodicity_x002eTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Periodicity_x002eTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfPeriodicity_x002eTime(struct soap *soap, ns4__ArrayOfPeriodicity_x002eTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfPeriodicity_x002eTime(struct soap *soap, const char *tag, int id, ns4__ArrayOfPeriodicity_x002eTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime ? type : NULL);
}

SOAP_FMAC3 ns4__ArrayOfPeriodicity_x002eTime ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfPeriodicity_x002eTime(struct soap *soap, const char *tag, ns4__ArrayOfPeriodicity_x002eTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfPeriodicity_x002eTime **)soap_malloc(soap, sizeof(ns4__ArrayOfPeriodicity_x002eTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfPeriodicity_x002eTime *)soap_instantiate_ns4__ArrayOfPeriodicity_x002eTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns4__ArrayOfPeriodicity_x002eTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfPeriodicity_x002eTime, sizeof(ns4__ArrayOfPeriodicity_x002eTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfPeriodicity_x002eTime(struct soap *soap, ns4__ArrayOfPeriodicity_x002eTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__ArrayOfPeriodicity_x002eTime(soap, tag ? tag : "ns4:ArrayOfPeriodicity.Time", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__ArrayOfPeriodicity_x002eTime ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfPeriodicity_x002eTime(struct soap *soap, ns4__ArrayOfPeriodicity_x002eTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfPeriodicity_x002eTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToarr__ArrayOfboolean(struct soap *soap, arr__ArrayOfboolean *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_arr__ArrayOfboolean))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToarr__ArrayOfboolean(struct soap *soap, const char *tag, int id, arr__ArrayOfboolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_arr__ArrayOfboolean, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_arr__ArrayOfboolean ? type : NULL);
}

SOAP_FMAC3 arr__ArrayOfboolean ** SOAP_FMAC4 soap_in_PointerToarr__ArrayOfboolean(struct soap *soap, const char *tag, arr__ArrayOfboolean **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (arr__ArrayOfboolean **)soap_malloc(soap, sizeof(arr__ArrayOfboolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (arr__ArrayOfboolean *)soap_instantiate_arr__ArrayOfboolean(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (arr__ArrayOfboolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_arr__ArrayOfboolean, sizeof(arr__ArrayOfboolean), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToarr__ArrayOfboolean(struct soap *soap, arr__ArrayOfboolean *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToarr__ArrayOfboolean(soap, tag ? tag : "arr:ArrayOfboolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 arr__ArrayOfboolean ** SOAP_FMAC4 soap_get_PointerToarr__ArrayOfboolean(struct soap *soap, arr__ArrayOfboolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToarr__ArrayOfboolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Periodicity(struct soap *soap, ns4__Periodicity *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Periodicity))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Periodicity(struct soap *soap, const char *tag, int id, ns4__Periodicity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Periodicity, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns4__Periodicity ? type : NULL);
}

SOAP_FMAC3 ns4__Periodicity ** SOAP_FMAC4 soap_in_PointerTons4__Periodicity(struct soap *soap, const char *tag, ns4__Periodicity **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Periodicity **)soap_malloc(soap, sizeof(ns4__Periodicity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Periodicity *)soap_instantiate_ns4__Periodicity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns4__Periodicity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Periodicity, sizeof(ns4__Periodicity), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Periodicity(struct soap *soap, ns4__Periodicity *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__Periodicity(soap, tag ? tag : "ns4:Periodicity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__Periodicity ** SOAP_FMAC4 soap_get_PointerTons4__Periodicity(struct soap *soap, ns4__Periodicity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Periodicity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__AutoPlanItem(struct soap *soap, ns4__AutoPlanItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__AutoPlanItem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__AutoPlanItem(struct soap *soap, const char *tag, int id, ns4__AutoPlanItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__AutoPlanItem, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns4__AutoPlanItem ? type : NULL);
}

SOAP_FMAC3 ns4__AutoPlanItem ** SOAP_FMAC4 soap_in_PointerTons4__AutoPlanItem(struct soap *soap, const char *tag, ns4__AutoPlanItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__AutoPlanItem **)soap_malloc(soap, sizeof(ns4__AutoPlanItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__AutoPlanItem *)soap_instantiate_ns4__AutoPlanItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns4__AutoPlanItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__AutoPlanItem, sizeof(ns4__AutoPlanItem), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__AutoPlanItem(struct soap *soap, ns4__AutoPlanItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__AutoPlanItem(soap, tag ? tag : "ns4:AutoPlanItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__AutoPlanItem ** SOAP_FMAC4 soap_get_PointerTons4__AutoPlanItem(struct soap *soap, ns4__AutoPlanItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__AutoPlanItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__OperationStepTypes(struct soap *soap, enum ns4__OperationStepTypes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns4__OperationStepTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__OperationStepTypes(struct soap *soap, const char *tag, int id, enum ns4__OperationStepTypes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__OperationStepTypes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__OperationStepTypes(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__OperationStepTypes ** SOAP_FMAC4 soap_in_PointerTons4__OperationStepTypes(struct soap *soap, const char *tag, enum ns4__OperationStepTypes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__OperationStepTypes **)soap_malloc(soap, sizeof(enum ns4__OperationStepTypes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__OperationStepTypes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__OperationStepTypes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__OperationStepTypes, sizeof(enum ns4__OperationStepTypes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__OperationStepTypes(struct soap *soap, enum ns4__OperationStepTypes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__OperationStepTypes(soap, tag ? tag : "ns4:OperationStepTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__OperationStepTypes ** SOAP_FMAC4 soap_get_PointerTons4__OperationStepTypes(struct soap *soap, enum ns4__OperationStepTypes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__OperationStepTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates(struct soap *soap, enum ns3__OperationProcInfo_x002eOperationStepInfoStates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfoStates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates(struct soap *soap, const char *tag, int id, enum ns3__OperationProcInfo_x002eOperationStepInfoStates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfoStates, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__OperationProcInfo_x002eOperationStepInfoStates(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns3__OperationProcInfo_x002eOperationStepInfoStates ** SOAP_FMAC4 soap_in_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates(struct soap *soap, const char *tag, enum ns3__OperationProcInfo_x002eOperationStepInfoStates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns3__OperationProcInfo_x002eOperationStepInfoStates **)soap_malloc(soap, sizeof(enum ns3__OperationProcInfo_x002eOperationStepInfoStates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__OperationProcInfo_x002eOperationStepInfoStates(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns3__OperationProcInfo_x002eOperationStepInfoStates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfoStates, sizeof(enum ns3__OperationProcInfo_x002eOperationStepInfoStates), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates(struct soap *soap, enum ns3__OperationProcInfo_x002eOperationStepInfoStates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates(soap, tag ? tag : "ns3:OperationProcInfo.OperationStepInfoStates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__OperationProcInfo_x002eOperationStepInfoStates ** SOAP_FMAC4 soap_get_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates(struct soap *soap, enum ns3__OperationProcInfo_x002eOperationStepInfoStates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__OperationProcInfo_x002eOperationStepInfoStates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_double);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodouble(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__OperationProcInfo_x002eOperationStepInfo(struct soap *soap, ns3__OperationProcInfo_x002eOperationStepInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__OperationProcInfo_x002eOperationStepInfo(struct soap *soap, const char *tag, int id, ns3__OperationProcInfo_x002eOperationStepInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo ? type : NULL);
}

SOAP_FMAC3 ns3__OperationProcInfo_x002eOperationStepInfo ** SOAP_FMAC4 soap_in_PointerTons3__OperationProcInfo_x002eOperationStepInfo(struct soap *soap, const char *tag, ns3__OperationProcInfo_x002eOperationStepInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__OperationProcInfo_x002eOperationStepInfo **)soap_malloc(soap, sizeof(ns3__OperationProcInfo_x002eOperationStepInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__OperationProcInfo_x002eOperationStepInfo *)soap_instantiate_ns3__OperationProcInfo_x002eOperationStepInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__OperationProcInfo_x002eOperationStepInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo, sizeof(ns3__OperationProcInfo_x002eOperationStepInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__OperationProcInfo_x002eOperationStepInfo(struct soap *soap, ns3__OperationProcInfo_x002eOperationStepInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__OperationProcInfo_x002eOperationStepInfo(soap, tag ? tag : "ns3:OperationProcInfo.OperationStepInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__OperationProcInfo_x002eOperationStepInfo ** SOAP_FMAC4 soap_get_PointerTons3__OperationProcInfo_x002eOperationStepInfo(struct soap *soap, ns3__OperationProcInfo_x002eOperationStepInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__OperationProcInfo_x002eOperationStepInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__OperationProcInfo_x002eControlParamInfo(struct soap *soap, ns3__OperationProcInfo_x002eControlParamInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__OperationProcInfo_x002eControlParamInfo(struct soap *soap, const char *tag, int id, ns3__OperationProcInfo_x002eControlParamInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo ? type : NULL);
}

SOAP_FMAC3 ns3__OperationProcInfo_x002eControlParamInfo ** SOAP_FMAC4 soap_in_PointerTons3__OperationProcInfo_x002eControlParamInfo(struct soap *soap, const char *tag, ns3__OperationProcInfo_x002eControlParamInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__OperationProcInfo_x002eControlParamInfo **)soap_malloc(soap, sizeof(ns3__OperationProcInfo_x002eControlParamInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__OperationProcInfo_x002eControlParamInfo *)soap_instantiate_ns3__OperationProcInfo_x002eControlParamInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__OperationProcInfo_x002eControlParamInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo, sizeof(ns3__OperationProcInfo_x002eControlParamInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__OperationProcInfo_x002eControlParamInfo(struct soap *soap, ns3__OperationProcInfo_x002eControlParamInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__OperationProcInfo_x002eControlParamInfo(soap, tag ? tag : "ns3:OperationProcInfo.ControlParamInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__OperationProcInfo_x002eControlParamInfo ** SOAP_FMAC4 soap_get_PointerTons3__OperationProcInfo_x002eControlParamInfo(struct soap *soap, ns3__OperationProcInfo_x002eControlParamInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__OperationProcInfo_x002eControlParamInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToarr__ArrayOfstring(struct soap *soap, arr__ArrayOfstring *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_arr__ArrayOfstring))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToarr__ArrayOfstring(struct soap *soap, const char *tag, int id, arr__ArrayOfstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_arr__ArrayOfstring, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_arr__ArrayOfstring ? type : NULL);
}

SOAP_FMAC3 arr__ArrayOfstring ** SOAP_FMAC4 soap_in_PointerToarr__ArrayOfstring(struct soap *soap, const char *tag, arr__ArrayOfstring **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (arr__ArrayOfstring **)soap_malloc(soap, sizeof(arr__ArrayOfstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (arr__ArrayOfstring *)soap_instantiate_arr__ArrayOfstring(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (arr__ArrayOfstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_arr__ArrayOfstring, sizeof(arr__ArrayOfstring), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToarr__ArrayOfstring(struct soap *soap, arr__ArrayOfstring *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToarr__ArrayOfstring(soap, tag ? tag : "arr:ArrayOfstring", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 arr__ArrayOfstring ** SOAP_FMAC4 soap_get_PointerToarr__ArrayOfstring(struct soap *soap, arr__ArrayOfstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToarr__ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo(struct soap *soap, ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo(struct soap *soap, const char *tag, int id, ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo(struct soap *soap, const char *tag, ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo **)soap_malloc(soap, sizeof(ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *)soap_instantiate_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo, sizeof(ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo(struct soap *soap, ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, tag ? tag : "ns3:ArrayOfOperationProcInfo.OperationStepInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo(struct soap *soap, ns3__ArrayOfOperationProcInfo_x002eOperationStepInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfOperationProcInfo_x002eOperationStepInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo(struct soap *soap, ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo(struct soap *soap, const char *tag, int id, ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfOperationProcInfo_x002eControlParamInfo ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo(struct soap *soap, const char *tag, ns3__ArrayOfOperationProcInfo_x002eControlParamInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfOperationProcInfo_x002eControlParamInfo **)soap_malloc(soap, sizeof(ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *)soap_instantiate_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfOperationProcInfo_x002eControlParamInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfOperationProcInfo_x002eControlParamInfo, sizeof(ns3__ArrayOfOperationProcInfo_x002eControlParamInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo(struct soap *soap, ns3__ArrayOfOperationProcInfo_x002eControlParamInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, tag ? tag : "ns3:ArrayOfOperationProcInfo.ControlParamInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfOperationProcInfo_x002eControlParamInfo ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo(struct soap *soap, ns3__ArrayOfOperationProcInfo_x002eControlParamInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfOperationProcInfo_x002eControlParamInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ProcessingModes(struct soap *soap, enum ns3__ProcessingModes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns3__ProcessingModes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ProcessingModes(struct soap *soap, const char *tag, int id, enum ns3__ProcessingModes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ProcessingModes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__ProcessingModes(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns3__ProcessingModes ** SOAP_FMAC4 soap_in_PointerTons3__ProcessingModes(struct soap *soap, const char *tag, enum ns3__ProcessingModes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns3__ProcessingModes **)soap_malloc(soap, sizeof(enum ns3__ProcessingModes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__ProcessingModes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns3__ProcessingModes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ProcessingModes, sizeof(enum ns3__ProcessingModes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ProcessingModes(struct soap *soap, enum ns3__ProcessingModes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ProcessingModes(soap, tag ? tag : "ns3:ProcessingModes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__ProcessingModes ** SOAP_FMAC4 soap_get_PointerTons3__ProcessingModes(struct soap *soap, enum ns3__ProcessingModes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ProcessingModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__OperationProcInfo(struct soap *soap, ns3__OperationProcInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__OperationProcInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__OperationProcInfo(struct soap *soap, const char *tag, int id, ns3__OperationProcInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__OperationProcInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__OperationProcInfo ? type : NULL);
}

SOAP_FMAC3 ns3__OperationProcInfo ** SOAP_FMAC4 soap_in_PointerTons3__OperationProcInfo(struct soap *soap, const char *tag, ns3__OperationProcInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__OperationProcInfo **)soap_malloc(soap, sizeof(ns3__OperationProcInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__OperationProcInfo *)soap_instantiate_ns3__OperationProcInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__OperationProcInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__OperationProcInfo, sizeof(ns3__OperationProcInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__OperationProcInfo(struct soap *soap, ns3__OperationProcInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__OperationProcInfo(soap, tag ? tag : "ns3:OperationProcInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__OperationProcInfo ** SOAP_FMAC4 soap_get_PointerTons3__OperationProcInfo(struct soap *soap, ns3__OperationProcInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__OperationProcInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__ArrayOfEEvent(struct soap *soap, ns10__ArrayOfEEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns10__ArrayOfEEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__ArrayOfEEvent(struct soap *soap, const char *tag, int id, ns10__ArrayOfEEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__ArrayOfEEvent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns10__ArrayOfEEvent ? type : NULL);
}

SOAP_FMAC3 ns10__ArrayOfEEvent ** SOAP_FMAC4 soap_in_PointerTons10__ArrayOfEEvent(struct soap *soap, const char *tag, ns10__ArrayOfEEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns10__ArrayOfEEvent **)soap_malloc(soap, sizeof(ns10__ArrayOfEEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns10__ArrayOfEEvent *)soap_instantiate_ns10__ArrayOfEEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns10__ArrayOfEEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__ArrayOfEEvent, sizeof(ns10__ArrayOfEEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__ArrayOfEEvent(struct soap *soap, ns10__ArrayOfEEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons10__ArrayOfEEvent(soap, tag ? tag : "ns10:ArrayOfEEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns10__ArrayOfEEvent ** SOAP_FMAC4 soap_get_PointerTons10__ArrayOfEEvent(struct soap *soap, ns10__ArrayOfEEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__ArrayOfEEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__ESample(struct soap *soap, ns10__ESample *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns10__ESample))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__ESample(struct soap *soap, const char *tag, int id, ns10__ESample *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__ESample, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns10__ESample ? type : NULL);
}

SOAP_FMAC3 ns10__ESample ** SOAP_FMAC4 soap_in_PointerTons10__ESample(struct soap *soap, const char *tag, ns10__ESample **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns10__ESample **)soap_malloc(soap, sizeof(ns10__ESample *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns10__ESample *)soap_instantiate_ns10__ESample(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns10__ESample **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__ESample, sizeof(ns10__ESample), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__ESample(struct soap *soap, ns10__ESample *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons10__ESample(soap, tag ? tag : "ns10:ESample", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns10__ESample ** SOAP_FMAC4 soap_get_PointerTons10__ESample(struct soap *soap, ns10__ESample **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__ESample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__ArrayOfESample(struct soap *soap, ns10__ArrayOfESample *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns10__ArrayOfESample))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__ArrayOfESample(struct soap *soap, const char *tag, int id, ns10__ArrayOfESample *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__ArrayOfESample, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns10__ArrayOfESample ? type : NULL);
}

SOAP_FMAC3 ns10__ArrayOfESample ** SOAP_FMAC4 soap_in_PointerTons10__ArrayOfESample(struct soap *soap, const char *tag, ns10__ArrayOfESample **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns10__ArrayOfESample **)soap_malloc(soap, sizeof(ns10__ArrayOfESample *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns10__ArrayOfESample *)soap_instantiate_ns10__ArrayOfESample(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns10__ArrayOfESample **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__ArrayOfESample, sizeof(ns10__ArrayOfESample), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__ArrayOfESample(struct soap *soap, ns10__ArrayOfESample *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons10__ArrayOfESample(soap, tag ? tag : "ns10:ArrayOfESample", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns10__ArrayOfESample ** SOAP_FMAC4 soap_get_PointerTons10__ArrayOfESample(struct soap *soap, ns10__ArrayOfESample **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__ArrayOfESample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__ESampleTypes(struct soap *soap, enum ns10__ESampleTypes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns10__ESampleTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__ESampleTypes(struct soap *soap, const char *tag, int id, enum ns10__ESampleTypes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__ESampleTypes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns10__ESampleTypes(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns10__ESampleTypes ** SOAP_FMAC4 soap_in_PointerTons10__ESampleTypes(struct soap *soap, const char *tag, enum ns10__ESampleTypes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns10__ESampleTypes **)soap_malloc(soap, sizeof(enum ns10__ESampleTypes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns10__ESampleTypes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns10__ESampleTypes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__ESampleTypes, sizeof(enum ns10__ESampleTypes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__ESampleTypes(struct soap *soap, enum ns10__ESampleTypes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons10__ESampleTypes(soap, tag ? tag : "ns10:ESampleTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns10__ESampleTypes ** SOAP_FMAC4 soap_get_PointerTons10__ESampleTypes(struct soap *soap, enum ns10__ESampleTypes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__ESampleTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__SystemConfigurations(struct soap *soap, ns5__SystemConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__SystemConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__SystemConfigurations(struct soap *soap, const char *tag, int id, ns5__SystemConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__SystemConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__SystemConfigurations ? type : NULL);
}

SOAP_FMAC3 ns5__SystemConfigurations ** SOAP_FMAC4 soap_in_PointerTons5__SystemConfigurations(struct soap *soap, const char *tag, ns5__SystemConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__SystemConfigurations **)soap_malloc(soap, sizeof(ns5__SystemConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__SystemConfigurations *)soap_instantiate_ns5__SystemConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__SystemConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__SystemConfigurations, sizeof(ns5__SystemConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__SystemConfigurations(struct soap *soap, ns5__SystemConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__SystemConfigurations(soap, tag ? tag : "ns5:SystemConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__SystemConfigurations ** SOAP_FMAC4 soap_get_PointerTons5__SystemConfigurations(struct soap *soap, ns5__SystemConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__SystemConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ProcessingInfo(struct soap *soap, ns3__ProcessingInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ProcessingInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ProcessingInfo(struct soap *soap, const char *tag, int id, ns3__ProcessingInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ProcessingInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__ProcessingInfo ? type : NULL);
}

SOAP_FMAC3 ns3__ProcessingInfo ** SOAP_FMAC4 soap_in_PointerTons3__ProcessingInfo(struct soap *soap, const char *tag, ns3__ProcessingInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ProcessingInfo **)soap_malloc(soap, sizeof(ns3__ProcessingInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ProcessingInfo *)soap_instantiate_ns3__ProcessingInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ProcessingInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ProcessingInfo, sizeof(ns3__ProcessingInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ProcessingInfo(struct soap *soap, ns3__ProcessingInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ProcessingInfo(soap, tag ? tag : "ns3:ProcessingInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ProcessingInfo ** SOAP_FMAC4 soap_get_PointerTons3__ProcessingInfo(struct soap *soap, ns3__ProcessingInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ProcessingInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons10__EEvent(struct soap *soap, std::vector<ns10__EEvent *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons10__EEvent(struct soap *soap, const std::vector<ns10__EEvent *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns10__EEvent *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons10__EEvent(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons10__EEvent(struct soap *soap, const char *tag, int id, const std::vector<ns10__EEvent *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns10__EEvent *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons10__EEvent(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns10__EEvent *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons10__EEvent(struct soap *soap, const char *tag, std::vector<ns10__EEvent *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons10__EEvent(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns10__EEvent *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns10__EEvent, SOAP_TYPE_std__vectorTemplateOfPointerTons10__EEvent, sizeof(ns10__EEvent), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons10__EEvent(soap, tag, NULL, "ns10:EEvent"))
				break;
		}
		else
		{	if (!soap_in_PointerTons10__EEvent(soap, tag, &n, "ns10:EEvent"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns10__EEvent *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons10__EEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons10__EEvent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns10__EEvent *> *p;
	size_t k = sizeof(std::vector<ns10__EEvent *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons10__EEvent, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns10__EEvent *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns10__EEvent *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns10__EEvent *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons10__EResult(struct soap *soap, std::vector<ns10__EResult *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons10__EResult(struct soap *soap, const std::vector<ns10__EResult *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns10__EResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons10__EResult(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons10__EResult(struct soap *soap, const char *tag, int id, const std::vector<ns10__EResult *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns10__EResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons10__EResult(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns10__EResult *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons10__EResult(struct soap *soap, const char *tag, std::vector<ns10__EResult *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons10__EResult(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns10__EResult *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns10__EResult, SOAP_TYPE_std__vectorTemplateOfPointerTons10__EResult, sizeof(ns10__EResult), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons10__EResult(soap, tag, NULL, "ns10:EResult"))
				break;
		}
		else
		{	if (!soap_in_PointerTons10__EResult(soap, tag, &n, "ns10:EResult"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns10__EResult *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons10__EResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons10__EResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns10__EResult *> *p;
	size_t k = sizeof(std::vector<ns10__EResult *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons10__EResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns10__EResult *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns10__EResult *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns10__EResult *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons10__ESample(struct soap *soap, std::vector<ns10__ESample *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons10__ESample(struct soap *soap, const std::vector<ns10__ESample *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns10__ESample *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons10__ESample(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons10__ESample(struct soap *soap, const char *tag, int id, const std::vector<ns10__ESample *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns10__ESample *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons10__ESample(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns10__ESample *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons10__ESample(struct soap *soap, const char *tag, std::vector<ns10__ESample *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons10__ESample(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns10__ESample *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns10__ESample, SOAP_TYPE_std__vectorTemplateOfPointerTons10__ESample, sizeof(ns10__ESample), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons10__ESample(soap, tag, NULL, "ns10:ESample"))
				break;
		}
		else
		{	if (!soap_in_PointerTons10__ESample(soap, tag, &n, "ns10:ESample"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns10__ESample *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons10__ESample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons10__ESample(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns10__ESample *> *p;
	size_t k = sizeof(std::vector<ns10__ESample *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons10__ESample, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns10__ESample *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns10__ESample *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns10__ESample *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__AuxDeviceState(struct soap *soap, std::vector<ns7__AuxDeviceState *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__AuxDeviceState(struct soap *soap, const std::vector<ns7__AuxDeviceState *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns7__AuxDeviceState *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__AuxDeviceState(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__AuxDeviceState(struct soap *soap, const char *tag, int id, const std::vector<ns7__AuxDeviceState *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns7__AuxDeviceState *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__AuxDeviceState(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__AuxDeviceState *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__AuxDeviceState(struct soap *soap, const char *tag, std::vector<ns7__AuxDeviceState *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__AuxDeviceState(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns7__AuxDeviceState *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns7__AuxDeviceState, SOAP_TYPE_std__vectorTemplateOfPointerTons7__AuxDeviceState, sizeof(ns7__AuxDeviceState), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons7__AuxDeviceState(soap, tag, NULL, "ns7:AuxDeviceState"))
				break;
		}
		else
		{	if (!soap_in_PointerTons7__AuxDeviceState(soap, tag, &n, "ns7:AuxDeviceState"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns7__AuxDeviceState *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons7__AuxDeviceState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__AuxDeviceState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns7__AuxDeviceState *> *p;
	size_t k = sizeof(std::vector<ns7__AuxDeviceState *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons7__AuxDeviceState, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns7__AuxDeviceState *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns7__AuxDeviceState *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns7__AuxDeviceState *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__AuxDevice(struct soap *soap, std::vector<ns7__AuxDevice *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__AuxDevice(struct soap *soap, const std::vector<ns7__AuxDevice *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns7__AuxDevice *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__AuxDevice(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__AuxDevice(struct soap *soap, const char *tag, int id, const std::vector<ns7__AuxDevice *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns7__AuxDevice *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__AuxDevice(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__AuxDevice *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__AuxDevice(struct soap *soap, const char *tag, std::vector<ns7__AuxDevice *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__AuxDevice(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns7__AuxDevice *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns7__AuxDevice, SOAP_TYPE_std__vectorTemplateOfPointerTons7__AuxDevice, sizeof(ns7__AuxDevice), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons7__AuxDevice(soap, tag, NULL, "ns7:AuxDevice"))
				break;
		}
		else
		{	if (!soap_in_PointerTons7__AuxDevice(soap, tag, &n, "ns7:AuxDevice"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns7__AuxDevice *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons7__AuxDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__AuxDevice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns7__AuxDevice *> *p;
	size_t k = sizeof(std::vector<ns7__AuxDevice *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons7__AuxDevice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns7__AuxDevice *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns7__AuxDevice *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns7__AuxDevice *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfbool(struct soap *soap, std::vector<bool> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfbool(struct soap *soap, const std::vector<bool> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfbool(struct soap *soap, const char *tag, int id, const std::vector<bool> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<bool> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		bool b = (*i);
		if (soap_out_bool(soap, tag, id, &b, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<bool> * SOAP_FMAC4 soap_in_std__vectorTemplateOfbool(struct soap *soap, const char *tag, std::vector<bool> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfbool(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		bool n;
		soap_default_bool(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_bool, SOAP_TYPE_std__vectorTemplateOfbool, sizeof(bool), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_bool(soap, tag, NULL, "xsd:boolean"))
				break;
		}
		else
		{	if (!soap_in_bool(soap, tag, &n, "xsd:boolean"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<bool>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfbool(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfbool(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<bool> *p;
	size_t k = sizeof(std::vector<bool> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfbool, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<bool> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<bool> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<bool>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_std__string(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr(struct soap *soap, std::vector<ns4__OperationStep_x002eUsingControlledParametr *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr(struct soap *soap, const std::vector<ns4__OperationStep_x002eUsingControlledParametr *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns4__OperationStep_x002eUsingControlledParametr *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__OperationStep_x002eUsingControlledParametr(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr(struct soap *soap, const char *tag, int id, const std::vector<ns4__OperationStep_x002eUsingControlledParametr *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns4__OperationStep_x002eUsingControlledParametr *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__OperationStep_x002eUsingControlledParametr(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__OperationStep_x002eUsingControlledParametr *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr(struct soap *soap, const char *tag, std::vector<ns4__OperationStep_x002eUsingControlledParametr *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns4__OperationStep_x002eUsingControlledParametr *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns4__OperationStep_x002eUsingControlledParametr, SOAP_TYPE_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr, sizeof(ns4__OperationStep_x002eUsingControlledParametr), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons4__OperationStep_x002eUsingControlledParametr(soap, tag, NULL, "ns4:OperationStep.UsingControlledParametr"))
				break;
		}
		else
		{	if (!soap_in_PointerTons4__OperationStep_x002eUsingControlledParametr(soap, tag, &n, "ns4:OperationStep.UsingControlledParametr"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__OperationStep_x002eUsingControlledParametr *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns4__OperationStep_x002eUsingControlledParametr *> *p;
	size_t k = sizeof(std::vector<ns4__OperationStep_x002eUsingControlledParametr *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons4__OperationStep_x002eUsingControlledParametr, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns4__OperationStep_x002eUsingControlledParametr *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns4__OperationStep_x002eUsingControlledParametr *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns4__OperationStep_x002eUsingControlledParametr *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__OperationStep(struct soap *soap, std::vector<ns4__OperationStep *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__OperationStep(struct soap *soap, const std::vector<ns4__OperationStep *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns4__OperationStep *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__OperationStep(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__OperationStep(struct soap *soap, const char *tag, int id, const std::vector<ns4__OperationStep *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns4__OperationStep *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__OperationStep(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__OperationStep *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__OperationStep(struct soap *soap, const char *tag, std::vector<ns4__OperationStep *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__OperationStep(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns4__OperationStep *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns4__OperationStep, SOAP_TYPE_std__vectorTemplateOfPointerTons4__OperationStep, sizeof(ns4__OperationStep), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons4__OperationStep(soap, tag, NULL, "ns4:OperationStep"))
				break;
		}
		else
		{	if (!soap_in_PointerTons4__OperationStep(soap, tag, &n, "ns4:OperationStep"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__OperationStep *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__OperationStep(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__OperationStep(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns4__OperationStep *> *p;
	size_t k = sizeof(std::vector<ns4__OperationStep *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons4__OperationStep, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns4__OperationStep *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns4__OperationStep *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns4__OperationStep *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__Operation(struct soap *soap, std::vector<ns4__Operation *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__Operation(struct soap *soap, const std::vector<ns4__Operation *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns4__Operation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__Operation(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__Operation(struct soap *soap, const char *tag, int id, const std::vector<ns4__Operation *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns4__Operation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__Operation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__Operation *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__Operation(struct soap *soap, const char *tag, std::vector<ns4__Operation *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__Operation(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns4__Operation *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns4__Operation, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Operation, sizeof(ns4__Operation), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons4__Operation(soap, tag, NULL, "ns4:Operation"))
				break;
		}
		else
		{	if (!soap_in_PointerTons4__Operation(soap, tag, &n, "ns4:Operation"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__Operation *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__Operation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__Operation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns4__Operation *> *p;
	size_t k = sizeof(std::vector<ns4__Operation *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Operation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns4__Operation *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns4__Operation *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns4__Operation *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__MeasuringComponent(struct soap *soap, std::vector<ns4__MeasuringComponent *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__MeasuringComponent(struct soap *soap, const std::vector<ns4__MeasuringComponent *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns4__MeasuringComponent *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__MeasuringComponent(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__MeasuringComponent(struct soap *soap, const char *tag, int id, const std::vector<ns4__MeasuringComponent *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns4__MeasuringComponent *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__MeasuringComponent(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__MeasuringComponent *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__MeasuringComponent(struct soap *soap, const char *tag, std::vector<ns4__MeasuringComponent *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__MeasuringComponent(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns4__MeasuringComponent *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns4__MeasuringComponent, SOAP_TYPE_std__vectorTemplateOfPointerTons4__MeasuringComponent, sizeof(ns4__MeasuringComponent), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons4__MeasuringComponent(soap, tag, NULL, "ns4:MeasuringComponent"))
				break;
		}
		else
		{	if (!soap_in_PointerTons4__MeasuringComponent(soap, tag, &n, "ns4:MeasuringComponent"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__MeasuringComponent *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__MeasuringComponent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__MeasuringComponent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns4__MeasuringComponent *> *p;
	size_t k = sizeof(std::vector<ns4__MeasuringComponent *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons4__MeasuringComponent, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns4__MeasuringComponent *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns4__MeasuringComponent *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns4__MeasuringComponent *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__ControlledParametr(struct soap *soap, std::vector<ns4__ControlledParametr *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__ControlledParametr(struct soap *soap, const std::vector<ns4__ControlledParametr *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns4__ControlledParametr *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__ControlledParametr(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__ControlledParametr(struct soap *soap, const char *tag, int id, const std::vector<ns4__ControlledParametr *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns4__ControlledParametr *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__ControlledParametr(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__ControlledParametr *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__ControlledParametr(struct soap *soap, const char *tag, std::vector<ns4__ControlledParametr *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__ControlledParametr(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns4__ControlledParametr *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns4__ControlledParametr, SOAP_TYPE_std__vectorTemplateOfPointerTons4__ControlledParametr, sizeof(ns4__ControlledParametr), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons4__ControlledParametr(soap, tag, NULL, "ns4:ControlledParametr"))
				break;
		}
		else
		{	if (!soap_in_PointerTons4__ControlledParametr(soap, tag, &n, "ns4:ControlledParametr"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__ControlledParametr *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__ControlledParametr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__ControlledParametr(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns4__ControlledParametr *> *p;
	size_t k = sizeof(std::vector<ns4__ControlledParametr *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons4__ControlledParametr, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns4__ControlledParametr *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns4__ControlledParametr *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns4__ControlledParametr *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime(struct soap *soap, std::vector<ns4__Periodicity_x002eTime *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime(struct soap *soap, const std::vector<ns4__Periodicity_x002eTime *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns4__Periodicity_x002eTime *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__Periodicity_x002eTime(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime(struct soap *soap, const char *tag, int id, const std::vector<ns4__Periodicity_x002eTime *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns4__Periodicity_x002eTime *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__Periodicity_x002eTime(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__Periodicity_x002eTime *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime(struct soap *soap, const char *tag, std::vector<ns4__Periodicity_x002eTime *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns4__Periodicity_x002eTime *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns4__Periodicity_x002eTime, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime, sizeof(ns4__Periodicity_x002eTime), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons4__Periodicity_x002eTime(soap, tag, NULL, "ns4:Periodicity.Time"))
				break;
		}
		else
		{	if (!soap_in_PointerTons4__Periodicity_x002eTime(soap, tag, &n, "ns4:Periodicity.Time"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__Periodicity_x002eTime *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns4__Periodicity_x002eTime *> *p;
	size_t k = sizeof(std::vector<ns4__Periodicity_x002eTime *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons4__Periodicity_x002eTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns4__Periodicity_x002eTime *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns4__Periodicity_x002eTime *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns4__Periodicity_x002eTime *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__AutoPlanItem(struct soap *soap, std::vector<ns4__AutoPlanItem *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__AutoPlanItem(struct soap *soap, const std::vector<ns4__AutoPlanItem *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns4__AutoPlanItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__AutoPlanItem(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__AutoPlanItem(struct soap *soap, const char *tag, int id, const std::vector<ns4__AutoPlanItem *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns4__AutoPlanItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__AutoPlanItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__AutoPlanItem *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__AutoPlanItem(struct soap *soap, const char *tag, std::vector<ns4__AutoPlanItem *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__AutoPlanItem(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns4__AutoPlanItem *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns4__AutoPlanItem, SOAP_TYPE_std__vectorTemplateOfPointerTons4__AutoPlanItem, sizeof(ns4__AutoPlanItem), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons4__AutoPlanItem(soap, tag, NULL, "ns4:AutoPlanItem"))
				break;
		}
		else
		{	if (!soap_in_PointerTons4__AutoPlanItem(soap, tag, &n, "ns4:AutoPlanItem"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__AutoPlanItem *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__AutoPlanItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__AutoPlanItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns4__AutoPlanItem *> *p;
	size_t k = sizeof(std::vector<ns4__AutoPlanItem *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons4__AutoPlanItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns4__AutoPlanItem *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns4__AutoPlanItem *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns4__AutoPlanItem *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo(struct soap *soap, std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo(struct soap *soap, const std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__OperationProcInfo_x002eOperationStepInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__OperationProcInfo_x002eOperationStepInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo(struct soap *soap, const char *tag, std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__OperationProcInfo_x002eOperationStepInfo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns3__OperationProcInfo_x002eOperationStepInfo, SOAP_TYPE_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo, sizeof(ns3__OperationProcInfo_x002eOperationStepInfo), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons3__OperationProcInfo_x002eOperationStepInfo(soap, tag, NULL, "ns3:OperationProcInfo.OperationStepInfo"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__OperationProcInfo_x002eOperationStepInfo(soap, tag, &n, "ns3:OperationProcInfo.OperationStepInfo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> *p;
	size_t k = sizeof(std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eOperationStepInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__OperationProcInfo_x002eOperationStepInfo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo(struct soap *soap, std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo(struct soap *soap, const std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__OperationProcInfo_x002eControlParamInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo(struct soap *soap, const char *tag, int id, const std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__OperationProcInfo_x002eControlParamInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo(struct soap *soap, const char *tag, std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__OperationProcInfo_x002eControlParamInfo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns3__OperationProcInfo_x002eControlParamInfo, SOAP_TYPE_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo, sizeof(ns3__OperationProcInfo_x002eControlParamInfo), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons3__OperationProcInfo_x002eControlParamInfo(soap, tag, NULL, "ns3:OperationProcInfo.ControlParamInfo"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__OperationProcInfo_x002eControlParamInfo(soap, tag, &n, "ns3:OperationProcInfo.ControlParamInfo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__OperationProcInfo_x002eControlParamInfo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> *p;
	size_t k = sizeof(std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons3__OperationProcInfo_x002eControlParamInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__OperationProcInfo_x002eControlParamInfo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__OperationProcInfo_x002eControlParamInfo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
